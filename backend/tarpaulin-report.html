<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","Users","andrewinci","Development","insulator2","backend","build.rs"],"content":"fn main() {\n    tauri_build::build()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","api","admin.rs"],"content":"use std::collections::HashMap;\n\nuse log::debug;\n\nuse crate::lib::{\n    admin::{ConsumerGroupInfo, PartitionOffset, Topic, TopicInfo},\n    consumer::types::ConsumerSessionConfiguration,\n};\n\nuse super::{error::ApiResult, AppState};\n\n#[tauri::command]\npub async fn list_topics(cluster_id: \u0026str, state: tauri::State\u003c'_, AppState\u003e) -\u003e ApiResult\u003cVec\u003cTopic\u003e\u003e {\n    debug!(\"Retrieve the list of topics\");\n    let cluster = state.get_cluster(cluster_id).await?;\n    Ok(cluster.kafka_admin_client.list_topics().await?)\n}\n\n#[tauri::command]\npub async fn get_topic_info(\n    cluster_id: \u0026str,\n    topic_name: \u0026str,\n    state: tauri::State\u003c'_, AppState\u003e,\n) -\u003e ApiResult\u003cTopicInfo\u003e {\n    debug!(\"Retrieve topic info for {}\", topic_name);\n    let cluster = state.get_cluster(cluster_id).await?;\n    Ok(cluster.kafka_admin_client.get_topic_info(topic_name).await?)\n}\n\n#[tauri::command]\npub async fn delete_topic(cluster_id: \u0026str, topic_name: \u0026str, state: tauri::State\u003c'_, AppState\u003e) -\u003e ApiResult\u003c()\u003e {\n    debug!(\"Deleting topic {}\", topic_name);\n    let cluster = state.get_cluster(cluster_id).await?;\n    Ok(cluster.kafka_admin_client.delete_topic(topic_name).await?)\n}\n\n#[tauri::command]\npub async fn create_topic(\n    cluster_id: \u0026str,\n    topic_name: \u0026str,\n    partitions: i32,\n    isr: i32,\n    compacted: bool,\n    state: tauri::State\u003c'_, AppState\u003e,\n) -\u003e ApiResult\u003c()\u003e {\n    debug!(\"Create new topic\");\n    let cluster = state.get_cluster(cluster_id).await?;\n    Ok(cluster\n        .kafka_admin_client\n        .create_topic(topic_name, partitions, isr, compacted)\n        .await?)\n}\n\n#[tauri::command]\npub async fn list_consumer_groups(cluster_id: \u0026str, state: tauri::State\u003c'_, AppState\u003e) -\u003e ApiResult\u003cVec\u003cString\u003e\u003e {\n    debug!(\"Retrieve the list of consumer groups\");\n    let cluster = state.get_cluster(cluster_id).await?;\n    Ok(cluster.kafka_admin_client.list_consumer_groups()?)\n}\n\n#[tauri::command]\npub async fn describe_consumer_group(\n    cluster_id: \u0026str,\n    consumer_group_name: \u0026str,\n    ignore_cache: Option\u003cbool\u003e,\n    state: tauri::State\u003c'_, AppState\u003e,\n) -\u003e ApiResult\u003cConsumerGroupInfo\u003e {\n    debug!(\"Describe consumer group\");\n    let cluster = state.get_cluster(cluster_id).await?;\n    Ok(cluster\n        .kafka_admin_client\n        .describe_consumer_group(consumer_group_name, ignore_cache.unwrap_or(false))\n        .await?)\n}\n\n#[tauri::command]\npub async fn get_consumer_group_state(\n    cluster_id: \u0026str,\n    consumer_group_name: \u0026str,\n    state: tauri::State\u003c'_, AppState\u003e,\n) -\u003e ApiResult\u003cString\u003e {\n    debug!(\"Get consumer group\");\n    let cluster = state.get_cluster(cluster_id).await?;\n    Ok(cluster\n        .kafka_admin_client\n        .get_consumer_group_state(consumer_group_name)?)\n}\n\n#[tauri::command]\npub async fn set_consumer_group(\n    cluster_id: \u0026str,\n    consumer_group_name: \u0026str,\n    topics: Vec\u003c\u0026str\u003e,\n    offset_config: ConsumerSessionConfiguration,\n    state: tauri::State\u003c'_, AppState\u003e,\n) -\u003e ApiResult\u003c()\u003e {\n    debug!(\"Create consumer group {}\", consumer_group_name);\n    let cluster = state.get_cluster(cluster_id).await?;\n    Ok(cluster\n        .kafka_admin_client\n        .set_consumer_group(consumer_group_name, \u0026topics, \u0026offset_config)?)\n}\n\n#[tauri::command]\npub async fn get_last_offsets(\n    cluster_id: \u0026str,\n    topic_names: Vec\u003c\u0026str\u003e,\n    state: tauri::State\u003c'_, AppState\u003e,\n) -\u003e ApiResult\u003cHashMap\u003cString, Vec\u003cPartitionOffset\u003e\u003e\u003e {\n    debug!(\"Get last offset for topics {:?}\", topic_names);\n    let cluster = state.get_cluster(cluster_id).await?;\n    Ok(cluster.kafka_admin_client.get_last_offsets(\u0026topic_names).await?)\n}\n\n#[tauri::command]\npub async fn delete_consumer_group(\n    cluster_id: \u0026str,\n    consumer_group_name: \u0026str,\n    state: tauri::State\u003c'_, AppState\u003e,\n) -\u003e ApiResult\u003c()\u003e {\n    debug!(\"Deleting consumer group {}\", consumer_group_name);\n    let cluster = state.get_cluster(cluster_id).await?;\n    Ok(cluster\n        .kafka_admin_client\n        .delete_consumer_group(consumer_group_name)\n        .await?)\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":53},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","api","cluster.rs"],"content":"use log::{debug, trace};\nuse std::{collections::HashMap, sync::Arc};\nuse tokio::sync::RwLock;\n\nuse crate::lib::{\n    admin::KafkaAdmin,\n    configuration::InsulatorConfig,\n    consumer::{ConsumerError, KafkaConsumer},\n    error_callback::ErrorCallback,\n    parser::Parser,\n    producer::KafkaProducer,\n    record_store::SqliteStore,\n    record_store::TopicStore,\n    schema_registry::CachedSchemaRegistry,\n};\n\nuse super::error::{ApiError, ApiResult};\n\ntype TopicName = String;\n\npub struct Cluster {\n    pub cluster_id: String,\n    pub config: InsulatorConfig,\n    pub schema_registry_client: Option\u003cArc\u003cCachedSchemaRegistry\u003e\u003e,\n    pub kafka_admin_client: Arc\u003cKafkaAdmin\u003e,\n    pub kafka_producer: Arc\u003cKafkaProducer\u003e,\n    pub parser: Arc\u003cParser\u003e,\n    pub store: Arc\u003cSqliteStore\u003e,\n    active_kafka_consumers: Arc\u003cRwLock\u003cHashMap\u003cTopicName, Arc\u003cKafkaConsumer\u003e\u003e\u003e\u003e,\n    error_callback: ErrorCallback\u003cApiError\u003e,\n}\n\nimpl Cluster {\n    pub fn new(cluster_id: \u0026str, config: \u0026InsulatorConfig, error_callback: ErrorCallback\u003cApiError\u003e) -\u003e ApiResult\u003cSelf\u003e {\n        let cluster_config = config.get_cluster_config(cluster_id)?;\n        let (schema_registry_client, parser) = {\n            if let Some(s_config) = \u0026cluster_config.schema_registry {\n                let ptr = Arc::new(CachedSchemaRegistry::new(\n                    s_config.endpoint.as_str(),\n                    s_config.username.as_deref(),\n                    s_config.password.as_deref(),\n                ));\n                (Some(ptr.clone()), Arc::new(Parser::new(Some(ptr))))\n            } else {\n                (None, Arc::new(Parser::new(None)))\n            }\n        };\n        Ok(Cluster {\n            cluster_id: cluster_id.to_string(),\n            schema_registry_client,\n            active_kafka_consumers: Arc::new(RwLock::new(HashMap::new())),\n            kafka_admin_client: Arc::new(KafkaAdmin::new(\u0026cluster_config, config.get_kafka_tmo())?),\n            kafka_producer: Arc::new(KafkaProducer::new(\u0026cluster_config, parser.clone())),\n            parser,\n            store: Arc::new(SqliteStore::new(config.get_sql_tmo())),\n            error_callback,\n            config: config.clone(),\n        })\n    }\n\n    pub async fn get_consumer(\u0026self, topic_name: \u0026str) -\u003e Arc\u003cKafkaConsumer\u003e {\n        {\n            if let Some(consumer) = self.active_kafka_consumers.read().await.get(topic_name) {\n                trace!(\"Consumer for {} found in cache\", topic_name);\n                return consumer.clone();\n            }\n        }\n        {\n            debug!(\"Create consumer for topic {}\", topic_name);\n            let cluster_config = self\n                .config\n                .get_cluster_config(\u0026self.cluster_id)\n                .expect(\"Cluster id not found\"); //todo: bubble up the error\n\n            // create a new table for the consumer\n            let topic_store =\n                TopicStore::from_record_store(self.store.clone(), self.parser.clone(), \u0026self.cluster_id, topic_name);\n            // build the consumer callback\n            let error_cb = self.error_callback.clone();\n            let consumer_callback: ErrorCallback\u003cConsumerError\u003e = Arc::new(move |err| (*error_cb)(err.into()));\n            let consumer = Arc::new(KafkaConsumer::new(\n                \u0026cluster_config,\n                topic_name,\n                topic_store,\n                consumer_callback,\n                self.config.get_kafka_tmo(),\n            ));\n            self.active_kafka_consumers\n                .write()\n                .await\n                .insert(topic_name.to_string(), consumer.clone());\n            consumer\n        }\n    }\n\n    pub async fn get_topic_store(\u0026self, topic_name: \u0026str) -\u003e Arc\u003cTopicStore\u003e {\n        let consumer = self.get_consumer(topic_name).await;\n        consumer.topic_store.clone()\n    }\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":46},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","api","configuration.rs"],"content":"use log::debug;\n\nuse crate::lib::configuration::InsulatorConfig;\n\nuse super::{error::ApiResult, AppState};\n\n#[tauri::command]\npub fn get_configuration(state: tauri::State\u003c'_, AppState\u003e) -\u003e ApiResult\u003cInsulatorConfig\u003e {\n    debug!(\"Retrieve configuration\");\n    Ok(state.configuration_provider.get_configuration()?)\n}\n\n#[tauri::command]\npub fn write_configuration(\n    configuration: InsulatorConfig,\n    state: tauri::State\u003c'_, AppState\u003e,\n) -\u003e ApiResult\u003cInsulatorConfig\u003e {\n    debug!(\"Write configuration\");\n    Ok(state\n        .configuration_provider\n        .write_configuration(\u0026configuration)\n        .map(|_| configuration)?)\n}\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":9},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","api","consumer.rs"],"content":"use log::debug;\n\nuse crate::lib::{\n    consumer::{types::ConsumerState, ConsumerConfiguration},\n    record_store::types::ExportOptions,\n};\n\nuse super::{error::ApiResult, types::GetPageResponse, AppState};\n\n#[tauri::command]\npub async fn start_consumer(\n    cluster_id: \u0026str,\n    topic: \u0026str,\n    config: ConsumerConfiguration,\n    state: tauri::State\u003c'_, AppState\u003e,\n) -\u003e ApiResult\u003c()\u003e {\n    let consumer = state.get_cluster(cluster_id).await?.get_consumer(topic).await;\n    Ok(consumer.start(\u0026config).await?)\n}\n\n#[tauri::command]\npub async fn get_consumer_state(\n    cluster_id: \u0026str,\n    topic: \u0026str,\n    state: tauri::State\u003c'_, AppState\u003e,\n) -\u003e ApiResult\u003cConsumerState\u003e {\n    let consumer = state.get_cluster(cluster_id).await?.get_consumer(topic).await;\n    Ok(consumer.get_consumer_state().await?)\n}\n\n#[tauri::command]\npub async fn stop_consumer(cluster_id: \u0026str, topic: \u0026str, state: tauri::State\u003c'_, AppState\u003e) -\u003e ApiResult\u003c()\u003e {\n    let consumer = state.get_cluster(cluster_id).await?.get_consumer(topic).await;\n    Ok(consumer.stop().await?)\n}\n\n#[tauri::command]\npub async fn get_records_page(\n    cluster_id: \u0026str,\n    topic: \u0026str,\n    page_number: usize,\n    query: Option\u003c\u0026str\u003e,\n    state: tauri::State\u003c'_, AppState\u003e,\n) -\u003e ApiResult\u003cGetPageResponse\u003e {\n    debug!(\"Get records page\");\n    const PAGE_SIZE: usize = 20;\n    let cluster = state.get_cluster(cluster_id).await?;\n    let topic_store = cluster.get_topic_store(topic).await;\n    let records = topic_store.get_records(query, (page_number * PAGE_SIZE) as i64, PAGE_SIZE as i64, None)?;\n    let records_count = records.len();\n    Ok(GetPageResponse {\n        records,\n        next_page: if records_count == PAGE_SIZE {\n            Some(page_number + 1)\n        } else {\n            None\n        },\n        prev_page: if page_number \u003e= 1 { Some(page_number - 1) } else { None },\n    })\n}\n\n#[tauri::command]\npub async fn export_records(\n    cluster_id: \u0026str,\n    topic: \u0026str,\n    options: ExportOptions,\n    state: tauri::State\u003c'_, AppState\u003e,\n) -\u003e ApiResult\u003c()\u003e {\n    let store = state.get_cluster(cluster_id).await?.get_topic_store(topic).await;\n    Ok(store.export_records(\u0026options)?)\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":24},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","api","error.rs"],"content":"use crate::lib::{\n    admin::AdminError, avro::AvroError, configuration::ConfigError, consumer::ConsumerError, producer::ProducerError,\n    record_store::StoreError, schema_registry::SchemaRegistryError,\n};\nuse serde::{Deserialize, Serialize};\n\npub type ApiResult\u003cT\u003e = std::result::Result\u003cT, ApiError\u003e;\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct ApiError {\n    #[serde(rename = \"errorType\")]\n    pub error_type: String,\n    pub message: String,\n}\n\nimpl From\u003cSchemaRegistryError\u003e for ApiError {\n    fn from(err: SchemaRegistryError) -\u003e Self {\n        match err {\n            SchemaRegistryError::SchemaNotFound(message) =\u003e ApiError {\n                error_type: \"Schema registry error: Schema not found\".into(),\n                message,\n            },\n            SchemaRegistryError::SchemaParsing(message) =\u003e ApiError {\n                error_type: \"Schema registry error: Unable to parse the schema\".into(),\n                message,\n            },\n            SchemaRegistryError::HttpClient(message) =\u003e ApiError {\n                error_type: \"Schema registry error: HTTPClient\".into(),\n                message,\n            },\n            SchemaRegistryError::InvalidUrl(message) =\u003e ApiError {\n                error_type: \"Schema registry error: Invalid URL\".into(),\n                message,\n            },\n        }\n    }\n}\n\nimpl From\u003cStoreError\u003e for ApiError {\n    fn from(value: StoreError) -\u003e Self {\n        match value {\n            StoreError::SqlError(message) =\u003e ApiError {\n                error_type: \"Records store error: SQL\".into(),\n                message,\n            },\n            StoreError::IO(message) =\u003e ApiError {\n                error_type: \"Records store error: IO\".into(),\n                message,\n            },\n            StoreError::RecordParse(message) =\u003e ApiError {\n                error_type: \"Records store error: Parsing the record\".into(),\n                message,\n            },\n        }\n    }\n}\n\nimpl From\u003cConsumerError\u003e for ApiError {\n    fn from(value: ConsumerError) -\u003e Self {\n        match value {\n            ConsumerError::RDKafka(message) =\u003e ApiError {\n                error_type: \"Consumer error: RDKafkaLib\".into(),\n                message,\n            },\n            ConsumerError::RecordStore(_, records_store_error) =\u003e records_store_error.into(),\n            ConsumerError::AlreadyRunning(message) =\u003e ApiError {\n                error_type: \"Consumer error\".into(),\n                message,\n            },\n        }\n    }\n}\n\nimpl From\u003cAdminError\u003e for ApiError {\n    fn from(value: AdminError) -\u003e Self {\n        match value {\n            AdminError::TopicNotFound(topic_name) =\u003e ApiError {\n                error_type: \"Admin client\".into(),\n                message: format!(\"Topic {} not found.\", topic_name),\n            },\n            AdminError::RDKafka(message) =\u003e ApiError {\n                error_type: \"RDKafkaLib error\".into(),\n                message,\n            },\n            AdminError::ConsumerError(consumer_error) =\u003e consumer_error.into(),\n        }\n    }\n}\n\nimpl From\u003cConfigError\u003e for ApiError {\n    fn from(value: ConfigError) -\u003e Self {\n        match value {\n            ConfigError::IO(msg) =\u003e ApiError {\n                error_type: \"IO error handling user configurations\".into(),\n                message: msg,\n            },\n            ConfigError::JSONSerde(msg) =\u003e ApiError {\n                error_type: \"JSON error handling user configurations\".into(),\n                message: msg,\n            },\n            ConfigError::TOMLSerde(msg) =\u003e ApiError {\n                error_type: \"TOML error handling user configurations\".into(),\n                message: msg,\n            },\n            ConfigError::LegacyConfiguration(msg) =\u003e ApiError {\n                error_type: \"Error loading the legacy configuration\".into(),\n                message: msg,\n            },\n            ConfigError::ClusterNotFound(cluster_id) =\u003e ApiError {\n                error_type: \"User configuration error\".into(),\n                message: format!(\"Cluster {} not found\", cluster_id),\n            },\n        }\n    }\n}\n\nimpl From\u003cProducerError\u003e for ApiError {\n    fn from(value: ProducerError) -\u003e Self {\n        match value {\n            ProducerError::MissingAvroConfiguration =\u003e Self {\n                error_type: \"Missing avro configuration\".into(),\n                message: \"Unable to parse the record to avro\".into(),\n            },\n            ProducerError::RDKafka(message) =\u003e ApiError {\n                error_type: \"RDKafkaLib error trying to produce\".into(),\n                message,\n            },\n            ProducerError::AvroParse(avro_error) =\u003e avro_error.into(),\n        }\n    }\n}\n\nimpl From\u003cAvroError\u003e for ApiError {\n    fn from(value: AvroError) -\u003e Self {\n        match value {\n            AvroError::InvalidNumber(message) =\u003e ApiError {\n                error_type: \"Avro error: InvalidNumber\".into(),\n                message,\n            },\n            AvroError::MissingAvroSchemaReference(message) =\u003e ApiError {\n                error_type: \"Avro error: MissingAvroSchemaReference\".into(),\n                message,\n            },\n            AvroError::MissingField(message) =\u003e ApiError {\n                error_type: \"Avro error: MissingField\".into(),\n                message,\n            },\n            AvroError::SchemaProvider(message, _) =\u003e ApiError {\n                error_type: \"Avro error: SchemaProvider\".into(),\n                message,\n            },\n            AvroError::InvalidUnion(message) =\u003e ApiError {\n                error_type: \"Avro error: InvalidUnion\".into(),\n                message,\n            },\n            AvroError::Unsupported(message) =\u003e ApiError {\n                error_type: \"Avro error: Unsupported\".into(),\n                message,\n            },\n            AvroError::InvalidAvroHeader(message) =\u003e ApiError {\n                error_type: \"Avro error: InvalidAvroHeader\".into(),\n                message,\n            },\n            AvroError::ParseAvroValue(message) =\u003e ApiError {\n                error_type: \"Avro error: ParseAvroValue\".into(),\n                message,\n            },\n            AvroError::ParseJsonValue(message) =\u003e ApiError {\n                error_type: \"Avro error: ParseJsonValue\".into(),\n                message,\n            },\n            AvroError::InvalidEnum(message) =\u003e ApiError {\n                error_type: \"Avro error: InvalidEnum\".into(),\n                message,\n            },\n        }\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":48},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","api","mod.rs"],"content":"pub mod admin;\nmod cluster;\npub mod configuration;\npub mod consumer;\nmod error;\nmod notification;\npub mod producer;\npub mod schema_registry;\nmod state;\nmod types;\npub mod utils;\npub use state::AppState;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","api","notification.rs"],"content":"use tauri::{AppHandle, Manager};\n\nuse super::error::ApiError;\n\npub fn _notify_error(error_type: \u0026str, message: \u0026str, app: \u0026AppHandle) {\n    app.app_handle()\n        .emit_all(\n            \"error\",\n            ApiError {\n                error_type: error_type.to_string(),\n                message: message.to_string(),\n            },\n        )\n        .expect(\"unable to send a notification to the frontend\");\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":5},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","api","producer.rs"],"content":"use crate::lib::types::ParserMode;\n\nuse super::{error::ApiResult, AppState};\n\n#[tauri::command]\npub async fn produce_record(\n    cluster_id: \u0026str,\n    topic: \u0026str,\n    key: \u0026str,\n    value: Option\u003c\u0026str\u003e, // None would be a tombstone\n    mode: ParserMode,\n    state: tauri::State\u003c'_, AppState\u003e,\n) -\u003e ApiResult\u003c()\u003e {\n    let cluster = state.get_cluster(cluster_id).await?;\n    Ok(cluster.kafka_producer.produce(topic, key, value, mode).await?)\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","api","schema_registry.rs"],"content":"use crate::lib::schema_registry::Subject;\nuse log::debug;\n\nuse super::{\n    error::{ApiError, ApiResult},\n    AppState,\n};\n\n#[tauri::command]\npub async fn list_subjects(cluster_id: \u0026str, state: tauri::State\u003c'_, AppState\u003e) -\u003e ApiResult\u003cVec\u003cString\u003e\u003e {\n    debug!(\"List schema schema registry subjects\");\n    let client = state.get_schema_reg_client(cluster_id).await?.ok_or(ApiError {\n        error_type: \"Configuration error\".into(),\n        message: \"Missing schema registry configuration\".into(),\n    })?;\n    Ok(client.list_subjects().await?)\n}\n\n#[tauri::command]\npub async fn get_subject(subject_name: \u0026str, cluster_id: \u0026str, state: tauri::State\u003c'_, AppState\u003e) -\u003e ApiResult\u003cSubject\u003e {\n    debug!(\"Retrieve all schema version for subject {}\", subject_name);\n    let client = state.get_schema_reg_client(cluster_id).await?.ok_or(ApiError {\n        error_type: \"Configuration error\".into(),\n        message: \"Missing schema registry configuration\".into(),\n    })?;\n    Ok(client.get_subject(subject_name).await?)\n}\n\n#[tauri::command]\npub async fn delete_subject(subject_name: \u0026str, cluster_id: \u0026str, state: tauri::State\u003c'_, AppState\u003e) -\u003e ApiResult\u003c()\u003e {\n    debug!(\"Deleting subject {}\", subject_name);\n    let client = state.get_schema_reg_client(cluster_id).await?.ok_or(ApiError {\n        error_type: \"Configuration error\".into(),\n        message: \"Missing schema registry configuration\".into(),\n    })?;\n    Ok(client.delete_subject(subject_name).await?)\n}\n\n#[tauri::command]\npub async fn delete_subject_version(\n    subject_name: \u0026str,\n    version: i32,\n    cluster_id: \u0026str,\n    state: tauri::State\u003c'_, AppState\u003e,\n) -\u003e ApiResult\u003c()\u003e {\n    debug!(\"Deleting subject {} version {}\", subject_name, version);\n    let client = state.get_schema_reg_client(cluster_id).await?.ok_or(ApiError {\n        error_type: \"Configuration error\".into(),\n        message: \"Missing schema registry configuration\".into(),\n    })?;\n    Ok(client.delete_version(subject_name, version).await?)\n}\n\n#[tauri::command]\npub async fn post_schema(\n    subject_name: \u0026str,\n    schema: \u0026str,\n    cluster_id: \u0026str,\n    state: tauri::State\u003c'_, AppState\u003e,\n) -\u003e ApiResult\u003c()\u003e {\n    debug!(\"Create subject {}\", subject_name);\n    let client = state.get_schema_reg_client(cluster_id).await?.ok_or(ApiError {\n        error_type: \"Configuration error\".into(),\n        message: \"Missing schema registry configuration\".into(),\n    })?;\n    Ok(client.post_schema(subject_name, schema).await?)\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":30},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","api","state.rs"],"content":"use std::{collections::HashMap, sync::Arc};\n\nuse log::debug;\nuse tauri::Manager;\nuse tokio::sync::RwLock;\n\nuse crate::lib::{\n    configuration::ConfigurationProvider, error_callback::ErrorCallback, schema_registry::CachedSchemaRegistry,\n};\n\nuse super::{\n    cluster::Cluster,\n    error::{ApiError, ApiResult},\n};\n\ntype ClusterId = String;\n\npub struct AppState {\n    clusters: Arc\u003cRwLock\u003cHashMap\u003cClusterId, Arc\u003cCluster\u003e\u003e\u003e\u003e,\n    pub configuration_provider: Arc\u003cConfigurationProvider\u003e,\n    error_callback: ErrorCallback\u003cApiError\u003e,\n}\n\nimpl AppState {\n    pub fn new(app_handle: tauri::AppHandle) -\u003e Self {\n        AppState {\n            clusters: Default::default(),\n            configuration_provider: Arc::new(ConfigurationProvider::new()),\n            error_callback: Arc::new(move |err| {\n                app_handle.emit_all(\"error\", err).ok();\n            }),\n        }\n    }\n\n    pub async fn get_cluster(\u0026self, cluster_id: \u0026str) -\u003e ApiResult\u003cArc\u003cCluster\u003e\u003e {\n        {\n            if let Some(cluster) = self.clusters.read().await.get(cluster_id) {\n                return Ok(cluster.clone());\n            }\n        }\n        {\n            debug!(\"Init cluster {}\", cluster_id);\n            let cluster = self.build_new_cluster(cluster_id, self.error_callback.clone())?;\n            let cluster = Arc::new(cluster);\n            self.clusters.write().await.insert(cluster_id.into(), cluster.clone());\n            Ok(cluster)\n        }\n    }\n\n    pub async fn get_schema_reg_client(\u0026self, cluster_id: \u0026str) -\u003e ApiResult\u003cOption\u003cArc\u003cCachedSchemaRegistry\u003e\u003e\u003e {\n        let cluster = self.get_cluster(cluster_id).await?;\n        Ok(cluster.schema_registry_client.as_ref().cloned())\n    }\n\n    fn build_new_cluster(\u0026self, cluster_id: \u0026str, error_callback: ErrorCallback\u003cApiError\u003e) -\u003e ApiResult\u003cCluster\u003e {\n        debug!(\"Init cluster {}\", cluster_id);\n        let configuration = self.configuration_provider.get_configuration()?;\n        Cluster::new(cluster_id, \u0026configuration, error_callback)\n    }\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":19},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","api","types.rs"],"content":"use serde::Serialize;\n\nuse crate::lib::types::ParsedKafkaRecord;\n\n#[derive(Serialize, Debug)]\npub struct GetPageResponse {\n    pub records: Vec\u003cParsedKafkaRecord\u003e,\n    #[serde(rename = \"nextPage\")]\n    pub next_page: Option\u003cusize\u003e,\n    #[serde(rename = \"prevPage\")]\n    pub prev_page: Option\u003cusize\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","api","utils.rs"],"content":"use log::{debug, error};\n\nuse super::error::{ApiError, ApiResult};\nuse super::AppState;\nuse rust_keystore::KeyStore;\nuse serde::{Deserialize, Serialize};\n\n#[tauri::command]\npub async fn export_datastore(cluster_id: \u0026str, output_path: \u0026str, state: tauri::State\u003c'_, AppState\u003e) -\u003e ApiResult\u003c()\u003e {\n    debug!(\"Start export database\");\n    Ok(state.get_cluster(cluster_id).await?.store.export_db(output_path)?)\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct UserCertificate {\n    certificate: String,\n    key: String,\n}\n\n#[tauri::command]\npub async fn parse_truststore(location: \u0026str, password: Option\u003c\u0026str\u003e) -\u003e ApiResult\u003cString\u003e {\n    debug!(\"Parsing truststore {}\", \u0026location);\n    let ca_certificate = KeyStore::try_load(location)\n        .and_then(|c| c.certificates(password))\n        .map(|certs| certs[0].pem.clone());\n    ca_certificate.map_err(|err| {\n        error!(\"Unable to load the truststore: {:?}\", err);\n        ApiError {\n            error_type: \"Legacy config\".into(),\n            message: \"Unable to correctly parse the truststore\".into(),\n        }\n    })\n}\n\n#[tauri::command]\npub async fn parse_keystore(location: \u0026str, password: Option\u003c\u0026str\u003e) -\u003e ApiResult\u003cUserCertificate\u003e {\n    debug!(\"Parsing keystore {}\", \u0026location);\n    let user_cert = KeyStore::try_load(location)\n        .and_then(|c| c.certificates(password))\n        .map(|certs| certs[0].clone());\n\n    if let Ok(certificate) = user_cert {\n        if let (certificate, Some(key)) = (certificate.pem, certificate.private_key) {\n            return Ok(UserCertificate {\n                certificate,\n                key: key.pkcs8_pem,\n            });\n        }\n    }\n    Err(ApiError {\n        error_type: \"Legacy config\".into(),\n        message: \"Unable to correctly parse the keystore\".into(),\n    })\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":26},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","integration_tests","consumer_group_admin_it.rs"],"content":"#![cfg(test)]\nuse rdkafka::{\n    consumer::{BaseConsumer, Consumer},\n    producer::{BaseProducer, BaseRecord},\n};\nuse std::time::Duration;\n\nuse crate::{integration_tests::KafkaTest, lib::admin::KafkaAdmin};\n\n#[tokio::test]\nasync fn test_consumer_groups_admin_client() {\n    // arrange\n    let test_fixture = KafkaTest::new();\n\n    let consumer: BaseConsumer = test_fixture.build_kafka_client();\n    let producer: BaseProducer = test_fixture.build_kafka_client();\n    let cluster_config = test_fixture.build_cluster_config();\n\n    let sut = KafkaAdmin::new(\u0026cluster_config, test_fixture.tmo).expect(\"Unable to create the admin client\");\n    let test_topic_name = \"test_topic_name\";\n    // produce a record to create the topic\n    producer\n        .send(BaseRecord::to(\u0026test_topic_name).key(\"key\").payload(\"content\"))\n        .expect(\"Unable to produce the message\");\n\n    // test list consumer groups\n    {\n        // arrange\n        // create a consumer group by consuming the test topic\n        consumer\n            .subscribe(\u0026[\u0026test_topic_name])\n            .expect(\"Unable to subscribe to the test topic\");\n        let consumed = consumer.poll(Duration::from_secs(60)).unwrap();\n        assert!(consumed.is_ok());\n        // act\n        let res = sut.list_consumer_groups().expect(\"\");\n        // assert\n        assert_eq!(res, vec![test_fixture.default_consumer_group])\n    }\n\n    // test create consumer groups\n    {\n        let test_consumer_group = \"test-consumer-group\";\n        // act\n        let res = sut.set_consumer_group(\n            test_consumer_group,\n            \u0026[\u0026test_topic_name],\n            \u0026crate::lib::consumer::types::ConsumerSessionConfiguration::Beginning,\n        );\n        // assert\n        assert!(res.is_ok());\n        let consumer_groups = consumer\n            .fetch_group_list(None, test_fixture.tmo)\n            .expect(\"Unable to retrieve the list of consumer groups\");\n        assert!(!consumer_groups\n            .groups()\n            .iter()\n            .filter(|cg| cg.name() == test_consumer_group)\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .is_empty())\n    }\n\n    // test delete consumer group\n    {\n        let test_consumer_group = \"test-delete-consumer-group\";\n        sut.set_consumer_group(\n            test_consumer_group,\n            \u0026[\u0026test_topic_name],\n            \u0026crate::lib::consumer::types::ConsumerSessionConfiguration::Beginning,\n        )\n        .expect(\"Unable to create the consumer group for the test\");\n        // act\n        let res = sut.delete_consumer_group(test_consumer_group).await;\n        // assert\n        assert!(res.is_ok());\n        let consumer_groups = consumer\n            .fetch_group_list(None, test_fixture.tmo)\n            .expect(\"Unable to retrieve the list of consumer groups\");\n        assert!(consumer_groups\n            .groups()\n            .iter()\n            .filter(|cg| cg.name() == test_consumer_group)\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .is_empty())\n    }\n\n    // test describe consumer group\n    {\n        let test_consumer_group = \"test-delete-consumer-group\";\n        sut.set_consumer_group(\n            test_consumer_group,\n            \u0026[\u0026test_topic_name],\n            \u0026crate::lib::consumer::types::ConsumerSessionConfiguration::Beginning,\n        )\n        .expect(\"Unable to create the consumer group for the test\");\n        // act\n        let res = sut\n            .describe_consumer_group(test_consumer_group, true)\n            .await\n            .expect(\"Unable to describe the consumer group\");\n        // assert\n        assert_eq!(res.offsets.len(), 1);\n        assert_eq!(res.offsets[0].offset, 0);\n        assert_eq!(res.offsets[0].topic, test_topic_name);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","integration_tests","mod.rs"],"content":"#![cfg(test)]\n\nuse once_cell::sync::Lazy;\nuse rdkafka::{config::FromClientConfig, ClientConfig};\nuse std::time::Duration;\nuse testcontainers::{clients, images::kafka};\n\nuse crate::lib::configuration::{ClusterConfig, Favorites};\n\nmod consumer_group_admin_it;\nmod topic_admin_it;\n\nstatic DOCKER: Lazy\u003cclients::Cli\u003e = Lazy::new(clients::Cli::default);\n\nstruct KafkaTest\u003c'a\u003e {\n    pub tmo: Duration,\n    pub default_consumer_group: String,\n    pub bootstrap_servers: String,\n    _kafka_node: testcontainers::Container\u003c'a, kafka::Kafka\u003e,\n}\n\nimpl\u003c'a\u003e KafkaTest\u003c'a\u003e {\n    fn new() -\u003e Self {\n        let tmo = Duration::from_secs(30);\n        let kafka_node = DOCKER.run(kafka::Kafka::default());\n\n        let bootstrap_servers = format!(\"127.0.0.1:{}\", kafka_node.get_host_port_ipv4(kafka::KAFKA_PORT));\n        kafka_node.start();\n\n        Self {\n            tmo,\n            default_consumer_group: \"testcontainer-rs\".into(),\n            bootstrap_servers,\n            _kafka_node: kafka_node,\n        }\n    }\n\n    fn build_kafka_client\u003cT: FromClientConfig\u003e(\u0026self) -\u003e T {\n        ClientConfig::new()\n            .set(\"group.id\", self.default_consumer_group.to_string())\n            .set(\"bootstrap.servers\", self.bootstrap_servers.to_string())\n            .set(\"session.timeout.ms\", \"6000\")\n            .set(\"enable.auto.commit\", \"true\")\n            .set(\"auto.offset.reset\", \"earliest\")\n            .create()\n            .expect(\"Unable to create the kafka client\")\n    }\n\n    fn build_cluster_config(\u0026self) -\u003e ClusterConfig {\n        ClusterConfig {\n            id: \"cluster-id\".into(),\n            name: \"test-cluster-name\".into(),\n            endpoint: self.bootstrap_servers.to_string(),\n            authentication: crate::lib::configuration::AuthenticationConfig::None,\n            schema_registry: None,\n            favorites: Favorites::default(),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","integration_tests","topic_admin_it.rs"],"content":"#![cfg(test)]\n\nuse rdkafka::{\n    consumer::{stream_consumer::StreamConsumer, Consumer},\n    producer::{FutureProducer, FutureRecord},\n};\nuse std::{collections::HashSet, time::Duration};\n\nuse crate::{integration_tests::KafkaTest, lib::admin::KafkaAdmin};\n\n#[tokio::test]\nasync fn test_topic_admin_client() {\n    // arrange\n    let test_fixture = KafkaTest::new();\n\n    let consumer: StreamConsumer = test_fixture.build_kafka_client();\n    let cluster_config = test_fixture.build_cluster_config();\n\n    let sut = KafkaAdmin::new(\u0026cluster_config, test_fixture.tmo).expect(\"Unable to create the admin client\");\n\n    // test create a topic\n    {\n        let test_topic_name = \"test_topic_name\";\n        let partition_count = 7_usize;\n        // act\n        sut.create_topic(test_topic_name, partition_count as i32, 1, false)\n            .await\n            .expect(\"Unable to create the test topic\");\n\n        // assert\n        let metadata = consumer\n            .fetch_metadata(None, test_fixture.tmo)\n            .expect(\"Unable to retrieve the metadata\");\n        let tp: Vec\u003c_\u003e = metadata\n            .topics()\n            .iter()\n            .map(|t| (t.name(), t.partitions().len()))\n            .collect();\n\n        assert!(tp.contains(\u0026(test_topic_name, partition_count)))\n    }\n\n    // test retrieve the list of topics\n    {\n        sut.create_topic(\"another_test_topic\", 1, 1, true)\n            .await\n            .expect(\"Unable to create a test topic\");\n        // act\n        let res = sut.list_topics().await.expect(\"Unable to retrieve the list of topics\");\n        // assert\n        let topic_set: HashSet\u003c_\u003e = res.iter().map(|t| (t.name.clone(), t.partitions.len())).collect();\n        let metadata = consumer\n            .fetch_metadata(None, test_fixture.tmo)\n            .expect(\"Unable to retrieve the metadata\");\n\n        let expected_topics: HashSet\u003c_\u003e = metadata\n            .topics()\n            .iter()\n            .map(|t| (t.name().to_string(), t.partitions().len()))\n            .collect();\n\n        assert_eq!(topic_set, expected_topics)\n    }\n\n    // test get topic\n    {\n        // arrange\n        let test_topic_name = \"test_get_topic\";\n        let partition_count = 3_usize;\n        sut.create_topic(test_topic_name, partition_count as i32, 1, true)\n            .await\n            .expect(\"Unable to create a test topic\");\n        // act\n        let res = sut.get_topic(test_topic_name).expect(\"Unable to get topic\");\n        // assert\n        assert_eq!(res.name, test_topic_name.to_string());\n        assert_eq!(res.partitions.len(), partition_count);\n    }\n\n    // test get topic info\n    {\n        // arrange\n        let test_topic_name = \"test_get_topic_info\";\n        let partition_count = 3_usize;\n        sut.create_topic(test_topic_name, partition_count as i32, 1, true)\n            .await\n            .expect(\"Unable to create a test topic\");\n        // act\n        let res = sut.get_topic_info(test_topic_name).await.expect(\"get_topic_info error\");\n        // assert\n        assert_eq!(res.name, test_topic_name.to_string());\n        assert_eq!(res.partitions.len(), partition_count);\n        assert_eq!(\n            res.configurations.get(\"cleanup.policy\").unwrap(),\n            \u0026Some(\"compact\".to_string())\n        );\n    }\n\n    // delete topic test\n    {\n        // arrange\n        let test_topic_name = \"test_delete_topic\";\n        sut.create_topic(test_topic_name, 1, 1, true)\n            .await\n            .expect(\"Unable to create a test topic\");\n        // act\n        let res = sut.delete_topic(test_topic_name).await;\n        // assert\n        assert!(res.is_ok())\n    }\n\n    // get last offset\n    {\n        // arrange\n        let expected_offset = 13;\n        let test_topic_name = \"test_get_last_offset\";\n        let producer: FutureProducer = test_fixture.build_kafka_client();\n        sut.create_topic(test_topic_name, 1, 1, true)\n            .await\n            .expect(\"Unable to create a test topic\");\n        // produce some records to increase the offset\n        for i in 0..expected_offset {\n            producer\n                .send(\n                    FutureRecord::to(test_topic_name)\n                        .payload(\u0026format!(\"test_message {}\", i))\n                        .key(\u0026format!(\"Key {}\", i)),\n                    Duration::from_secs(0),\n                )\n                .await\n                .expect(\"Unable to produce the message\");\n        }\n        // act\n        let res = sut\n            .get_last_offsets(\u0026[test_topic_name])\n            .await\n            .expect(\"get_last_offsets error\");\n\n        // assert\n        let topic_result = res.get(test_topic_name).expect(\"Invalid result\");\n        // since there is only one partition we expect to get only one offset\n        assert_eq!(topic_result.len(), 1);\n        assert_eq!(topic_result[0].offset, expected_offset)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","admin","client.rs"],"content":"use std::sync::Arc;\nuse std::time::Duration;\n\nuse crate::lib::configuration::{build_kafka_client_config, ClusterConfig};\nuse log::debug;\nuse rdkafka::admin::AdminClient;\nuse rdkafka::{client::DefaultClientContext, consumer::BaseConsumer};\nuse rdkafka::{Offset, TopicPartitionList};\nuse tokio::sync::RwLock;\n\nuse super::error::AdminResult;\n\npub struct KafkaAdmin {\n    pub(super) config: ClusterConfig,\n    pub(super) timeout: Duration,\n    pub(super) consumer: BaseConsumer,\n    pub(super) admin_client: AdminClient\u003cDefaultClientContext\u003e,\n    pub(super) all_topic_partition_list: Arc\u003cRwLock\u003cTopicPartitionList\u003e\u003e,\n}\n\nimpl KafkaAdmin {\n    pub fn new(config: \u0026ClusterConfig, kafka_timeout: Duration) -\u003e AdminResult\u003cSelf\u003e {\n        Ok(KafkaAdmin {\n            config: config.clone(),\n            timeout: kafka_timeout,\n            consumer: build_kafka_client_config(config, None).create()?,\n            admin_client: build_kafka_client_config(config, None).create()?,\n            all_topic_partition_list: Arc::new(RwLock::new(TopicPartitionList::new())),\n        })\n    }\n\n    pub(super) async fn get_all_topic_partition_list(\u0026self, ignore_cache: bool) -\u003e AdminResult\u003cTopicPartitionList\u003e {\n        {\n            let topic_partition_list = self.all_topic_partition_list.read().await;\n            if !ignore_cache \u0026\u0026 topic_partition_list.count() \u003e 0 {\n                return Ok(topic_partition_list.clone());\n            }\n        }\n        let mut topic_partition_list = TopicPartitionList::new();\n        debug!(\"Retrieve the list of all topics/partition\");\n        let topics = self.list_topics().await?;\n        debug!(\"Build the topic/partition list\");\n        for topic in topics {\n            for partition in topic.partitions {\n                topic_partition_list.add_partition_offset(\u0026topic.name, partition.id, Offset::End)?;\n            }\n        }\n        {\n            *self.all_topic_partition_list.write().await = topic_partition_list.clone();\n        }\n        Ok(topic_partition_list)\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":116},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":17,"coverable":20},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","admin","consumer_admin.rs"],"content":"use log::{debug, trace};\n\nuse super::{error::AdminResult, ConsumerGroupInfo, KafkaAdmin};\nuse crate::lib::{\n    admin::TopicPartitionOffset,\n    configuration::build_kafka_client_config,\n    consumer::{types::ConsumerSessionConfiguration, KafkaConsumer},\n};\nuse rdkafka::{\n    admin::AdminOptions,\n    consumer::{BaseConsumer, Consumer},\n};\nuse rdkafka::{consumer::CommitMode, Offset};\n\nimpl KafkaAdmin {\n    pub async fn delete_consumer_group(\u0026self, consumer_group_name: \u0026str) -\u003e AdminResult\u003c()\u003e {\n        debug!(\"Deleting consumer group {}\", consumer_group_name);\n        let res = self\n            .admin_client\n            .delete_groups(\u0026[consumer_group_name], \u0026AdminOptions::default())\n            .await?;\n        assert_eq!(res.len(), 1);\n        match res.first().unwrap() {\n            Ok(_) =\u003e Ok(()),\n            Err(err) =\u003e Err(err.1.into()),\n        }\n    }\n\n    pub fn set_consumer_group(\n        \u0026self,\n        consumer_group_name: \u0026str,\n        topic_names: \u0026[\u0026str],\n        config: \u0026ConsumerSessionConfiguration,\n    ) -\u003e AdminResult\u003c()\u003e {\n        let consumer = build_kafka_client_config(\u0026self.config, Some(consumer_group_name)).create()?;\n\n        debug!(\"assign offsets for each topic\");\n        KafkaConsumer::update_consumer_assignment(\u0026consumer, topic_names, config, self.timeout)?;\n\n        debug!(\"store offset to commit\");\n        for t in consumer.assignment()?.elements() {\n            trace!(\n                \"Store topic {:?} partition {:?} offset {:?}\",\n                t.topic(),\n                t.partition(),\n                t.offset().to_raw()\n            );\n            consumer.store_offset(t.topic(), t.partition(), t.offset().to_raw().unwrap() - 1)?;\n        }\n\n        debug!(\"commit consumer state\");\n        Ok(consumer.commit_consumer_state(CommitMode::Sync)?)\n    }\n\n    pub fn list_consumer_groups(\u0026self) -\u003e AdminResult\u003cVec\u003cString\u003e\u003e {\n        let groups = self.consumer.fetch_group_list(None, self.timeout)?;\n        let group_names: Vec\u003c_\u003e = groups.groups().iter().map(|g| g.name().to_string()).collect();\n        Ok(group_names)\n    }\n\n    pub async fn describe_consumer_group(\n        \u0026self,\n        consumer_group_name: \u0026str,\n        ignore_cache: bool,\n    ) -\u003e AdminResult\u003cConsumerGroupInfo\u003e {\n        // create a consumer with the defined consumer_group_name.\n        // NOTE: the consumer shouldn't join the consumer group, otherwise it'll cause a re-balance\n        debug!(\"Build the consumer for tsumer group {}\", consumer_group_name);\n        let consumer: BaseConsumer = build_kafka_client_config(\u0026self.config, Some(consumer_group_name)).create()?;\n\n        debug!(\"Build the topic/partition list\");\n        let topic_partition_lst = self.get_all_topic_partition_list(ignore_cache).await?;\n\n        debug!(\"Retrieve any committed offset to the consumer group\");\n        // allow up to 1 minute of tmo for big clusters and slow connections\n        let committed_offsets = consumer.committed_offsets(topic_partition_lst, self.timeout).unwrap();\n\n        debug!(\"Build API response\");\n        let offsets: Vec\u003c_\u003e = committed_offsets\n            .elements()\n            .iter()\n            .filter(|tpo| tpo.offset() != Offset::Invalid)\n            .map(|r| TopicPartitionOffset {\n                topic: r.topic().into(),\n                partition_id: r.partition(),\n                offset: r.offset().to_raw().unwrap(),\n            })\n            .collect();\n        debug!(\"Retrieve completed\");\n        Ok(ConsumerGroupInfo {\n            name: consumer_group_name.into(),\n            offsets,\n        })\n    }\n\n    pub fn get_consumer_group_state(\u0026self, consumer_group_name: \u0026str) -\u003e AdminResult\u003cString\u003e {\n        debug!(\"Retrieve consumer group status\");\n        let fetch_group_response = self\n            .consumer\n            .fetch_group_list(Some(consumer_group_name), self.timeout)?;\n        let groups: Vec\u003c_\u003e = fetch_group_response.groups().iter().collect();\n        assert_eq!(groups.len(), 1);\n        Ok(groups[0].state().to_string())\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":53},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":35,"coverable":53},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","admin","error.rs"],"content":"use rdkafka::{error::KafkaError, types::RDKafkaErrorCode};\n\nuse crate::lib::consumer::ConsumerError;\n\n#[derive(Debug)]\npub enum AdminError {\n    /// topic (Name) not found\n    TopicNotFound(String),\n    /// RDKafka errors\n    RDKafka(String),\n    // Consumer error\n    ConsumerError(ConsumerError),\n}\n\npub type AdminResult\u003cT\u003e = Result\u003cT, AdminError\u003e;\n\nimpl From\u003cKafkaError\u003e for AdminError {\n    fn from(error: KafkaError) -\u003e Self {\n        AdminError::RDKafka(error.to_string())\n    }\n}\nimpl From\u003cRDKafkaErrorCode\u003e for AdminError {\n    fn from(value: RDKafkaErrorCode) -\u003e Self {\n        AdminError::RDKafka(value.to_string())\n    }\n}\n//todo: change with the consumer error\nimpl From\u003cConsumerError\u003e for AdminError {\n    fn from(value: ConsumerError) -\u003e Self {\n        AdminError::ConsumerError(value)\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":6},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","admin","mod.rs"],"content":"mod client;\nmod consumer_admin;\nmod error;\nmod topic_admin;\nmod types;\n\npub use client::KafkaAdmin;\npub use error::*;\npub use types::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","admin","topic_admin.rs"],"content":"use log::{debug, warn};\nuse std::{collections::HashMap, vec};\n\nuse crate::lib::admin::error::AdminError;\n\nuse super::{\n    error::AdminResult,\n    types::{PartitionInfo, PartitionOffset, Topic, TopicInfo},\n    KafkaAdmin, Partition,\n};\nuse rdkafka::{admin::ResourceSpecifier, Offset, TopicPartitionList};\nuse rdkafka::{\n    admin::{AdminOptions, NewTopic, TopicReplication},\n    consumer::Consumer,\n};\n\nimpl KafkaAdmin {\n    pub async fn list_topics(\u0026self) -\u003e AdminResult\u003cVec\u003cTopic\u003e\u003e {\n        {\n            // delete cache of topics/partitions map\n            *self.all_topic_partition_list.write().await = TopicPartitionList::new();\n        }\n        self.internal_list_topics(None)\n    }\n\n    pub fn get_topic(\u0026self, topic_name: \u0026str) -\u003e AdminResult\u003cTopic\u003e {\n        let topic_list = self.internal_list_topics(Some(topic_name))?;\n        if let Some(topic) = topic_list.first() {\n            Ok(topic.to_owned())\n        } else {\n            warn!(\n                \"Topic not found or more than one topic with the same name {}\",\n                topic_name\n            );\n            Err(AdminError::TopicNotFound(topic_name.to_string()))\n        }\n    }\n\n    pub async fn delete_topic(\u0026self, topic_name: \u0026str) -\u003e AdminResult\u003c()\u003e {\n        debug!(\"Deleting topic {}\", topic_name);\n        let res = self\n            .admin_client\n            .delete_topics(\u0026[topic_name], \u0026AdminOptions::default())\n            .await?;\n        match res.first() {\n            Some(Ok(_)) =\u003e Ok(()),\n            Some(Err(err)) =\u003e Err(err.1.into()),\n            None =\u003e Err(AdminError::TopicNotFound(topic_name.to_string())),\n        }\n    }\n\n    pub async fn get_topic_info(\u0026self, topic_name: \u0026str) -\u003e AdminResult\u003cTopicInfo\u003e {\n        let topic = self.get_topic(topic_name)?;\n\n        // retrieve the last offsets\n        let mut tp = TopicPartitionList::new();\n        for p_id in 0..topic.partitions.len() {\n            tp.add_partition_offset(topic_name, p_id as i32, Offset::End)?;\n        }\n        let Topic { name, partitions } = topic;\n        Ok(TopicInfo {\n            name: name.to_string(),\n            partitions: partitions\n                .iter()\n                .map(|p| PartitionInfo {\n                    id: p.id,\n                    isr: p.isr,\n                    replicas: p.replicas,\n                })\n                .collect(),\n            configurations: self.get_topic_configuration(topic_name).await?,\n        })\n    }\n\n    // return a list in which the index is the partition id and the value is the offset\n    pub async fn get_last_offsets(\u0026self, topic_names: \u0026[\u0026str]) -\u003e AdminResult\u003cHashMap\u003cString, Vec\u003cPartitionOffset\u003e\u003e\u003e {\n        let all_partitions = self.get_all_topic_partition_list(false).await?;\n        let mut topic_partition_list = TopicPartitionList::new();\n        for topic in topic_names {\n            for tpo in all_partitions.elements_for_topic(topic) {\n                topic_partition_list.add_partition_offset(topic, tpo.partition(), Offset::End)?;\n            }\n        }\n        let offsets = self.consumer.offsets_for_times(topic_partition_list, self.timeout)?;\n        let mut res = HashMap::\u003cString, Vec\u003cPartitionOffset\u003e\u003e::new();\n        offsets.elements().iter().for_each(|t| {\n            if !res.contains_key(t.topic()) {\n                res.insert(t.topic().into(), vec![]);\n            }\n            let partition_offsets = res.get_mut(t.topic()).unwrap();\n            partition_offsets.push(PartitionOffset {\n                partition_id: t.partition(),\n                offset: t.offset().to_raw().unwrap(),\n            })\n        });\n        Ok(res)\n    }\n\n    pub async fn create_topic(\u0026self, name: \u0026str, num_partitions: i32, isr: i32, compacted: bool) -\u003e AdminResult\u003c()\u003e {\n        let new_topic = NewTopic {\n            name,\n            num_partitions,\n            config: vec![(\"cleanup.policy\", if compacted { \"compact\" } else { \"delete\" })],\n            replication: TopicReplication::Fixed(isr),\n        };\n        let res = self\n            .admin_client\n            .create_topics(vec![\u0026new_topic], \u0026AdminOptions::default())\n            .await?;\n        let res = res\n            .first()\n            .ok_or_else(|| AdminError::RDKafka(\"Invalid result from create topic api call.\".into()))?;\n        match res {\n            Ok(_) =\u003e {\n                debug!(\"Topic created successfully\");\n                Ok(())\n            }\n            Err(err) =\u003e {\n                warn!(\"{:?}\", err);\n                Err(err.1.into())\n            }\n        }\n    }\n\n    pub async fn get_topic_configuration(\u0026self, topic_name: \u0026str) -\u003e AdminResult\u003cHashMap\u003cString, Option\u003cString\u003e\u003e\u003e {\n        debug!(\"Retrieving the topic configurations\");\n        let responses = self\n            .admin_client\n            .describe_configs([\u0026ResourceSpecifier::Topic(topic_name)], \u0026AdminOptions::default())\n            .await?;\n        let mut configurations = HashMap::\u003cString, Option\u003cString\u003e\u003e::new();\n        if let Some(Ok(topic_config)) = responses.first() {\n            topic_config.entries.iter().for_each(|c| {\n                configurations.insert(c.name.clone(), c.value.as_ref().cloned());\n            });\n        }\n        Ok(configurations)\n    }\n\n    fn internal_list_topics(\u0026self, topic: Option\u003c\u0026str\u003e) -\u003e AdminResult\u003cVec\u003cTopic\u003e\u003e {\n        let topics: Vec\u003c_\u003e = self\n            .consumer\n            .fetch_metadata(topic, self.timeout)?\n            .topics()\n            .iter()\n            .map(|t| Topic {\n                name: t.name().to_string(),\n                partitions: t\n                    .partitions()\n                    .iter()\n                    .map(|m| Partition {\n                        id: m.id(),\n                        isr: m.isr().len(),\n                        replicas: m.replicas().len(),\n                    })\n                    .collect(),\n            })\n            .collect();\n        Ok(topics)\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":193},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":180},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":180},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":180},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":5},"fn_name":null}],"covered":82,"coverable":92},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","admin","types.rs"],"content":"use std::collections::HashMap;\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Topic {\n    pub name: String,\n    pub partitions: Vec\u003cPartition\u003e,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Partition {\n    pub id: i32,\n    pub isr: usize,\n    pub replicas: usize,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct TopicInfo {\n    pub name: String,\n    pub partitions: Vec\u003cPartitionInfo\u003e,\n    pub configurations: HashMap\u003cString, Option\u003cString\u003e\u003e,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct PartitionInfo {\n    pub id: i32,\n    pub isr: usize,\n    pub replicas: usize,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct ConsumerGroupInfo {\n    pub name: String,\n    pub offsets: Vec\u003cTopicPartitionOffset\u003e,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct TopicPartitionOffset {\n    pub topic: String,\n    pub partition_id: i32,\n    pub offset: i64,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct PartitionOffset {\n    #[serde(rename = \"partitionId\")]\n    pub partition_id: i32,\n    pub offset: i64,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","avro","avro_parser.rs"],"content":"use std::sync::Arc;\n\nuse super::schema_provider::SchemaProvider;\n\npub struct AvroParser\u003cS: SchemaProvider\u003e {\n    pub(super) schema_provider: Arc\u003cS\u003e,\n}\n\nimpl\u003cS: SchemaProvider\u003e AvroParser\u003cS\u003e {\n    pub fn new(schema_provider: Arc\u003cS\u003e) -\u003e Self {\n        Self { schema_provider }\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","avro","avro_to_json.rs"],"content":"use super::{\n    avro_parser::AvroParser,\n    error::{AvroError, AvroResult},\n    helpers::get_schema_id_from_record_header,\n    schema_provider::SchemaProvider,\n};\nuse apache_avro::{from_avro_datum, schema::Name, types::Value as AvroValue, Schema};\nuse num_bigint::BigInt;\nuse rust_decimal::Decimal;\nuse serde_json::{json, Map, Value as JsonValue};\nuse std::{collections::HashMap, io::Cursor};\n\nimpl\u003cS: SchemaProvider\u003e AvroParser\u003cS\u003e {\n    pub async fn avro_to_json(\u0026self, raw: \u0026[u8]) -\u003e AvroResult\u003cString\u003e {\n        // retrieve the schema from the id on the record header\n        let id = get_schema_id_from_record_header(raw)?;\n\n        let schema = self.schema_provider.get_schema_by_id(id).await?;\n        let mut data = Cursor::new(\u0026raw[5..]);\n\n        // parse the avro record into an AvroValue\n        let record =\n            from_avro_datum(\u0026schema.schema, \u0026mut data, None).map_err(|err| AvroError::ParseAvroValue(err.to_string()))?;\n        let json = map(\u0026record, \u0026schema.schema, \u0026None, \u0026schema.resolved_schemas)?;\n        let res = serde_json::to_string(\u0026json).map_err(|err| AvroError::ParseJsonValue(err.to_string()))?;\n        Ok(res)\n    }\n}\n\nfn map(\n    value: \u0026AvroValue,\n    schema: \u0026Schema,\n    parent_ns: \u0026Option\u003cString\u003e,\n    ref_cache: \u0026HashMap\u003cName, Schema\u003e,\n) -\u003e AvroResult\u003cJsonValue\u003e {\n    match (value, schema) {\n        (AvroValue::Null, Schema::Null) =\u003e Ok(JsonValue::Null),\n        (AvroValue::Boolean(v), Schema::Boolean) =\u003e Ok(json!(*v)),\n        (AvroValue::Int(v), Schema::Int) =\u003e Ok(json!(*v)),\n        (AvroValue::Long(v), Schema::Long) =\u003e Ok(json!(*v)),\n        (AvroValue::Float(v), Schema::Float) =\u003e Ok(json!(*v)),\n        (AvroValue::Double(v), Schema::Double) =\u003e Ok(json!(*v)),\n        (AvroValue::String(v), Schema::String) =\u003e Ok(json!(*v)),\n        (AvroValue::Array(v), Schema::Array(s)) =\u003e parse_array(v, s, parent_ns, ref_cache),\n        (AvroValue::Map(vec), Schema::Map(s)) =\u003e parse_map(vec, s, parent_ns, ref_cache),\n        (\n            AvroValue::Record(vec),\n            Schema::Record {\n                name, fields, lookup, ..\n            },\n        ) =\u003e parse_record(vec, lookup, fields, name, parent_ns, ref_cache),\n        (AvroValue::Date(v), Schema::Date) =\u003e Ok(json!(*v)),\n        (AvroValue::TimeMillis(v), Schema::TimeMillis) =\u003e Ok(json!(*v)),\n        (AvroValue::TimeMicros(v), Schema::TimeMicros) =\u003e Ok(json!(*v)),\n        (AvroValue::TimestampMillis(v), Schema::TimestampMillis) =\u003e Ok(json!(*v)),\n        (AvroValue::TimestampMicros(v), Schema::TimestampMicros) =\u003e Ok(json!(*v)),\n        (AvroValue::Uuid(v), Schema::Uuid) =\u003e Ok(json!(*v)),\n        (AvroValue::Bytes(v), Schema::Bytes) =\u003e Ok(json!(*v)),\n        (\n            AvroValue::Decimal(v),\n            Schema::Decimal {\n                precision: _,\n                scale,\n                inner: _,\n            },\n        ) =\u003e parse_decimal(v, scale),\n        (AvroValue::Duration(v), Schema::Duration) =\u003e Ok(json!(format!(\n            \"{:?} months {:?} days {:?} millis\",\n            v.months(),\n            v.days(),\n            v.millis()\n        ))),\n        (AvroValue::Union(i, v), Schema::Union(s)) =\u003e {\n            let schema = s\n                .variants()\n                .get(*i as usize)\n                .ok_or_else(|| AvroError::InvalidUnion(format!(\"Missing schema index {} in the union {:?}\", *i, s)))?;\n            map(v, schema, parent_ns, ref_cache)\n        }\n        (AvroValue::Enum(_, v), Schema::Enum { name: _, .. }) =\u003e Ok(json!(*v)),\n        (AvroValue::Fixed(_, v), Schema::Fixed { .. }) =\u003e Ok(json!(*v)),\n        (value, Schema::Ref { name }) =\u003e parse_ref(ref_cache, name, parent_ns, value),\n        (_, s) =\u003e Err(AvroError::Unsupported(format!(\n            \"Unexpected value/schema tuple. Schema: {:?}\",\n            s\n        ))),\n    }\n}\n\nfn parse_ref(\n    ref_cache: \u0026HashMap\u003cName, Schema\u003e,\n    name: \u0026Name,\n    parent_ns: \u0026Option\u003cString\u003e,\n    value: \u0026AvroValue,\n) -\u003e AvroResult\u003cJsonValue\u003e {\n    let schema = ref_cache\n        .get(\n            \u0026(Name {\n                namespace: name.namespace.clone().or_else(|| parent_ns.to_owned()),\n                name: name.name.clone(),\n            }),\n        )\n        .ok_or_else(|| AvroError::MissingAvroSchemaReference(name.to_string()))?;\n    map(value, schema, \u0026name.namespace, ref_cache)\n}\n\nfn parse_decimal(v: \u0026apache_avro::Decimal, scale: \u0026usize) -\u003e AvroResult\u003cJsonValue\u003e {\n    let arr = \u003cVec\u003cu8\u003e\u003e::try_from(v).map_err(|err| AvroError::InvalidNumber(err.to_string()))?;\n    let value = BigInt::from_signed_bytes_be(\u0026arr);\n    let num = i64::try_from(value).map_err(|err| AvroError::InvalidNumber(err.to_string()))?;\n    let decimal = Decimal::new(num, scale.to_owned() as u32);\n    Ok(json!(decimal))\n}\n\nfn parse_record(\n    vec: \u0026[(String, AvroValue)],\n    lookup: \u0026std::collections::BTreeMap\u003cString, usize\u003e,\n    fields: \u0026[apache_avro::schema::RecordField],\n    name: \u0026Name,\n    parent_ns: \u0026Option\u003cString\u003e,\n    ref_cache: \u0026HashMap\u003cName, Schema\u003e,\n) -\u003e AvroResult\u003cJsonValue\u003e {\n    let mut json_map = Map::new();\n    for (k, v) in vec.iter() {\n        let field_index = lookup.get(k).ok_or_else(|| AvroError::MissingField(k.to_string()))?;\n        json_map.insert(\n            k.clone(),\n            map(\n                v,\n                \u0026fields.get(*field_index).unwrap().schema,\n                \u0026name.namespace.clone().or_else(|| parent_ns.to_owned()),\n                ref_cache,\n            )?,\n        );\n    }\n    Ok(JsonValue::Object(json_map))\n}\n\nfn parse_map(\n    vec: \u0026HashMap\u003cString, AvroValue\u003e,\n    s: \u0026Schema,\n    parent_ns: \u0026Option\u003cString\u003e,\n    ref_cache: \u0026HashMap\u003cName, Schema\u003e,\n) -\u003e AvroResult\u003cJsonValue\u003e {\n    let mut json_map = Map::new();\n    for (k, v) in vec.iter() {\n        json_map.insert(k.clone(), map(v, s, parent_ns, ref_cache)?);\n    }\n    Ok(JsonValue::Object(json_map))\n}\n\nfn parse_array(\n    v: \u0026[AvroValue],\n    s: \u0026Schema,\n    parent_ns: \u0026Option\u003cString\u003e,\n    ref_cache: \u0026HashMap\u003cName, Schema\u003e,\n) -\u003e AvroResult\u003cJsonValue\u003e {\n    let mut json_vec = Vec::new();\n    for v in v.iter() {\n        json_vec.push(map(v, s, parent_ns, ref_cache)?);\n    }\n    Ok(JsonValue::Array(json_vec))\n}\n\n#[cfg(test)]\nmod tests {\n    use std::sync::Arc;\n\n    use apache_avro::{to_avro_datum, types::Record, types::Value as AvroValue, Schema as ApacheAvroSchema, Writer};\n    use async_trait::async_trait;\n\n    use crate::lib::{avro::error::AvroResult, schema_registry::ResolvedAvroSchema};\n\n    use super::{AvroParser, SchemaProvider};\n    struct MockSchemaRegistry {\n        schema: String,\n    }\n\n    #[async_trait]\n    impl SchemaProvider for MockSchemaRegistry {\n        async fn get_schema_by_id(\u0026self, _: i32) -\u003e AvroResult\u003cResolvedAvroSchema\u003e {\n            Ok(ResolvedAvroSchema::from(\n                123,\n                ApacheAvroSchema::parse_str(\u0026self.schema).unwrap(),\n            ))\n        }\n        async fn get_schema_by_name(\u0026self, _name: \u0026str) -\u003e AvroResult\u003cResolvedAvroSchema\u003e {\n            todo!()\n        }\n    }\n\n    fn get_sut(schema: String) -\u003e AvroParser\u003cMockSchemaRegistry\u003e {\n        AvroParser::new(Arc::new(MockSchemaRegistry { schema }))\n    }\n\n    #[tokio::test]\n    async fn test_simple_types_parsing() {\n        let raw_schema = r#\"\n    {\n        \"fields\": [\n            { \"name\": \"null_field\", \"type\": \"null\" },\n            { \"name\": \"boolean_field\", \"type\": \"boolean\" },\n            { \"name\": \"int_field\", \"type\": \"int\" },\n            { \"name\": \"long_field\", \"type\": \"long\" },\n            { \"name\": \"float_field\", \"type\": \"float\" },\n            { \"name\": \"double_field\", \"type\": \"double\" },\n            { \"name\": \"bytes_field\", \"type\": \"bytes\" },\n            { \"name\": \"string_field\", \"type\": \"string\" }\n        ],\n        \"name\": \"sampleRecord\",\n        \"namespace\": \"com.example.namespace\",\n        \"type\": \"record\"}\"#;\n        let schema = ApacheAvroSchema::parse_str(raw_schema).unwrap();\n        let writer = Writer::new(\u0026schema, Vec::new());\n        let mut record = Record::new(writer.schema()).unwrap();\n        record.put(\"null_field\", AvroValue::Null);\n        record.put(\"boolean_field\", true);\n        record.put(\"int_field\", 12);\n        record.put(\"long_field\", 12345667);\n        record.put(\"float_field\", 123.123f32);\n        record.put(\"double_field\", 12.12f64);\n        record.put(\"bytes_field\", AvroValue::Bytes(vec![0x01, 0x02, 0xaa]));\n        record.put(\"string_field\", \"YO!! test\");\n        let mut encoded = to_avro_datum(\u0026schema, record).unwrap();\n        // add 1 magic byte + 4 id bytes\n        let mut raw: Vec\u003cu8\u003e = vec![0x00, 0x00, 0x00, 0x00, 0x00];\n        raw.append(\u0026mut encoded);\n\n        let res = get_sut(raw_schema.to_string()).avro_to_json(\u0026raw[..]).await.unwrap();\n\n        assert_eq!(\n            res,\n            r#\"{\"boolean_field\":true,\"bytes_field\":[1,2,170],\"double_field\":12.12,\"float_field\":123.12300109863281,\"int_field\":12,\"long_field\":12345667,\"null_field\":null,\"string_field\":\"YO!! test\"}\"#\n        )\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":33,"coverable":86},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","avro","error.rs"],"content":"use crate::lib::schema_registry::SchemaRegistryError;\n\n#[derive(Debug, PartialEq)]\npub enum AvroError {\n    InvalidNumber(String),\n    MissingAvroSchemaReference(String),\n    MissingField(String),\n    SchemaProvider(String, SchemaRegistryError),\n    InvalidUnion(String),\n    Unsupported(String),\n    InvalidAvroHeader(String),\n    ParseAvroValue(String),\n    ParseJsonValue(String),\n    InvalidEnum(String),\n}\n\npub type AvroResult\u003cT\u003e = std::result::Result\u003cT, AvroError\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","avro","helpers.rs"],"content":"use super::error::{AvroError, AvroResult};\n\npub(super) fn get_schema_id_from_record_header(raw: \u0026[u8]) -\u003e AvroResult\u003ci32\u003e {\n    const AVRO_MAGIC_BYTE: u8 = 0x00;\n    if raw.len() \u003c= 5 || raw[0] != AVRO_MAGIC_BYTE {\n        return Err(AvroError::InvalidAvroHeader(\n            \"Supported avro messages should start with 0x00 follow by the schema id (4 bytes)\".into(),\n        ));\n    }\n    let arr = \u003c[u8; 4]\u003e::try_from(\u0026raw[1..5])\n        .map_err(|_| AvroError::InvalidAvroHeader(\"Invalid record. Unable to extract the schema id.\".into()))?;\n    Ok(i32::from_be_bytes(arr))\n}\n\npub(super) fn build_record_header(schema_id: i32) -\u003e Vec\u003cu8\u003e {\n    let mut res = vec![0x00];\n    let mut id = Vec::from(schema_id.to_be_bytes());\n    res.append(\u0026mut id);\n    res\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{build_record_header, get_schema_id_from_record_header};\n\n    #[test]\n    fn test_get_schema_id_from_raw() {\n        let raw: Vec\u003cu8\u003e = vec![0x00, 0x00, 0x01, 0x86, 0xc5, 0x00, 0x00, 0x00];\n        let id = get_schema_id_from_record_header(\u0026raw).unwrap();\n        assert_eq!(id, 100037)\n    }\n\n    #[test]\n    fn test_too_short_record_fails() {\n        let raw: Vec\u003cu8\u003e = vec![0x00, 0x00, 0x01, 0x86, 0xc5, 0x00, 0x00, 0x00];\n        let id = get_schema_id_from_record_header(\u0026raw).unwrap();\n        assert_eq!(id, 100037)\n    }\n\n    #[test]\n    fn test_missing_magic_byte_fails() {\n        let raw: Vec\u003cu8\u003e = vec![0x00, 0x00, 0x01, 0x86, 0xc5, 0x00, 0x00, 0x00];\n        let id = get_schema_id_from_record_header(\u0026raw).unwrap();\n        assert_eq!(id, 100037)\n    }\n\n    #[test]\n    fn build_record_header_happy_path() {\n        let raw = build_record_header(100037);\n        assert_eq!(raw, vec![0x00, 0x00, 0x01, 0x86, 0xc5])\n    }\n}\n","traces":[{"line":3,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":5,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":10,"coverable":12},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","avro","json_to_avro.rs"],"content":"use std::{collections::HashMap, str::FromStr};\n\nuse apache_avro::{schema::Name, to_avro_datum, types::Value as AvroValue, Schema};\nuse log::error;\n\nuse super::{\n    avro_parser::AvroParser, error::AvroResult, helpers::build_record_header, schema_provider::SchemaProvider, AvroError,\n};\nuse crate::lib::schema_registry::ResolvedAvroSchema;\nuse serde_json::Value as JsonValue;\n\nimpl\u003cS: SchemaProvider\u003e AvroParser\u003cS\u003e {\n    pub async fn json_to_avro(\u0026self, json: \u0026str, schema_name: \u0026str) -\u003e AvroResult\u003cVec\u003cu8\u003e\u003e {\n        let schema = self.schema_provider.get_schema_by_name(schema_name).await?;\n        Self::json_to_avro_with_schema(self, json, schema)\n    }\n\n    pub fn json_to_avro_with_schema(\u0026self, json: \u0026str, schema: ResolvedAvroSchema) -\u003e AvroResult\u003cVec\u003cu8\u003e\u003e {\n        let json_value = JsonValue::from_str(json).map_err(|err| AvroError::ParseJsonValue(err.to_string()))?;\n        let mut res = build_record_header(schema.schema_id);\n        let avro_value = json_to_avro_map(\u0026json_value, \u0026schema.schema, \u0026schema.resolved_schemas)?;\n        let mut avro_record = to_avro_datum(\u0026schema.schema, avro_value.clone()).map_err(|err| {\n            error!(\n                \"\\n\\tUnable to parse {:?}\\n\\tUsing schema: {:?}\\n\\tError: {:?}\",\n                avro_value, \u0026schema.schema, err\n            );\n            AvroError::ParseAvroValue(err.to_string())\n        })?;\n        res.append(\u0026mut avro_record);\n        Ok(res)\n    }\n}\n\nfn json_to_avro_map(j: \u0026JsonValue, s: \u0026Schema, ref_map: \u0026HashMap\u003cName, Schema\u003e) -\u003e AvroResult\u003cAvroValue\u003e {\n    match (\u0026s, j) {\n        // complex types\n        (Schema::Record { fields, .. }, JsonValue::Object(obj)) =\u003e map_json_fields_to_record(fields, obj, ref_map),\n        (Schema::Array(items_schema), JsonValue::Array(values)) =\u003e map_json_array_to_avro(values, items_schema, ref_map),\n        (Schema::Union(union_schema), JsonValue::Null) =\u003e {\n            let (position, _) = union_schema.find_schema(\u0026AvroValue::Null).ok_or_else(|| {\n                AvroError::InvalidUnion(format!(\n                    \"Cannot set null to the union. Supported options are: {:?}\",\n                    union_schema.variants()\n                ))\n            })?;\n            Ok(AvroValue::Union(position as u32, AvroValue::Null.into()))\n        }\n        (Schema::Union(union_schema), JsonValue::Object(obj)) =\u003e map_union(obj, union_schema, ref_map),\n        (Schema::Map(schema), JsonValue::Object(obj)) =\u003e {\n            let mut avro_map = HashMap::new();\n            for (key, value) in obj {\n                avro_map.insert(key.to_string(), json_to_avro_map(value, schema, ref_map)?);\n            }\n            Ok(AvroValue::Map(avro_map))\n        }\n        // simple types\n        (Schema::Null, JsonValue::Null) =\u003e Ok(AvroValue::Null),\n        (Schema::Boolean, JsonValue::Bool(v)) =\u003e Ok(AvroValue::Boolean(*v)),\n        (Schema::String, JsonValue::String(s)) =\u003e Ok(AvroValue::String(s.clone())),\n        (Schema::Enum { symbols, .. }, JsonValue::String(s)) =\u003e {\n            let (index, value) = symbols\n                .iter()\n                .enumerate()\n                .find(|(_, v)| v.to_string().eq(s))\n                .ok_or_else(|| AvroError::InvalidEnum(format!(\"Invalid enum {} expected one of {:?}\", s, symbols)))?;\n            Ok(AvroValue::Enum(index as u32, value.into()))\n        }\n        // numbers\n        (Schema::Int, JsonValue::Number(n)) =\u003e {\n            let n = n\n                .as_i64()\n                .and_then(|v| i32::try_from(v).ok())\n                .ok_or_else(|| AvroError::InvalidNumber(format!(\"Unable to convert {} to Int\", n)))?;\n            Ok(AvroValue::Int(n))\n        }\n        (Schema::Long, JsonValue::Number(n)) =\u003e {\n            let n = n\n                .as_i64()\n                .ok_or_else(|| AvroError::InvalidNumber(format!(\"Unable to convert {} to Long\", n)))?;\n            Ok(AvroValue::Long(n))\n        }\n        (Schema::Float, JsonValue::Number(n)) =\u003e {\n            let n = n\n                .as_f64()\n                .map(|v| v as f32)\n                .ok_or_else(|| AvroError::InvalidNumber(format!(\"Unable to convert {} to Float\", n)))?;\n            Ok(AvroValue::Float(n))\n        }\n        (Schema::Double, JsonValue::Number(n)) =\u003e {\n            let n = n\n                .as_f64()\n                .ok_or_else(|| AvroError::InvalidNumber(format!(\"Unable to convert {} to Double\", n)))?;\n            Ok(AvroValue::Double(n))\n        }\n        (Schema::Ref { name }, value) =\u003e {\n            let schema = ref_map.get(name).ok_or_else(|| {\n                AvroError::MissingAvroSchemaReference(format!(\"Unable to resolve reference {}\", name.to_string()))\n            })?;\n            json_to_avro_map(value, schema, ref_map)\n        }\n        // (\n        //     Schema::Decimal {\n        //         precision,\n        //         scale,\n        //         inner,\n        //     },\n        //     JsonValue::Number(n),\n        // ) =\u003e todo!(),\n\n        // Schema::Fixed { name, aliases, doc, size } =\u003e todo!(),\n        // Schema::Uuid =\u003e todo!(),\n        // // time\n        // Schema::Date =\u003e todo!(),\n        // Schema::TimeMillis =\u003e todo!(),\n        // Schema::TimeMicros =\u003e todo!(),\n        // Schema::TimestampMillis =\u003e todo!(),\n        // Schema::TimestampMicros =\u003e todo!(),\n        // Schema::Duration =\u003e todo!(),\n        // todo:\n        //(Schema::Bytes, JsonValue::String(s)) =\u003e todo!(),\n        (schema, value) =\u003e Err(AvroError::Unsupported(format!(\n            \"Unsupported Schema-JsonValue tuple: \\n\\n{:?}\\n\\n{:?}\",\n            schema, value\n        ))),\n    }\n}\n\nfn map_union(\n    obj: \u0026serde_json::Map\u003cString, JsonValue\u003e,\n    union_schema: \u0026apache_avro::schema::UnionSchema,\n    ref_map: \u0026HashMap\u003cName, Schema\u003e,\n) -\u003e Result\u003cAvroValue, AvroError\u003e {\n    let fields_vec: Vec\u003c(\u0026String, \u0026JsonValue)\u003e = obj.iter().collect();\n    if fields_vec.len() != 1 {\n        Err(AvroError::InvalidUnion(format!(\n            \"Invalid union. Expected one of: {:?}\",\n            union_schema.variants()\n        )))\n    } else {\n        let (union_branch_name, value) = *fields_vec.first().unwrap();\n        let index_schema = union_schema\n            .variants()\n            .iter()\n            .enumerate()\n            .find(|(_, s)| get_schema_name(s).eq(union_branch_name));\n        if let Some((index, current_schema)) = index_schema {\n            let value = json_to_avro_map(value, current_schema, ref_map)?;\n            Ok(AvroValue::Union(index as u32, value.into()))\n        } else {\n            Err(AvroError::InvalidUnion(format!(\n                \"Unsupported union specifier: {}\",\n                union_branch_name\n            )))\n        }\n    }\n}\n\nfn get_schema_name(s: \u0026Schema) -\u003e \u0026str {\n    match s {\n        Schema::Null =\u003e \"null\",\n        Schema::Boolean =\u003e \"boolean\",\n        Schema::Int =\u003e \"int\",\n        Schema::Long =\u003e \"long\",\n        Schema::Float =\u003e \"float\",\n        Schema::Double =\u003e \"double\",\n        Schema::Bytes =\u003e \"bytes\",\n        Schema::String =\u003e \"string\",\n        Schema::Record { name, .. } =\u003e \u0026name.name,\n        _ =\u003e {\n            //todo: support the other types\n            let message = format!(\"Unable to retrieve the name of the schema {:?}\", s);\n            error!(\"{}\", message);\n            panic!(\"{}\", message);\n        }\n    }\n}\n\nfn map_json_array_to_avro(\n    values: \u0026Vec\u003cJsonValue\u003e,\n    items_schema: \u0026Schema,\n    ref_map: \u0026HashMap\u003cName, Schema\u003e,\n) -\u003e Result\u003cAvroValue, AvroError\u003e {\n    let mut vec = vec![];\n    for value in values {\n        let avro_value = json_to_avro_map(value, items_schema, ref_map)?;\n        vec.push(avro_value);\n    }\n    Ok(AvroValue::Array(vec))\n}\n\nfn map_json_fields_to_record(\n    fields: \u0026Vec\u003capache_avro::schema::RecordField\u003e,\n    obj: \u0026serde_json::Map\u003cString, JsonValue\u003e,\n    ref_map: \u0026HashMap\u003cName, Schema\u003e,\n) -\u003e Result\u003cAvroValue, AvroError\u003e {\n    let mut record_fields: Vec\u003c(String, AvroValue)\u003e = vec![];\n    for field in fields {\n        let field_value = obj\n            .get(\u0026field.name)\n            .ok_or_else(|| AvroError::MissingField(field.name.clone()))?;\n        let avro_field = json_to_avro_map(field_value, \u0026field.schema, ref_map)?;\n        record_fields.push((field.name.clone(), avro_field));\n    }\n    Ok(AvroValue::Record(record_fields))\n}\n\n#[cfg(test)]\nmod tests {\n\n    use std::collections::BTreeMap;\n    use std::collections::HashMap;\n\n    use apache_avro::{schema::RecordField, Schema};\n\n    use super::map_json_fields_to_record;\n    use crate::lib::avro::AvroError;\n\n    use apache_avro::types::Value as AvroValue;\n    use serde_json::json;\n    use serde_json::Value as JsonValue;\n\n    #[test]\n    fn test_map_record() {\n        let obj = {\n            let mut obj_map = serde_json::Map::new();\n            obj_map.insert(\"sample\".to_string(), json!(1));\n            obj_map\n        };\n        let fields = vec![build_record_field(\"sample\", apache_avro::Schema::Int)];\n\n        // happy path\n        {\n            let res = map_json_fields_to_record(\u0026fields, \u0026obj, \u0026HashMap::new());\n            assert_eq!(\n                res,\n                Ok(AvroValue::Record(vec![(\"sample\".to_string(), AvroValue::Int(1))]))\n            );\n        }\n\n        // parse a json object with a missing field return an error\n        {\n            let fields = vec![\n                build_record_field(\"sample\", apache_avro::Schema::Int),\n                build_record_field(\"sample_2\", apache_avro::Schema::Int),\n            ];\n            let res = map_json_fields_to_record(\u0026fields, \u0026obj, \u0026HashMap::new());\n            assert_eq!(res, Err(AvroError::MissingField(\"sample_2\".into())))\n        }\n\n        // parse nested record\n        {\n            let obj_parent = {\n                let mut obj_map = serde_json::Map::new();\n                obj_map.insert(\"sample\".into(), json!(2));\n                obj_map.insert(\"nested\".into(), JsonValue::Object(obj));\n                obj_map\n            };\n            let nested_schema = Schema::Record {\n                name: \"Nested\".into(),\n                aliases: None,\n                doc: None,\n                fields: fields,\n                lookup: BTreeMap::\u003cString, usize\u003e::new(),\n            };\n            let fields = vec![\n                build_record_field(\"sample\", apache_avro::Schema::Int),\n                build_record_field(\"nested\", nested_schema),\n            ];\n            let res = map_json_fields_to_record(\u0026fields, \u0026obj_parent, \u0026HashMap::new());\n            assert_eq!(\n                res,\n                Ok(AvroValue::Record(vec![\n                    (\"sample\".to_string(), AvroValue::Int(2)),\n                    (\n                        \"nested\".to_string(),\n                        AvroValue::Record(vec![(\"sample\".into(), AvroValue::Int(1))])\n                    ),\n                ]))\n            );\n        }\n    }\n\n    fn build_record_field(name: \u0026str, schema: Schema) -\u003e RecordField {\n        RecordField {\n            name: name.into(),\n            doc: Default::default(),\n            default: Default::default(),\n            schema: schema,\n            order: apache_avro::schema::RecordFieldOrder::Ignore,\n            position: Default::default(),\n        }\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":16,"coverable":106},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","avro","mod.rs"],"content":"mod avro_parser;\nmod avro_to_json;\nmod error;\nmod helpers;\nmod json_to_avro;\nmod schema_provider;\n\npub use avro_parser::AvroParser;\npub use error::AvroError;\npub use schema_provider::SchemaProvider;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","avro","schema_provider.rs"],"content":"use async_trait::async_trait;\n\nuse crate::lib::schema_registry::{CachedSchemaRegistry, ResolvedAvroSchema};\n\nuse super::error::{AvroError, AvroResult};\n\n#[async_trait]\npub trait SchemaProvider: Send + Sync {\n    async fn get_schema_by_id(\u0026self, id: i32) -\u003e AvroResult\u003cResolvedAvroSchema\u003e;\n    async fn get_schema_by_name(\u0026self, name: \u0026str) -\u003e AvroResult\u003cResolvedAvroSchema\u003e;\n}\n\n#[async_trait]\nimpl SchemaProvider for CachedSchemaRegistry {\n    async fn get_schema_by_id(\u0026self, id: i32) -\u003e AvroResult\u003cResolvedAvroSchema\u003e {\n        self.get_schema_by_id(id)\n            .await\n            .map_err(|err| AvroError::SchemaProvider(format!(\"Unable to retrieve the schema id {}\", id), err))\n    }\n    async fn get_schema_by_name(\u0026self, name: \u0026str) -\u003e AvroResult\u003cResolvedAvroSchema\u003e {\n        self.get_last_schema(name)\n            .await\n            .map_err(|err| AvroError::SchemaProvider(format!(\"Unable to retrieve the schema {}\", name), err))\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":8},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","configuration","configuration_provider.rs"],"content":"use super::error::ConfigResult;\nuse super::legacy_config::LegacyConfiguration;\nuse super::store_types::StoreConfig;\nuse super::InsulatorConfig;\nuse dirs::home_dir;\nuse std::path::PathBuf;\nuse std::{fs, path::Path};\n\n#[derive(Default)]\npub struct ConfigurationProvider {\n    config_path: PathBuf,\n    legacy_config_path: PathBuf,\n}\n\nimpl ConfigurationProvider {\n    pub fn new() -\u003e Self {\n        let mut config_path = home_dir().expect(\"Unable to retrieve the home directory\");\n        let mut legacy_config_path = config_path.clone();\n        config_path.push(\".insulator2.toml\");\n        legacy_config_path.push(\".insulator.config\");\n        ConfigurationProvider {\n            config_path,\n            legacy_config_path,\n        }\n    }\n\n    pub fn get_configuration(\u0026self) -\u003e ConfigResult\u003cInsulatorConfig\u003e {\n        match Path::exists(\u0026self.config_path) {\n            // read file content\n            true =\u003e {\n                let raw_config = fs::read_to_string(\u0026self.config_path)?;\n                let conf = toml::from_str::\u003cStoreConfig\u003e(\u0026raw_config)?;\n                Ok(InsulatorConfig::from(conf))\n            }\n            // if the file doesn't exists return the default\n            false =\u003e {\n                match Path::exists(\u0026self.legacy_config_path) {\n                    true =\u003e {\n                        // try to import the legacy config\n                        let raw_config = fs::read_to_string(\u0026self.legacy_config_path)?;\n                        let legacy_config = serde_json::from_str::\u003cLegacyConfiguration\u003e(\u0026raw_config)?;\n                        Ok(InsulatorConfig::try_from(legacy_config)?)\n                    }\n                    false =\u003e Ok(InsulatorConfig::default()),\n                }\n            }\n        }\n    }\n\n    pub fn write_configuration(\u0026self, configuration: \u0026InsulatorConfig) -\u003e ConfigResult\u003c()\u003e {\n        // validate input\n        configuration.clusters.iter().for_each(|c| {\n            assert!(!c.endpoint.is_empty());\n            match \u0026c.schema_registry {\n                Some(s) =\u003e assert!(!s.endpoint.is_empty()),\n                None =\u003e {}\n            }\n        });\n        let as_store = StoreConfig::from(configuration);\n        let raw_config = toml::to_string_pretty(\u0026as_store)?;\n        fs::write(\u0026self.config_path, raw_config)?;\n        Ok(())\n    }\n\n    #[cfg(test)]\n    fn from_config_path(config_path: \u0026str) -\u003e Self {\n        ConfigurationProvider {\n            config_path: PathBuf::from(config_path),\n            legacy_config_path: PathBuf::from(config_path),\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use std::{env::temp_dir, fs};\n\n    use crate::lib::configuration::InsulatorConfig;\n\n    use super::ConfigurationProvider;\n\n    fn get_test_config_path() -\u003e String {\n        let mut dir = temp_dir();\n        dir.push(\"test_config\");\n        dir.to_str().unwrap().into()\n    }\n\n    #[test]\n    fn test_retrieve_config() {\n        let tmp_config_file = get_test_config_path();\n        let sut = ConfigurationProvider::from_config_path(\u0026tmp_config_file);\n\n        // retrieve config the first time returns the default\n        {\n            fs::remove_file(\u0026tmp_config_file).ok();\n            let res = sut.get_configuration();\n            assert!(res.is_ok());\n            assert_eq!(res.unwrap(), InsulatorConfig::default());\n        }\n    }\n\n    #[test]\n    fn test_write_config() {\n        // write a default config\n        {\n            let sut = ConfigurationProvider::from_config_path(\u0026get_test_config_path());\n            let res = sut.write_configuration(\u0026InsulatorConfig::default());\n            assert!(res.is_ok());\n        }\n        // write a config with a cluster authentication and schema registry\n        {\n            let mut config = InsulatorConfig::default();\n            config.clusters.push(crate::lib::configuration::ClusterConfig {\n                id: \"7213059c-c744-45ef-a380-3f6997b44377\".into(),\n                name: \"test_cluster\".into(),\n                endpoint: \"localhost:9092\".into(),\n                authentication: crate::lib::configuration::AuthenticationConfig::Sasl {\n                    username: \"test\".into(),\n                    password: \"test\".into(),\n                    scram: true,\n                },\n                schema_registry: Some(crate::lib::configuration::SchemaRegistryConfig {\n                    endpoint: \"endpoint\".into(),\n                    username: Some(\"username\".into()),\n                    password: Some(\"password\".into()),\n                }),\n                ..Default::default()\n            });\n            config.clusters.push(crate::lib::configuration::ClusterConfig {\n                id: \"1213059c-c744-45ef-a380-3f6997b44377\".into(),\n                name: \"test_cluster_2\".into(),\n                endpoint: \"localhost:9092\".into(),\n                authentication: crate::lib::configuration::AuthenticationConfig::None,\n                schema_registry: None,\n                ..Default::default()\n            });\n            let sut = ConfigurationProvider::from_config_path(\u0026get_test_config_path());\n            let res = sut.write_configuration(\u0026InsulatorConfig::default());\n            assert!(res.is_ok())\n        }\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":14,"coverable":29},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","configuration","error.rs"],"content":"#[derive(Debug)]\npub enum ConfigError {\n    IO(String),\n    JSONSerde(String),\n    TOMLSerde(String),\n    LegacyConfiguration(String),\n    ClusterNotFound(String),\n}\n\npub type ConfigResult\u003cT\u003e = Result\u003cT, ConfigError\u003e;\n\nimpl From\u003cstd::io::Error\u003e for ConfigError {\n    fn from(error: std::io::Error) -\u003e Self {\n        ConfigError::IO(error.to_string())\n    }\n}\n\nimpl From\u003cserde_json::Error\u003e for ConfigError {\n    fn from(error: serde_json::Error) -\u003e Self {\n        ConfigError::JSONSerde(error.to_string())\n    }\n}\n\nimpl From\u003ctoml::de::Error\u003e for ConfigError {\n    fn from(error: toml::de::Error) -\u003e Self {\n        ConfigError::TOMLSerde(error.to_string())\n    }\n}\n\nimpl From\u003ctoml::ser::Error\u003e for ConfigError {\n    fn from(error: toml::ser::Error) -\u003e Self {\n        ConfigError::TOMLSerde(error.to_string())\n    }\n}\n\nimpl From\u003crust_keystore::error::Error\u003e for ConfigError {\n    fn from(err: rust_keystore::error::Error) -\u003e Self {\n        Self::LegacyConfiguration(format!(\"{:?}\", err))\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":10},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","configuration","kafka_client_config.rs"],"content":"use rdkafka::ClientConfig;\n\nuse crate::lib::configuration::{AuthenticationConfig, ClusterConfig};\n\npub fn build_kafka_client_config(cluster: \u0026ClusterConfig, group_id: Option\u003c\u0026str\u003e) -\u003e ClientConfig {\n    let mut config = ClientConfig::new();\n    let group_id = group_id.unwrap_or(\"insulator-2\");\n    config\n        .set(\"bootstrap.servers\", \u0026cluster.endpoint)\n        .set(\"session.timeout.ms\", \"60_000\")\n        .set(\"enable.auto.commit\", \"false\")\n        .set(\"enable.auto.offset.store\", \"false\")\n        .set(\"offset.store.method\", \"broker\")\n        .set(\"group.id\", group_id)\n        .set(\"api.version.request\", \"true\")\n        .set(\"debug\", \"all\");\n    match \u0026cluster.authentication {\n        AuthenticationConfig::None =\u003e {\n            config.set(\"security.protocol\", \"PLAINTEXT\");\n        }\n        AuthenticationConfig::Sasl {\n            username,\n            password,\n            scram,\n        } =\u003e {\n            config\n                .set(\"security.protocol\", \"SASL_SSL\")\n                .set(\"sasl.mechanisms\", if *scram { \"SCRAM-SHA-256\" } else { \"PLAIN\" })\n                .set(\"ssl.endpoint.identification.algorithm\", \"https\")\n                .set(\"sasl.username\", username)\n                .set(\"sasl.password\", password);\n        }\n\n        AuthenticationConfig::Ssl {\n            ca,\n            certificate,\n            key,\n            key_password,\n        } =\u003e {\n            config\n                .set(\"security.protocol\", \"ssl\")\n                .set(\"ssl.ca.pem\", ca)\n                .set(\"ssl.certificate.pem\", certificate)\n                .set(\"ssl.key.pem\", key);\n\n            if let Some(password) = key_password {\n                config.set(\"ssl.key.password\", password);\n            }\n        }\n    }\n    config\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":8},"fn_name":null}],"covered":10,"coverable":29},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","configuration","legacy_config.rs"],"content":"use super::{\n    error::{ConfigError, ConfigResult},\n    AuthenticationConfig, ClusterConfig, InsulatorConfig, SchemaRegistryConfig, Theme,\n};\nuse log::{debug, warn};\nuse serde::Deserialize;\n\n// insulator v1 config\n#[derive(Debug, Default, Deserialize)]\npub(crate) struct LegacyConfiguration {\n    clusters: Vec\u003cLegacyCluster\u003e,\n    theme: Theme,\n}\n\n#[derive(Debug, Default, Deserialize)]\nstruct LegacyCluster {\n    pub guid: String,\n    pub name: String,\n    pub endpoint: String,\n\n    #[serde(rename = \"useSSL\")]\n    pub use_ssl: bool,\n    #[serde(rename = \"sslConfiguration\")]\n    pub ssl_configuration: Option\u003cSslConfigurationLegacy\u003e,\n\n    #[serde(rename = \"useSasl\")]\n    pub use_sasl: bool,\n    #[serde(rename = \"saslConfiguration\")]\n    pub sasl_configuration: Option\u003cSaslConfigurationLegacy\u003e,\n\n    #[serde(rename = \"schemaRegistryConfig\")]\n    schema_registry_config: Option\u003cSchemaRegistryConfigurationLegacy\u003e,\n}\n\n#[derive(Debug, Default, Deserialize)]\nstruct SslConfigurationLegacy {\n    #[serde(rename = \"sslTruststoreLocation\")]\n    pub ssl_truststore_location: Option\u003cString\u003e,\n    #[serde(rename = \"sslTruststorePassword\")]\n    pub ssl_truststore_password: Option\u003cString\u003e,\n    #[serde(rename = \"sslKeystoreLocation\")]\n    pub ssl_keystore_location: Option\u003cString\u003e,\n    #[serde(rename = \"sslKeyStorePassword\")]\n    pub ssl_keystore_password: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Default, Deserialize)]\nstruct SaslConfigurationLegacy {\n    #[serde(rename = \"saslUsername\")]\n    pub sasl_username: Option\u003cString\u003e,\n    #[serde(rename = \"saslPassword\")]\n    pub sasl_password: Option\u003cString\u003e,\n    #[serde(rename = \"useScram\")]\n    pub use_scram: Option\u003cbool\u003e,\n}\n\n#[derive(Debug, Default, Deserialize)]\nstruct SchemaRegistryConfigurationLegacy {\n    pub endpoint: Option\u003cString\u003e,\n    pub username: Option\u003cString\u003e,\n    pub password: Option\u003cString\u003e,\n}\n\nimpl TryFrom\u003cLegacyConfiguration\u003e for InsulatorConfig {\n    type Error = ConfigError;\n\n    fn try_from(legacy: LegacyConfiguration) -\u003e std::result::Result\u003cSelf, Self::Error\u003e {\n        let mut config = InsulatorConfig {\n            theme: legacy.theme,\n            clusters: vec![], //populated below\n            ..Default::default()\n        };\n        let mut clusters = Vec::new();\n        for c in legacy.clusters {\n            debug!(\"Parsing cluster {}\", c.name);\n            let schema_registry = c.schema_registry_config.and_then(map_schema_registry);\n            let authentication = if c.use_sasl \u0026\u0026 c.sasl_configuration.is_some() {\n                map_sasl_config(c.sasl_configuration.unwrap())\n            } else if c.use_ssl \u0026\u0026 c.ssl_configuration.is_some() {\n                map_ssl_config(c.ssl_configuration.unwrap())\n            } else {\n                Ok(AuthenticationConfig::None)\n            };\n            if let Ok(authentication) = authentication {\n                clusters.push(ClusterConfig {\n                    id: c.guid.clone(),\n                    name: c.name.clone(),\n                    endpoint: c.endpoint.clone().replace(\"https://\", \"\").replace(\"http://\", \"\"),\n                    authentication,\n                    schema_registry,\n                    ..Default::default()\n                });\n            } else {\n                warn!(\"Unable to parse cluster config. {:?}\", authentication);\n            }\n        }\n        config.clusters = clusters;\n        Ok(config)\n    }\n}\n\nfn map_sasl_config(legacy: SaslConfigurationLegacy) -\u003e ConfigResult\u003cAuthenticationConfig\u003e {\n    if let (Some(username), Some(password)) = (legacy.sasl_username, legacy.sasl_password) {\n        Ok(AuthenticationConfig::Sasl {\n            username,\n            password,\n            scram: legacy.use_scram.unwrap_or(false),\n        })\n    } else {\n        Err(ConfigError::LegacyConfiguration(\n            \"Invalid sasl configuration found. Username and password must be non-empty\".into(),\n        ))\n    }\n}\n\nfn map_ssl_config(legacy: SslConfigurationLegacy) -\u003e ConfigResult\u003cAuthenticationConfig\u003e {\n    if let (Some(truststore_location), Some(keystore_location)) =\n        (legacy.ssl_truststore_location, legacy.ssl_keystore_location)\n    {\n        debug!(\"Parsing truststore {}\", \u0026truststore_location);\n        let ca_certificate = \u0026rust_keystore::KeyStore::try_load(\u0026truststore_location)?\n            .certificates(legacy.ssl_truststore_password.as_deref())?[0];\n\n        debug!(\"Parsing keystore {}\", \u0026keystore_location);\n        let user_certificate = \u0026rust_keystore::KeyStore::try_load(\u0026keystore_location)?\n            .certificates(legacy.ssl_keystore_password.as_deref())?[0];\n\n        Ok(AuthenticationConfig::Ssl {\n            ca: ca_certificate.pem.clone(),\n            certificate: user_certificate.pem.clone(),\n            key: user_certificate\n                .private_key\n                .as_ref()\n                .ok_or_else(|| ConfigError::LegacyConfiguration(\"Unable to parse the keystore\".into()))?\n                .pkcs8_pem\n                .clone(),\n            key_password: None,\n        })\n    } else {\n        Err(ConfigError::LegacyConfiguration(\n            \"Invalid ssl configuration found. truststore and keystore locations are required\".into(),\n        ))\n    }\n}\n\nfn map_schema_registry(legacy: SchemaRegistryConfigurationLegacy) -\u003e Option\u003cSchemaRegistryConfig\u003e {\n    if let Some(endpoint) = legacy.endpoint {\n        Some(SchemaRegistryConfig {\n            endpoint,\n            username: legacy.username.filter(|s| !s.is_empty()),\n            password: legacy.password.filter(|s| !s.is_empty()),\n        })\n    } else {\n        None\n    }\n}\n","traces":[{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":54},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","configuration","mod.rs"],"content":"mod configuration_provider;\nmod error;\nmod kafka_client_config;\nmod legacy_config;\nmod store_types;\nmod types;\n\npub use configuration_provider::ConfigurationProvider;\npub use error::*;\npub use kafka_client_config::build_kafka_client_config;\npub use types::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","configuration","store_types.rs"],"content":"use std::collections::HashMap;\n\nuse serde::{Deserialize, Serialize};\n\nuse super::{AuthenticationConfig, ClusterConfig, Favorites, InsulatorConfig, SchemaRegistryConfig, Theme};\n\n#[derive(Serialize, Deserialize, Debug, Default, PartialEq, Eq)]\npub struct StoreConfig {\n    pub theme: Theme,\n    #[serde(rename = \"showNotifications\")]\n    pub show_notifications: bool,\n    #[serde(rename = \"useRegex\")]\n    pub use_regex: bool,\n    #[serde(rename = \"sqlTimeoutSeconds\")]\n    pub sql_timeout_secs: Option\u003cu32\u003e,\n    #[serde(rename = \"kafkaTimeoutSeconds\")]\n    pub kafka_timeout_secs: Option\u003cu32\u003e,\n    pub clusters: HashMap\u003cString, StoreCluster\u003e,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone, Default, PartialEq, Eq)]\npub struct StoreCluster {\n    pub name: String,\n    pub endpoint: String,\n    pub authentication: StoreAuthentication,\n    #[serde(rename = \"schemaRegistry\")]\n    pub schema_registry: Option\u003cSchemaRegistryConfig\u003e,\n    pub favorites: Option\u003cFavorites\u003e,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone, Default, PartialEq, Eq)]\n#[serde(tag = \"type\")]\npub enum StoreAuthentication {\n    Ssl {\n        ca: String,\n        certificate: String,\n        key: String,\n        #[serde(rename = \"keyPassword\")]\n        key_password: Option\u003cString\u003e,\n    },\n    Sasl {\n        username: String,\n        password: String,\n        scram: bool,\n    },\n    #[default]\n    None,\n}\n\nimpl From\u003cStoreAuthentication\u003e for AuthenticationConfig {\n    fn from(s: StoreAuthentication) -\u003e Self {\n        match s {\n            StoreAuthentication::Ssl {\n                ca,\n                certificate,\n                key,\n                key_password,\n            } =\u003e AuthenticationConfig::Ssl {\n                ca,\n                certificate,\n                key,\n                key_password,\n            },\n            StoreAuthentication::Sasl {\n                username,\n                password,\n                scram,\n            } =\u003e AuthenticationConfig::Sasl {\n                username,\n                password,\n                scram,\n            },\n            StoreAuthentication::None =\u003e AuthenticationConfig::None,\n        }\n    }\n}\n\nfn store_cluster_to_config(id: String, store: StoreCluster) -\u003e ClusterConfig {\n    ClusterConfig {\n        id,\n        name: store.name,\n        endpoint: store.endpoint,\n        authentication: store.authentication.into(),\n        schema_registry: store.schema_registry,\n        favorites: store.favorites.unwrap_or_default(),\n    }\n}\n\nimpl From\u003cStoreConfig\u003e for InsulatorConfig {\n    fn from(\n        StoreConfig {\n            theme,\n            show_notifications,\n            use_regex,\n            clusters,\n            sql_timeout_secs,\n            kafka_timeout_secs,\n        }: StoreConfig,\n    ) -\u003e Self {\n        let converted_clusters = clusters\n            .into_iter()\n            .map(|(id, c)| store_cluster_to_config(id, c))\n            .collect();\n        InsulatorConfig {\n            theme,\n            show_notifications,\n            use_regex,\n            sql_timeout_secs: sql_timeout_secs.unwrap_or(10),\n            kafka_timeout_secs: kafka_timeout_secs.unwrap_or(15),\n            clusters: converted_clusters,\n        }\n    }\n}\n\nimpl From\u003cAuthenticationConfig\u003e for StoreAuthentication {\n    fn from(authentication_config: AuthenticationConfig) -\u003e Self {\n        match authentication_config {\n            AuthenticationConfig::Ssl {\n                ca,\n                certificate,\n                key,\n                key_password,\n            } =\u003e StoreAuthentication::Ssl {\n                ca,\n                certificate,\n                key,\n                key_password,\n            },\n            AuthenticationConfig::Sasl {\n                username,\n                password,\n                scram,\n            } =\u003e StoreAuthentication::Sasl {\n                username,\n                password,\n                scram,\n            },\n            AuthenticationConfig::None =\u003e StoreAuthentication::None,\n        }\n    }\n}\n\nimpl From\u003cClusterConfig\u003e for StoreCluster {\n    fn from(config: ClusterConfig) -\u003e Self {\n        StoreCluster {\n            name: config.name,\n            endpoint: config.endpoint,\n            authentication: config.authentication.into(),\n            schema_registry: config.schema_registry,\n            favorites: Some(config.favorites),\n        }\n    }\n}\n\nimpl From\u003c\u0026InsulatorConfig\u003e for StoreConfig {\n    fn from(config: \u0026InsulatorConfig) -\u003e Self {\n        StoreConfig {\n            theme: config.theme,\n            show_notifications: config.show_notifications,\n            use_regex: config.use_regex,\n            sql_timeout_secs: Some(config.sql_timeout_secs),\n            kafka_timeout_secs: Some(config.kafka_timeout_secs),\n            clusters: config\n                .clusters\n                .clone()\n                .into_iter()\n                .map(|c| (c.id.clone(), c.into()))\n                .collect(),\n        }\n    }\n}\n","traces":[{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":7,"coverable":44},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","configuration","types.rs"],"content":"use std::time::Duration;\n\nuse serde::{Deserialize, Serialize};\n\nuse super::error::{ConfigError, ConfigResult};\n\n#[derive(Serialize, Deserialize, Debug, PartialEq, Eq, Clone)]\npub struct InsulatorConfig {\n    pub theme: Theme,\n    #[serde(rename = \"showNotifications\")]\n    pub show_notifications: bool,\n    #[serde(rename = \"useRegex\")]\n    pub use_regex: bool,\n    #[serde(rename = \"sqlTimeoutSeconds\")]\n    pub sql_timeout_secs: u32,\n    #[serde(rename = \"kafkaTimeoutSeconds\")]\n    pub kafka_timeout_secs: u32,\n    pub clusters: Vec\u003cClusterConfig\u003e,\n}\n\nimpl InsulatorConfig {\n    pub fn get_kafka_tmo(\u0026self) -\u003e Duration {\n        Duration::from_secs(self.kafka_timeout_secs as u64)\n    }\n    pub fn get_sql_tmo(\u0026self) -\u003e Duration {\n        Duration::from_secs(self.sql_timeout_secs as u64)\n    }\n    pub fn get_cluster_config(\u0026self, cluster_id: \u0026str) -\u003e ConfigResult\u003cClusterConfig\u003e {\n        self.clusters\n            .iter()\n            .find(|c| c.id == cluster_id)\n            .cloned()\n            .ok_or_else(|| ConfigError::ClusterNotFound(cluster_id.to_string()))\n    }\n}\n\nimpl Default for InsulatorConfig {\n    fn default() -\u003e Self {\n        Self {\n            show_notifications: true,\n            use_regex: true,\n            sql_timeout_secs: 10,\n            clusters: vec![],\n            kafka_timeout_secs: 20,\n            theme: Theme::Dark,\n        }\n    }\n}\n\n#[derive(Serialize, Deserialize, Debug, PartialEq, Eq, Default, Clone, Copy)]\npub enum Theme {\n    #[default]\n    Dark,\n    Light,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone, Default, PartialEq, Eq)]\npub struct ClusterConfig {\n    pub id: String,\n    pub name: String,\n    pub endpoint: String,\n    pub authentication: AuthenticationConfig,\n    #[serde(rename = \"schemaRegistry\")]\n    pub schema_registry: Option\u003cSchemaRegistryConfig\u003e,\n    pub favorites: Favorites,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone, Default, PartialEq, Eq)]\npub enum AuthenticationConfig {\n    Ssl {\n        ca: String,\n        certificate: String,\n        key: String,\n        #[serde(rename = \"keyPassword\")]\n        key_password: Option\u003cString\u003e,\n    },\n    Sasl {\n        username: String,\n        password: String,\n        scram: bool,\n    },\n    #[default]\n    None,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]\npub struct SchemaRegistryConfig {\n    pub endpoint: String,\n    pub username: Option\u003cString\u003e,\n    pub password: Option\u003cString\u003e,\n}\n\n#[derive(Serialize, Deserialize, Debug, Default, Clone, PartialEq, Eq)]\npub struct Favorites {\n    pub topics: Vec\u003cString\u003e,\n    pub schemas: Vec\u003cString\u003e,\n    pub consumers: Vec\u003cString\u003e,\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":5},"fn_name":null}],"covered":2,"coverable":10},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","consumer","client.rs"],"content":"use crate::lib::{\n    configuration::{build_kafka_client_config, ClusterConfig},\n    consumer::types::{ConsumerConfiguration, ConsumerSessionConfiguration, ConsumerState},\n    error_callback::ErrorCallback,\n    record_store::TopicStore,\n    types::RawKafkaRecord,\n};\nuse futures::{lock::Mutex, StreamExt};\nuse log::{debug, error, warn};\nuse rdkafka::{\n    consumer::{Consumer as ApacheKafkaConsumer, StreamConsumer},\n    message::OwnedMessage,\n    Message, Offset, TopicPartitionList,\n};\nuse std::{sync::Arc, time::Duration};\nuse tauri::async_runtime::JoinHandle;\n\nuse super::error::{ConsumerError, ConsumerResult};\n\npub struct KafkaConsumer {\n    cluster_config: ClusterConfig,\n    topic: String,\n    loop_handle: Arc\u003cMutex\u003cOption\u003cJoinHandle\u003c()\u003e\u003e\u003e\u003e,\n    error_callback: ErrorCallback\u003cConsumerError\u003e,\n    pub topic_store: Arc\u003cTopicStore\u003e,\n    timeout: Duration,\n}\n\nimpl KafkaConsumer {\n    pub fn new(\n        cluster_config: \u0026ClusterConfig,\n        topic: \u0026str,\n        topic_store: TopicStore,\n        error_cb: ErrorCallback\u003cConsumerError\u003e,\n        timeout: Duration,\n    ) -\u003e Self {\n        KafkaConsumer {\n            error_callback: error_cb,\n            cluster_config: cluster_config.clone(),\n            topic: topic.to_string(),\n            loop_handle: Arc::new(Mutex::new(None)),\n            topic_store: Arc::new(topic_store),\n            timeout,\n        }\n    }\n\n    pub fn update_consumer_assignment(\n        consumer: \u0026rdkafka::consumer::StreamConsumer,\n        topics: \u0026[\u0026str],\n        config: \u0026ConsumerSessionConfiguration,\n        tmo: Duration,\n    ) -\u003e ConsumerResult\u003c()\u003e {\n        let metadata = consumer.fetch_metadata(if topics.len() == 1 { Some(topics[0]) } else { None }, tmo)?;\n        let topic_partition: Vec\u003c_\u003e = metadata\n            .topics()\n            .iter()\n            .filter(|t| topics.contains(\u0026t.name()))\n            .flat_map(|t| t.partitions().iter().map(|p| (t.name(), p.id())))\n            .collect();\n\n        let mut timestamp_assignment = consumer.assignment()?;\n        match config {\n            ConsumerSessionConfiguration::Beginning =\u003e {\n                for (t, p) in topic_partition {\n                    timestamp_assignment.add_partition_offset(t, p, Offset::Beginning)?;\n                }\n            }\n            ConsumerSessionConfiguration::End =\u003e {\n                for (t, p) in topic_partition {\n                    timestamp_assignment.add_partition_offset(t, p, Offset::End)?;\n                }\n            }\n            ConsumerSessionConfiguration::Custom {\n                start_timestamp,\n                stop_timestamp: _,\n            } =\u003e {\n                // note: the offsets_for_times function takes a TopicPartitionList in which the\n                // offset is the timestamp in ms (instead of the actual offset) and returns a\n                // new TopicPartitionList with the actual offset\n                for (t, p) in topic_partition {\n                    timestamp_assignment.add_partition_offset(t, p, Offset::Offset(*start_timestamp))?;\n                }\n            }\n        }\n        let assignment = consumer.offsets_for_times(timestamp_assignment, tmo)?;\n        consumer.assign(\u0026assignment)?;\n        debug!(\"Partition assigned {:?}\", assignment);\n        Ok(())\n    }\n\n    pub async fn start(\u0026self, consumer_config: \u0026ConsumerConfiguration) -\u003e ConsumerResult\u003c()\u003e {\n        let topic = self.topic.clone();\n        if self.loop_handle.lock().await.is_some() {\n            warn!(\"Try to start an already running consumer\");\n            return Err(ConsumerError::AlreadyRunning(format!(\n                \"A consumer is already running for {}\",\n                topic\n            )));\n        }\n        // set the handle to the consumer loop\n        *self.loop_handle.clone().lock().await = Some(tauri::async_runtime::spawn({\n            // clone arcs for the closure below\n            let consumer: StreamConsumer = build_kafka_client_config(\u0026self.cluster_config, None)\n                .create()\n                .expect(\"Unable to create kafka the consumer\");\n\n            // configure the consumer\n            if let Err(err) = KafkaConsumer::update_consumer_assignment(\n                \u0026consumer,\n                \u0026[\u0026topic],\n                \u0026consumer_config.consumer_start_config,\n                self.timeout,\n            ) {\n                error!(\"{:?}\", err);\n                (self.error_callback)(err);\n                panic!(\"Unable to continue\");\n            }\n\n            let loop_handle = self.loop_handle.clone();\n            let topic_store = self.topic_store.clone();\n            let consumer_config = consumer_config.clone();\n            let error_callback = self.error_callback.clone();\n            async move { consumer_loop(\u0026consumer, \u0026consumer_config, \u0026topic_store, \u0026error_callback, loop_handle).await }\n        }));\n        Ok(())\n    }\n\n    pub async fn stop(\u0026self) -\u003e ConsumerResult\u003c()\u003e {\n        _stop(self.loop_handle.clone()).await\n    }\n\n    pub async fn get_consumer_state(\u0026self) -\u003e ConsumerResult\u003cConsumerState\u003e {\n        Ok(ConsumerState {\n            is_running: self.loop_handle.clone().lock().await.is_some(),\n            record_count: self\n                .topic_store\n                .get_records_count()\n                .map_err(|err| ConsumerError::RecordStore(\"Unable to retrieve the records count\".into(), err))?,\n        })\n    }\n}\n\nfn get_stop_timestamp(consumer_config: \u0026ConsumerConfiguration) -\u003e Option\u003cu64\u003e {\n    // retrieve the stop timestamp if specified\n    if let ConsumerSessionConfiguration::Custom {\n        stop_timestamp: Some(stop),\n        ..\n    } = \u0026consumer_config.consumer_start_config\n    {\n        Some(*stop as u64)\n    } else {\n        None\n    }\n}\n\nasync fn consumer_loop(\n    consumer: \u0026StreamConsumer,\n    consumer_config: \u0026ConsumerConfiguration,\n    topic_store: \u0026TopicStore,\n    error_callback: \u0026ErrorCallback\u003cConsumerError\u003e,\n    loop_handle: Arc\u003cMutex\u003cOption\u003cJoinHandle\u003c()\u003e\u003e\u003e\u003e,\n) {\n    let stop_timestamp = get_stop_timestamp(consumer_config);\n\n    // setup a new store\n    topic_store\n        .setup(consumer_config.compactify)\n        .expect(\"Unable to create the internal store\");\n\n    // infinite consumer loop\n    debug!(\"Start consumer loop\");\n    loop {\n        match consumer.stream().next().await {\n            Some(Ok(msg)) =\u003e {\n                handle_consumed_message(\u0026msg.detach(), topic_store, stop_timestamp, consumer, error_callback).await;\n            }\n            Some(Err(err)) =\u003e {\n                error!(\"An error occurs consuming from kafka: {}\", err);\n                error_callback(err.into());\n                _stop(loop_handle.clone()).await.expect(\"Unable to stop the consumer\");\n                break;\n            }\n            None =\u003e {\n                error!(\"Consumer unexpectedly returned no messages\");\n                break;\n            }\n        }\n    }\n}\n\nasync fn handle_consumed_message(\n    msg: \u0026OwnedMessage,\n    topic_store: \u0026TopicStore,\n    stop_timestamp: Option\u003cu64\u003e,\n    consumer: \u0026StreamConsumer,\n    error_callback: \u0026ErrorCallback\u003cConsumerError\u003e,\n) {\n    let record = map_kafka_record(msg);\n    if record.timestamp.unwrap_or(u64::MIN) \u003c stop_timestamp.unwrap_or(u64::MAX) {\n        topic_store.insert_record(\u0026record).await.unwrap_or_else(|err| {\n            error_callback(ConsumerError::RecordStore(\n                \"Unable to store the record\".to_string(),\n                err,\n            ))\n        });\n    } else {\n        // pause consumption on the record partition\n        let mut tpl = TopicPartitionList::new();\n        tpl.add_partition(\u0026record.topic, record.partition);\n        match consumer.pause(\u0026tpl) {\n            Ok(_) =\u003e {\n                debug!(\"Pause consuming {} partition {}\", record.topic, record.partition);\n            }\n            Err(err) =\u003e error!(\n                \"Unable to pause consuming {} partition {}: {:?}\",\n                record.topic, record.partition, err\n            ),\n        }\n    }\n}\n\nasync fn _stop(loop_handle: Arc\u003cMutex\u003cOption\u003cJoinHandle\u003c()\u003e\u003e\u003e\u003e) -\u003e ConsumerResult\u003c()\u003e {\n    debug!(\"Consumer stopped\");\n    if let Some(handle) = \u0026*loop_handle.lock().await {\n        handle.abort();\n    }\n    *loop_handle.lock().await = None;\n    Ok(())\n}\n\nfn map_kafka_record(msg: \u0026OwnedMessage) -\u003e RawKafkaRecord {\n    RawKafkaRecord {\n        payload: msg.payload().map(|v| v.to_owned()),\n        key: msg.key().map(|v| v.to_owned()),\n        topic: msg.topic().into(),\n        partition: msg.partition(),\n        offset: msg.offset(),\n        timestamp: msg.timestamp().to_millis().map(|v| v as u64),\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":13,"coverable":101},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","consumer","error.rs"],"content":"use rdkafka::error::KafkaError;\n\n#[derive(Debug)]\npub enum ConsumerError {\n    RDKafka(String),\n    RecordStore(String, crate::lib::record_store::StoreError),\n    AlreadyRunning(String),\n}\npub type ConsumerResult\u003cT\u003e = Result\u003cT, ConsumerError\u003e;\n\nimpl From\u003cKafkaError\u003e for ConsumerError {\n    fn from(error: KafkaError) -\u003e Self {\n        ConsumerError::RDKafka(error.to_string())\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","consumer","mod.rs"],"content":"mod client;\nmod error;\npub mod types;\npub use client::KafkaConsumer;\npub use error::ConsumerError;\npub use types::ConsumerConfiguration;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","consumer","types.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct ConsumerConfiguration {\n    pub compactify: bool,\n    pub consumer_start_config: ConsumerSessionConfiguration,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub enum ConsumerSessionConfiguration {\n    Beginning,\n    End,\n    Custom {\n        start_timestamp: i64,        //time in ms\n        stop_timestamp: Option\u003ci64\u003e, //time in ms\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone)]\npub struct ConsumerState {\n    #[serde(rename = \"isRunning\")]\n    pub is_running: bool,\n    #[serde(rename = \"recordCount\")]\n    pub record_count: usize,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","error_callback.rs"],"content":"use std::sync::Arc;\n\npub type ErrorCallback\u003cT\u003e = Arc\u003cdyn Fn(T) + Send + Sync\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","mod.rs"],"content":"pub mod admin;\npub mod avro;\npub mod configuration;\npub mod consumer;\npub mod parser;\n\npub mod error_callback;\npub mod producer;\npub mod record_store;\npub mod schema_registry;\npub mod types;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","parser","error.rs"],"content":"use crate::lib::avro::AvroError;\n\npub enum ParserError {\n    MissingAvroConfiguration,\n    Avro(AvroError),\n}\n\npub type ParserResult\u003cT\u003e = Result\u003cT, ParserError\u003e;\n\nimpl From\u003cAvroError\u003e for ParserError {\n    fn from(value: AvroError) -\u003e Self {\n        ParserError::Avro(value)\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","parser","mod.rs"],"content":"mod error;\nmod string_parser;\n\nuse std::sync::Arc;\n\nuse crate::lib::{\n    avro::{AvroParser, SchemaProvider},\n    schema_registry::CachedSchemaRegistry,\n    types::{ParsedKafkaRecord, RawKafkaRecord},\n};\n\nuse string_parser::parse_string;\n\npub use self::error::ParserError;\nuse self::error::ParserResult;\n\nuse super::types::ParserMode;\n\npub struct Parser\u003cC: SchemaProvider = CachedSchemaRegistry\u003e {\n    avro_parser: Option\u003cAvroParser\u003cC\u003e\u003e,\n}\n\nimpl\u003cC: SchemaProvider\u003e Parser\u003cC\u003e {\n    pub fn new(schema_registry_client: Option\u003cArc\u003cC\u003e\u003e) -\u003e Self {\n        Parser {\n            avro_parser: schema_registry_client.map(|client| AvroParser::new(client)),\n        }\n    }\n\n    pub async fn parse_from_kafka_record(\n        \u0026self,\n        record: \u0026RawKafkaRecord,\n        mode: ParserMode,\n    ) -\u003e ParserResult\u003cParsedKafkaRecord\u003e {\n        let RawKafkaRecord {\n            payload,\n            key,\n            topic,\n            timestamp,\n            partition,\n            offset,\n        } = record.clone();\n        let (key, payload) = match mode {\n            ParserMode::String =\u003e (key.map(|v| parse_string(\u0026v)), payload.map(|v| parse_string(\u0026v))),\n            ParserMode::Avro =\u003e {\n                let avro_parser = self.avro_parser.as_ref().ok_or(ParserError::MissingAvroConfiguration)?;\n                (\n                    key.map(|v| parse_string(\u0026v)),\n                    match payload {\n                        Some(v) =\u003e Some(avro_parser.avro_to_json(\u0026v).await?),\n                        None =\u003e None,\n                    },\n                )\n            }\n        };\n        Ok(ParsedKafkaRecord {\n            key,\n            payload,\n            topic,\n            timestamp,\n            partition,\n            offset,\n        })\n    }\n\n    pub async fn parse_payload_to_avro(\u0026self, payload: \u0026str, topic_name: \u0026str) -\u003e ParserResult\u003cVec\u003cu8\u003e\u003e {\n        if let Some(avro_parser) = self.avro_parser.as_ref() {\n            Ok(avro_parser\n                .json_to_avro(payload, \u0026format!(\"{}-value\", topic_name))\n                .await?)\n        } else {\n            Err(ParserError::MissingAvroConfiguration)\n        }\n    }\n\n    pub fn parse_payload_to_string(\u0026self, payload: \u0026str) -\u003e Vec\u003cu8\u003e {\n        payload.as_bytes().into()\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":34},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","parser","string_parser.rs"],"content":"pub(super) fn parse_string(v: \u0026[u8]) -\u003e String {\n    String::from_utf8_lossy(v).into_owned()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::parse_string;\n\n    #[test]\n    fn parse_empty_array_to_string() {\n        let vec = vec![];\n        let res = parse_string(\u0026vec);\n        assert_eq!(res, \"\")\n    }\n\n    #[test]\n    fn parse_invalid_to_string() {\n        let vec: Vec\u003cu8\u003e = vec![0x00, 0x41, 0xff];\n        let res = parse_string(\u0026vec);\n        assert!(!res.is_empty())\n    }\n}\n","traces":[{"line":1,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","producer","client.rs"],"content":"use std::sync::Arc;\n\nuse rdkafka::producer::{BaseProducer, BaseRecord};\n\nuse crate::lib::{\n    configuration::{build_kafka_client_config, ClusterConfig},\n    parser::Parser,\n    types::ParserMode,\n};\n\nuse super::{error::ProducerResult, record_parser::KafkaRecordParser};\n\npub struct KafkaProducer\u003cP: KafkaRecordParser = Parser\u003e {\n    producer: BaseProducer,\n    parser: Arc\u003cP\u003e,\n}\n\nimpl\u003cP: KafkaRecordParser\u003e KafkaProducer\u003cP\u003e {\n    pub fn new(cluster_config: \u0026ClusterConfig, parser: Arc\u003cP\u003e) -\u003e Self {\n        let producer: BaseProducer = build_kafka_client_config(cluster_config, None)\n            .create()\n            .expect(\"Unable to create the consumer\"); //todo: bubble up the error\n        Self { producer, parser }\n    }\n    // Use a None value for tombstones\n    pub async fn produce(\u0026self, topic: \u0026str, key: \u0026str, value: Option\u003c\u0026str\u003e, mode: ParserMode) -\u003e ProducerResult\u003c()\u003e {\n        let mut record = BaseRecord::to(topic).key(key);\n        let payload = if let Some(payload) = value {\n            match mode {\n                ParserMode::String =\u003e Some(self.parser.parse_to_string(payload)),\n                ParserMode::Avro =\u003e Some(self.parser.parse_to_avro(payload, topic).await?),\n            }\n        } else {\n            None\n        };\n        if let Some(value) = payload {\n            record = record.payload(\u0026value);\n            Ok(self.producer.send(record).map_err(|err| err.0)?)\n        } else {\n            Ok(self.producer.send(record).map_err(|err| err.0)?)\n        }\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":13},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","producer","error.rs"],"content":"use rdkafka::error::KafkaError;\n\nuse crate::lib::parser::ParserError;\n\npub enum ProducerError {\n    MissingAvroConfiguration,\n    RDKafka(String),\n    AvroParse(crate::lib::avro::AvroError),\n}\n\npub type ProducerResult\u003cT\u003e = Result\u003cT, ProducerError\u003e;\n\nimpl From\u003cKafkaError\u003e for ProducerError {\n    fn from(error: KafkaError) -\u003e Self {\n        ProducerError::RDKafka(error.to_string())\n    }\n}\n\nimpl From\u003cParserError\u003e for ProducerError {\n    fn from(value: ParserError) -\u003e Self {\n        match value {\n            ParserError::MissingAvroConfiguration =\u003e ProducerError::MissingAvroConfiguration,\n            ParserError::Avro(err) =\u003e ProducerError::AvroParse(err),\n        }\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":6},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","producer","mod.rs"],"content":"mod client;\nmod error;\nmod record_parser;\npub use client::KafkaProducer;\npub use error::ProducerError;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","producer","record_parser.rs"],"content":"use async_trait::async_trait;\n\nuse crate::lib::parser::Parser;\n\nuse super::error::ProducerResult;\n\n#[async_trait]\npub trait KafkaRecordParser {\n    fn parse_to_string(\u0026self, payload: \u0026str) -\u003e Vec\u003cu8\u003e;\n    async fn parse_to_avro(\u0026self, payload: \u0026str, topic_name: \u0026str) -\u003e ProducerResult\u003cVec\u003cu8\u003e\u003e;\n}\n\n#[async_trait]\nimpl KafkaRecordParser for Parser {\n    fn parse_to_string(\u0026self, payload: \u0026str) -\u003e Vec\u003cu8\u003e {\n        self.parse_payload_to_string(payload)\n    }\n    async fn parse_to_avro(\u0026self, payload: \u0026str, topic_name: \u0026str) -\u003e ProducerResult\u003cVec\u003cu8\u003e\u003e {\n        Ok(self.parse_payload_to_avro(payload, topic_name).await?)\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","record_store","error.rs"],"content":"use rusqlite::{ffi, Error as SqlError};\n\n#[derive(Debug, PartialEq, Eq)]\npub enum StoreError {\n    SqlError(String),\n    IO(String),\n    RecordParse(String),\n}\n\npub type StoreResult\u003cT\u003e = Result\u003cT, StoreError\u003e;\n\nimpl From\u003cSqlError\u003e for StoreError {\n    fn from(error: SqlError) -\u003e Self {\n        StoreError::SqlError(match error {\n            SqlError::SqliteFailure(ffi::Error { code, .. }, ..) =\u003e match code {\n                rusqlite::ErrorCode::OperationInterrupted =\u003e \"Operation timed out\".into(),\n                _ =\u003e format!(\"{} {:?}\", error, code),\n            },\n            _ =\u003e error.to_string(),\n        })\n    }\n}\nimpl From\u003cstd::io::Error\u003e for StoreError {\n    fn from(error: std::io::Error) -\u003e Self {\n        StoreError::IO(error.to_string())\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":6,"coverable":8},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","record_store","mod.rs"],"content":"mod error;\nmod query;\nmod record_parser;\nmod sqlite_store;\nmod topic_store;\npub mod types;\n\npub use error::StoreError;\npub use sqlite_store::SqliteStore;\npub use topic_store::TopicStore;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","record_store","query.rs"],"content":"#[derive(Debug)]\npub struct Query {\n    pub cluster_id: String,\n    pub topic_name: String,\n    pub offset: i64,\n    pub limit: i64,\n    pub query_template: String,\n}\n\nimpl Query {\n    pub const SELECT_WITH_OFFSET_LIMIT_QUERY : \u0026str = \"SELECT partition, offset, timestamp, key, payload FROM {:topic} ORDER BY timestamp desc LIMIT {:limit} OFFSET {:offset}\";\n\n    #[cfg(test)]\n    pub fn select_any(cluster_id: \u0026str, topic_name: \u0026str, offset: i64, limit: i64) -\u003e Query {\n        Query {\n            cluster_id: cluster_id.into(),\n            topic_name: topic_name.into(),\n            limit,\n            offset,\n            query_template: Query::SELECT_WITH_OFFSET_LIMIT_QUERY.into(),\n        }\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":8},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","record_store","record_parser.rs"],"content":"use async_trait::async_trait;\n\nuse crate::lib::{\n    parser::Parser,\n    types::{ParsedKafkaRecord, ParserMode, RawKafkaRecord},\n};\n\nuse super::error::{StoreError, StoreResult};\n\n#[async_trait]\npub trait KafkaRecordParser {\n    async fn parse_kafka_record(\u0026self, record: \u0026RawKafkaRecord) -\u003e StoreResult\u003cParsedKafkaRecord\u003e;\n}\n\n#[async_trait]\nimpl KafkaRecordParser for Parser {\n    async fn parse_kafka_record(\u0026self, record: \u0026RawKafkaRecord) -\u003e StoreResult\u003cParsedKafkaRecord\u003e {\n        if let Ok(avro_record) = self.parse_from_kafka_record(record, ParserMode::Avro).await {\n            Ok(avro_record)\n        } else {\n            self.parse_from_kafka_record(record, ParserMode::String)\n                .await\n                .map_err(|_| StoreError::RecordParse(\"Unable to parse the kafka record before storing\".to_string()))\n        }\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":6},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","record_store","sqlite_store.rs"],"content":"use core::time;\nuse std::time::{Duration, Instant};\n\nuse crate::lib::types::ParsedKafkaRecord;\nuse log::debug;\nuse r2d2::Pool;\nuse r2d2_sqlite::SqliteConnectionManager;\nuse rusqlite::{backup::Backup, named_params, Connection, OpenFlags};\n\nuse super::{error::StoreResult, query::Query};\n\npub trait RecordStore {\n    fn create_or_replace_topic_table(\u0026self, cluster_id: \u0026str, topic_name: \u0026str, compacted: bool) -\u003e StoreResult\u003c()\u003e;\n    fn query_records(\u0026self, query: \u0026Query, timeout: Option\u003cDuration\u003e) -\u003e StoreResult\u003cVec\u003cParsedKafkaRecord\u003e\u003e;\n    fn insert_record(\u0026self, cluster_id: \u0026str, topic_name: \u0026str, record: \u0026ParsedKafkaRecord) -\u003e StoreResult\u003c()\u003e;\n    fn destroy(\u0026self, cluster_id: \u0026str, topic_name: \u0026str) -\u003e StoreResult\u003c()\u003e;\n}\n\npub struct SqliteStore {\n    pool: Pool\u003cSqliteConnectionManager\u003e,\n    timeout: Duration,\n}\n\nimpl RecordStore for SqliteStore {\n    fn query_records(\u0026self, query: \u0026Query, timeout: Option\u003cDuration\u003e) -\u003e StoreResult\u003cVec\u003cParsedKafkaRecord\u003e\u003e {\n        let parsed_query = Self::parse_query(query);\n        // closure that actually execute the query\n        let _get_records = move |connection: \u0026r2d2::PooledConnection\u003cSqliteConnectionManager\u003e| {\n            let mut stmt = connection.prepare(\u0026parsed_query)?;\n            let records_iter = stmt.query_map([], |row| {\n                Ok(ParsedKafkaRecord {\n                    topic: query.topic_name.clone(),\n                    partition: row.get(0)?,\n                    offset: row.get(1)?,\n                    timestamp: row.get(2)?,\n                    key: row.get(3)?,\n                    payload: row.get(4)?,\n                })\n            })?;\n            let mut records = Vec::new();\n            for r in records_iter {\n                records.push(r?);\n            }\n            Ok(records)\n        };\n        let connection = self.pool.get().unwrap();\n        let start_query = Instant::now();\n        let timeout = timeout.unwrap_or(self.timeout);\n        // setup the progress handler for the connection\n        connection.progress_handler(2500, Some(move || start_query.elapsed() \u003e timeout));\n        // run the query\n        let result = _get_records(\u0026connection);\n        // remove the progress handler attached to the connection before returning the result\n        connection.progress_handler(0, None::\u003cfn() -\u003e bool\u003e);\n        result\n    }\n\n    fn create_or_replace_topic_table(\u0026self, cluster_id: \u0026str, topic_name: \u0026str, compacted: bool) -\u003e StoreResult\u003c()\u003e {\n        let connection = self.pool.get().unwrap();\n        self.destroy(cluster_id, topic_name)?;\n        connection\n            .execute(\n                format!(\n                    \"CREATE TABLE {} (\n                        partition   NUMBER,\n                        offset      NUMBER,\n                        timestamp   NUMBER,\n                        key         TEXT {},\n                        payload     TEXT,\n                        PRIMARY KEY (partition, offset))\",\n                    Self::get_table_name(cluster_id, topic_name),\n                    match compacted {\n                        true =\u003e \"UNIQUE\",\n                        false =\u003e \"\",\n                    }\n                )\n                .as_str(),\n                [],\n            )\n            .unwrap_or_else(|e| panic!(\"Unable to create the table for {} {} {:?}\", cluster_id, topic_name, e));\n        Ok(())\n    }\n\n    fn insert_record(\u0026self, cluster_id: \u0026str, topic_name: \u0026str, record: \u0026ParsedKafkaRecord) -\u003e StoreResult\u003c()\u003e {\n        let connection = self.pool.get().unwrap();\n        connection.execute(\n            format!(\n                \"INSERT OR REPLACE INTO {} (partition, offset, timestamp, key, payload) \n                VALUES (:partition, :offset, :timestamp, :key, :payload)\",\n                Self::get_table_name(cluster_id, topic_name)\n            )\n            .as_str(),\n            named_params! {\n                \":partition\": \u0026record.partition,\n                \":offset\": \u0026record.offset,\n                \":timestamp\": \u0026record.timestamp,\n                \":key\": \u0026record.key,\n                \":payload\": \u0026record.payload,\n            },\n        )?;\n        Ok(())\n    }\n\n    fn destroy(\u0026self, cluster_id: \u0026str, topic_name: \u0026str) -\u003e StoreResult\u003c()\u003e {\n        let connection = self.pool.get().unwrap();\n        connection\n            .execute(\n                format!(\"DROP TABLE IF EXISTS {}\", Self::get_table_name(cluster_id, topic_name)).as_str(),\n                [],\n            )\n            .unwrap_or_else(|_| panic!(\"Unable to create the table for {} {}\", cluster_id, topic_name));\n        Ok(())\n    }\n}\n\nimpl SqliteStore {\n    pub fn new(timeout: Duration) -\u003e Self {\n        let file_name = format!(\"file::memory{}:?cache=shared\u0026mode=memory\", rand::random::\u003cusize\u003e());\n        let flags_r = OpenFlags::SQLITE_OPEN_READ_WRITE | OpenFlags::SQLITE_OPEN_NO_MUTEX | OpenFlags::SQLITE_OPEN_URI;\n        let manager = SqliteConnectionManager::file(file_name)\n            .with_flags(flags_r)\n            .with_init(|conn| {\n                conn.pragma_update(None, \"journal_mode\", \"OFF\").unwrap();\n                conn.pragma_update(None, \"synchronous\", \"OFF\").unwrap();\n                conn.pragma_update(None, \"page_size\", \"4096\").unwrap();\n                conn.pragma_update(None, \"cache_size\", \"16384\").unwrap();\n                conn.pragma_update(None, \"locking_mode\", \"NORMAL\").unwrap();\n                conn.pragma_update(None, \"read_uncommitted\", \"ON\").unwrap();\n                Ok(())\n            });\n        let pool = r2d2::Pool::builder()\n            .max_size(20)\n            .build(manager)\n            .expect(\"Unable to initialize the read only connection pool to the db\");\n        SqliteStore { pool, timeout }\n    }\n\n    #[cfg(test)]\n    fn get_size(\u0026self, query: \u0026Query) -\u003e StoreResult\u003cusize\u003e {\n        use super::error::StoreError;\n\n        let connection = self.pool.get().unwrap();\n        let mut stmt = connection.prepare(format!(\"SELECT count(*) FROM ({})\", Self::parse_query(query)).as_str())?;\n        let rows: Vec\u003c_\u003e = stmt.query_map([], |row| row.get::\u003c_, i64\u003e(0))?.collect();\n        if let Some(Ok(size)) = rows.first() {\n            Ok(*size as usize)\n        } else {\n            Err(StoreError::SqlError(\"Unable to get the table size\".to_string()))\n        }\n    }\n\n    pub fn export_db(\u0026self, output_path: \u0026str) -\u003e StoreResult\u003c()\u003e {\n        let src = self.pool.get().unwrap();\n        let mut dst = Connection::open(output_path)?;\n        let backup = Backup::new(\u0026src, \u0026mut dst)?;\n        backup.run_to_completion(\n            1000,\n            time::Duration::from_millis(100),\n            Some(|p| {\n                debug!(\n                    \"Export in progress: {}%\",\n                    100f32 * ((p.pagecount - p.remaining) as f32 / p.pagecount as f32)\n                )\n            }),\n        )?;\n        Ok(())\n    }\n\n    fn parse_query(query: \u0026Query) -\u003e String {\n        let Query {\n            cluster_id,\n            topic_name,\n            offset,\n            limit,\n            query_template,\n        } = query;\n        let query = query_template\n            .replace(\"{:topic}\", Self::get_table_name(cluster_id, topic_name).as_str())\n            .replace(\"{:limit}\", limit.to_string().as_str())\n            .replace(\"{:offset}\", offset.to_string().as_str());\n        let query = query.trim();\n        if query.ends_with(';') {\n            let mut chars = query.chars();\n            chars.next_back();\n            chars.as_str().into()\n        } else {\n            query.into()\n        }\n    }\n\n    fn get_table_name(cluster_id: \u0026str, topic_name: \u0026str) -\u003e String {\n        format!(\"\\'[{}].[{}]\\'\", cluster_id, topic_name)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::lib::{\n        record_store::{error::StoreError, sqlite_store::Query},\n        types::ParsedKafkaRecord,\n    };\n    use std::{\n        env::temp_dir,\n        sync::Arc,\n        thread::spawn,\n        time::{Duration, Instant},\n    };\n\n    use super::{RecordStore, SqliteStore};\n\n    fn get_test_db_path() -\u003e String {\n        let mut dir = temp_dir();\n        dir.push(\"test.db\");\n        dir.to_str().unwrap().into()\n    }\n\n    #[tokio::test]\n    async fn test_export_database() {\n        // arrange\n        let test_db_path = get_test_db_path();\n        let (cluster_id, topic_name) = (\"cluster_id_example\", \"topic_name_example\");\n        let db = SqliteStore::new(Duration::from_secs(10));\n        db.create_or_replace_topic_table(cluster_id, topic_name, false).unwrap();\n        let test_record = get_test_record(topic_name, 0);\n        db.insert_record(cluster_id, topic_name, \u0026test_record).unwrap();\n        // act\n        let res = db.export_db(\u0026test_db_path);\n        // assert\n        assert!(res.is_ok());\n        //todo: validate DB content\n    }\n\n    #[tokio::test]\n    async fn test_create_table() {\n        let db = SqliteStore::new(Duration::from_secs(10));\n        let res = db.create_or_replace_topic_table(\"cluster_id_example\", \"topic_name_example\", false);\n        assert!(res.is_ok())\n    }\n\n    #[tokio::test]\n    async fn test_insert_and_get_record() {\n        // arrange\n        let (cluster_id, topic_name) = (\"cluster_id_example\", \"topic_name_example\");\n        let db = SqliteStore::new(Duration::from_secs(10));\n        db.create_or_replace_topic_table(cluster_id, topic_name, false)\n            .expect(\"Unable to create the table\");\n        let test_record = get_test_record(topic_name, 0);\n        // act\n        db.insert_record(cluster_id, topic_name, \u0026test_record).unwrap();\n        let records_back = db\n            .query_records(\u0026Query::select_any(cluster_id, topic_name, 0, 1000), None)\n            .unwrap();\n        // assert\n        assert_eq!(records_back.len(), 1);\n        assert_eq!(records_back[0], test_record);\n    }\n\n    #[tokio::test]\n    async fn test_query_timeout() {\n        // arrange\n        let (cluster_id, topic_name) = (\"cluster_id_example\", \"topic_name_example\");\n        let db = SqliteStore::new(Duration::from_micros(1));\n        db.create_or_replace_topic_table(cluster_id, topic_name, false)\n            .expect(\"Unable to create the table\");\n        // act\n        (0..10000).for_each(|i| {\n            db.insert_record(cluster_id, topic_name, \u0026get_test_record(topic_name, i))\n                .unwrap()\n        });\n        let records_back = db.query_records(\u0026Query::select_any(cluster_id, topic_name, 0, 1000), None);\n        // assert\n        assert_eq!(\n            records_back.err().unwrap(),\n            StoreError::SqlError(\"Operation timed out\".into())\n        );\n    }\n\n    #[tokio::test]\n    async fn test_insert_and_get_records() {\n        // arrange\n        let (cluster_id, topic_name) = (\"cluster_id_example\", \"topic_name_example\");\n        let db = SqliteStore::new(Duration::from_secs(10));\n        let test_record1 = get_test_record(topic_name, 0);\n        let test_record2 = ParsedKafkaRecord {\n            offset: 1,\n            payload: Some(\"latest-test\".into()),\n            ..test_record1.clone()\n        };\n        // compacted table should replace old records with same key\n        {\n            db.create_or_replace_topic_table(cluster_id, topic_name, true)\n                .expect(\"Unable to create the table\");\n            // act\n            db.insert_record(cluster_id, topic_name, \u0026test_record1).unwrap();\n            db.insert_record(cluster_id, topic_name, \u0026test_record2).unwrap();\n            let records_back = db\n                .query_records(\u0026Query::select_any(cluster_id, topic_name, 0, 1000), None)\n                .unwrap();\n            // assert\n            assert_eq!(records_back.len(), 1);\n            assert_eq!(records_back[0], test_record2);\n        }\n        // non compacted table should persist all the data\n        {\n            db.create_or_replace_topic_table(cluster_id, topic_name, false)\n                .expect(\"Unable to create the table\");\n            // act\n            db.insert_record(cluster_id, topic_name, \u0026test_record1).unwrap();\n            db.insert_record(cluster_id, topic_name, \u0026test_record2).unwrap();\n            let records_back = db\n                .query_records(\u0026Query::select_any(cluster_id, topic_name, 0, 1000), None)\n                .unwrap();\n            // assert\n            assert_eq!(records_back.len(), 2);\n            assert_eq!(records_back[1], test_record2);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_get_size() {\n        // arrange\n        let (cluster_id, topic_name) = (\"cluster_id_example\", \"topic_name_example\");\n        let db = SqliteStore::new(Duration::from_secs(10));\n        db.create_or_replace_topic_table(cluster_id, topic_name, false)\n            .expect(\"Unable to create the table\");\n        // act\n        db.insert_record(cluster_id, topic_name, \u0026get_test_record(topic_name, 0))\n            .unwrap();\n        db.insert_record(cluster_id, topic_name, \u0026get_test_record(topic_name, 1))\n            .unwrap();\n        db.insert_record(cluster_id, topic_name, \u0026get_test_record(topic_name, 2))\n            .unwrap();\n        let table_size = db\n            .get_size(\u0026Query::select_any(cluster_id, topic_name, 0, 1000))\n            .unwrap();\n        // assert\n        assert_eq!(table_size, 3);\n    }\n\n    #[tokio::test]\n    async fn test_get_size_with_query() {\n        // arrange\n        let (cluster_id, topic_name) = (\"cluster_id_example\", \"topic_name_example\");\n        let db = SqliteStore::new(Duration::from_secs(10));\n        db.create_or_replace_topic_table(cluster_id, topic_name, false)\n            .expect(\"Unable to create the table\");\n        let record1 = ParsedKafkaRecord {\n            key: Some(\"test\".into()),\n            ..get_test_record(topic_name, 1)\n        };\n        let record2 = ParsedKafkaRecord {\n            offset: 2,\n            ..record1.clone()\n        };\n        // act\n        db.insert_record(cluster_id, topic_name, \u0026record1).unwrap();\n        db.insert_record(cluster_id, topic_name, \u0026record2).unwrap();\n        db.insert_record(cluster_id, topic_name, \u0026get_test_record(topic_name, 3))\n            .unwrap();\n        let table_size = db\n            .get_size(\u0026Query {\n                cluster_id: cluster_id.into(),\n                topic_name: topic_name.into(),\n                limit: -1,\n                offset: -1,\n                query_template:\n                    \"SELECT * from {:topic} WHERE key = \\\"test\\\" ORDER BY offset LIMIT {:limit} OFFSET {:offset};\".into(),\n            })\n            .unwrap();\n        // assert\n        assert_eq!(table_size, 2);\n    }\n\n    #[tokio::test]\n    async fn test_use_offset() {\n        // arrange\n        let (cluster_id, topic_name) = (\"cluster_id_example\", \"topic_name_example\");\n        let db = SqliteStore::new(Duration::from_secs(10));\n        db.create_or_replace_topic_table(cluster_id, topic_name, false)\n            .expect(\"Unable to create the table\");\n        // act\n        db.insert_record(cluster_id, topic_name, \u0026get_test_record(topic_name, 0))\n            .unwrap();\n        db.insert_record(cluster_id, topic_name, \u0026get_test_record(topic_name, 1))\n            .unwrap();\n        db.insert_record(cluster_id, topic_name, \u0026get_test_record(topic_name, 2))\n            .unwrap();\n        let first_1000_res = db\n            .query_records(\u0026Query::select_any(cluster_id, topic_name, 0, 1000), None)\n            .unwrap();\n        let first_res = db\n            .query_records(\u0026Query::select_any(cluster_id, topic_name, 1, 1), None)\n            .unwrap();\n        let no_res = db\n            .query_records(\u0026Query::select_any(cluster_id, topic_name, 3, 1000), None)\n            .unwrap();\n        // assert\n        assert_eq!(first_1000_res.len(), 3);\n        assert_eq!(first_res.len(), 1);\n        assert_eq!(no_res.len(), 0);\n    }\n\n    #[ignore]\n    #[tokio::test]\n    async fn bench_insert_and_get_record() {\n        use futures::executor::block_on;\n        // arrange\n        let (cluster_id, topic_name) = (\"cluster_id_example\", \"topic_name_example\");\n        let topic_name2 = \"topic_name_example2\";\n        let db = Arc::new(SqliteStore::new(Duration::from_secs(10)));\n\n        async fn write(id: i32, db: Arc\u003cSqliteStore\u003e, cluster_id: \u0026str, topic_name: \u0026str) {\n            let start = Instant::now();\n            let test_record = get_test_record(topic_name, 0);\n            for i in 0..10_000 {\n                let res = db.insert_record(cluster_id, topic_name, \u0026test_record);\n                if res.is_err() {\n                    println!(\"write-{} {} {:?}\", id, i, res);\n                }\n            }\n            println!(\"write-{} Time elapsed: {:?}\", id, start.elapsed());\n        }\n\n        async fn read(id: i32, db: Arc\u003cSqliteStore\u003e, cluster_id: \u0026str, topic_name: \u0026str) {\n            let start = Instant::now();\n            for i in 0..10_000 {\n                let res = db.query_records(\u0026Query::select_any(cluster_id, topic_name, 0, 1000), None);\n                if res.is_err() {\n                    println!(\"read-{} {} {:?}\", id, i, res);\n                }\n            }\n            println!(\"read-{} Time elapsed: {:?}\", id, start.elapsed());\n        }\n\n        // act\n        // topic1\n        db.create_or_replace_topic_table(cluster_id, topic_name, false)\n            .expect(\"Unable to create the table\");\n        let write1 = spawn({\n            let db = db.clone();\n            move || block_on(write(1, db.clone(), cluster_id, topic_name))\n        });\n\n        let read1 = spawn({\n            let db = db.clone();\n            move || block_on(read(1, db.clone(), cluster_id, topic_name))\n        });\n\n        let read2 = spawn({\n            let db = db.clone();\n            move || block_on(read(2, db.clone(), cluster_id, topic_name))\n        });\n\n        // topic2\n        db.create_or_replace_topic_table(cluster_id, topic_name2, false)\n            .expect(\"Unable to create the table\");\n\n        let write2 = spawn({\n            let db = db.clone();\n            move || block_on(write(2, db.clone(), cluster_id, topic_name2))\n        });\n\n        let read3 = spawn({\n            let db = db.clone();\n            move || block_on(read(2, db.clone(), cluster_id, topic_name2))\n        });\n\n        let read4 = spawn({\n            let db = db;\n            move || block_on(read(2, db.clone(), cluster_id, topic_name2))\n        });\n\n        assert!(write1.join().is_ok());\n        assert!(read1.join().is_ok());\n        assert!(read2.join().is_ok());\n        assert!(write2.join().is_ok());\n        assert!(read3.join().is_ok());\n        assert!(read4.join().is_ok());\n    }\n\n    fn get_test_record(topic_name: \u0026str, offset: i64) -\u003e ParsedKafkaRecord {\n        ParsedKafkaRecord {\n            payload: Some(\"example payload\".to_string()),\n            key: Some(\"key\".into()),\n            topic: topic_name.into(),\n            timestamp: Some(321123321),\n            partition: 2,\n            offset,\n        }\n    }\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":10015},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":10015},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":10015},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":10015},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":10015},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":10015},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":10015},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":10015},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":10015},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":10015},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":10015},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":10015},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":10015},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":10015},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":10015},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":166},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":160},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":160},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":160},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":160},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":160},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":160},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":160},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":10042},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":10042},"fn_name":null}],"covered":116,"coverable":119},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","record_store","topic_store.rs"],"content":"use log::{debug, trace};\nuse rdkafka::message::ToBytes;\n\nuse crate::lib::{\n    parser::Parser,\n    types::{ParsedKafkaRecord, RawKafkaRecord},\n};\nuse std::{\n    fs::OpenOptions,\n    io::{LineWriter, Write},\n    sync::{Arc, RwLock},\n    time::Duration,\n};\n\nuse super::{\n    error::StoreResult,\n    query::Query,\n    record_parser::KafkaRecordParser,\n    sqlite_store::{RecordStore, SqliteStore},\n    types::ExportOptions,\n};\n\npub struct TopicStore\u003cS: RecordStore = SqliteStore, P: KafkaRecordParser = Parser\u003e {\n    cluster_id: String,\n    topic_name: String,\n    store: Arc\u003cS\u003e,\n    parser: Arc\u003cP\u003e,\n    records_counter: RwLock\u003cusize\u003e,\n}\n\nimpl\u003cS: RecordStore, P: KafkaRecordParser\u003e TopicStore\u003cS, P\u003e {\n    pub fn from_record_store(store: Arc\u003cS\u003e, parser: Arc\u003cP\u003e, cluster_id: \u0026str, topic_name: \u0026str) -\u003e Self {\n        store\n            .create_or_replace_topic_table(cluster_id, topic_name, false)\n            .unwrap_or_else(|_| {\n                panic!(\n                    \"Unable to create the table to store the records from topic {}\",\n                    topic_name\n                )\n            });\n        TopicStore {\n            cluster_id: cluster_id.to_string(),\n            topic_name: topic_name.to_string(),\n            store,\n            parser,\n            records_counter: Default::default(),\n        }\n    }\n\n    pub fn setup(\u0026self, compactify: bool) -\u003e StoreResult\u003c()\u003e {\n        *self.records_counter.write().unwrap() = 0;\n        self.store\n            .create_or_replace_topic_table(\u0026self.cluster_id, \u0026self.topic_name, compactify)\n    }\n\n    pub fn get_records(\n        \u0026self,\n        query: Option\u003c\u0026str\u003e,\n        offset: i64,\n        limit: i64,\n        timeout: Option\u003cDuration\u003e,\n    ) -\u003e StoreResult\u003cVec\u003cParsedKafkaRecord\u003e\u003e {\n        self.store.query_records(\n            \u0026Query {\n                cluster_id: self.cluster_id.clone(),\n                topic_name: self.topic_name.clone(),\n                offset,\n                limit,\n                query_template: match query {\n                    Some(query) =\u003e query,\n                    None =\u003e Query::SELECT_WITH_OFFSET_LIMIT_QUERY,\n                }\n                .into(),\n            },\n            timeout,\n        )\n    }\n\n    pub async fn insert_record(\u0026self, record: \u0026RawKafkaRecord) -\u003e StoreResult\u003c()\u003e {\n        *self.records_counter.write().unwrap() += 1;\n        let parsed_record = self.parser.parse_kafka_record(record).await?;\n        self.store\n            .insert_record(\u0026self.cluster_id, \u0026self.topic_name, \u0026parsed_record)\n    }\n\n    pub fn get_records_count(\u0026self) -\u003e StoreResult\u003cusize\u003e {\n        Ok(*self.records_counter.read().unwrap())\n    }\n\n    pub fn export_records(\u0026self, options: \u0026ExportOptions) -\u003e StoreResult\u003c()\u003e {\n        let ExportOptions {\n            limit,\n            query,\n            output_path,\n            overwrite,\n            parse_timestamp,\n        } = options;\n        debug!(\"Exporting records to {}\", output_path);\n        let query_limit = limit.unwrap_or(-1); // export all the results if no limit is specified\n        let out_file = {\n            if *overwrite {\n                OpenOptions::new()\n                    .write(true)\n                    .truncate(true)\n                    .create(true)\n                    .open(output_path)\n            } else {\n                OpenOptions::new()\n                    .write(true)\n                    .truncate(true)\n                    .create_new(true)\n                    .open(output_path)\n            }\n        }?;\n        let mut writer = LineWriter::new(out_file);\n        let query_result: Vec\u003cParsedKafkaRecord\u003e =\n            self.get_records(query.as_deref(), 0, query_limit, Some(Duration::from_secs(3 * 60)))?;\n        trace!(\"Write records to the out file\");\n        writer.write_all(ParsedKafkaRecord::to_string_header().to_bytes())?;\n        for record in query_result {\n            writer.write_all(b\"\\n\")?;\n            writer.write_all(record.to_csv_line(*parse_timestamp).to_bytes())?;\n        }\n        writer.flush()?;\n        debug!(\"Export completed\");\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use std::env::temp_dir;\n    use std::fs;\n    use std::sync::Arc;\n    use std::time::Duration;\n\n    use mockall::*;\n\n    use super::TopicStore;\n    use crate::lib::record_store::error::StoreResult;\n    use crate::lib::record_store::query::Query;\n    use crate::lib::record_store::record_parser::KafkaRecordParser;\n    use crate::lib::record_store::sqlite_store::RecordStore;\n    use crate::lib::record_store::types::ExportOptions;\n    use crate::lib::types::{ParsedKafkaRecord, RawKafkaRecord};\n    use async_trait::async_trait;\n\n    mock! {\n        Parser {}\n        #[async_trait]\n        impl KafkaRecordParser for Parser {\n            async fn parse_kafka_record(\u0026self, record: \u0026RawKafkaRecord) -\u003e StoreResult\u003cParsedKafkaRecord\u003e;\n        }\n    }\n    mock! {\n        Store {}\n        impl RecordStore for Store {\n            fn query_records(\u0026self, query: \u0026Query, timeout: Option\u003cDuration\u003e) -\u003e StoreResult\u003cVec\u003cParsedKafkaRecord\u003e\u003e;\n            fn create_or_replace_topic_table(\u0026self, cluster_id: \u0026str, topic_name: \u0026str, compacted: bool) -\u003e StoreResult\u003c()\u003e;\n            fn insert_record(\u0026self, cluster_id: \u0026str, topic_name: \u0026str, record: \u0026ParsedKafkaRecord) -\u003e StoreResult\u003c()\u003e;\n            fn destroy(\u0026self, cluster_id: \u0026str, topic_name: \u0026str) -\u003e StoreResult\u003c()\u003e;\n        }\n    }\n\n    #[test]\n    fn test_export_all_records() {\n        // arrange\n        let mut mock_record_store = MockStore::new();\n        let parser_mock = MockParser::new();\n        mock_record_store\n            .expect_create_or_replace_topic_table()\n            .returning(|_, _, _| Ok(()));\n        mock_record_store\n            .expect_query_records()\n            .returning(|_, _| Ok(vec![create_test_record(0), create_test_record(1)]));\n        let sut = TopicStore::from_record_store(\n            Arc::new(mock_record_store),\n            Arc::new(parser_mock),\n            \"cluster_id\",\n            \"topic_name\",\n        );\n\n        let test_file = format!(\"{}/{}\", temp_dir().to_str().unwrap(), rand::random::\u003cusize\u003e());\n        println!(\"{}\", test_file);\n        let select_all_query = \"SELECT partition, offset, timestamp, key, payload FROM {:topic} ORDER BY timestamp desc LIMIT {:limit} OFFSET {:offset}\";\n        // act\n        let options = ExportOptions {\n            query: Some(select_all_query.to_string()),\n            output_path: test_file.clone(),\n            overwrite: true,\n            ..Default::default()\n        };\n        let res = sut.export_records(\u0026options);\n        // assert\n        let exported_data = fs::read_to_string(test_file).unwrap();\n        assert!(res.is_ok());\n        assert_eq!(\n            exported_data,\n            \"timestamp;partition;offset;key;payload\\n123123;0;0;key;payload\\n123123;1;0;key;payload\"\n        );\n    }\n\n    #[test]\n    fn test_export_no_records() {\n        // arrange\n        let mut mock_record_store = MockStore::new();\n        let parser_mock = MockParser::new();\n        mock_record_store.expect_query_records().returning(|_, _| Ok(vec![]));\n        mock_record_store\n            .expect_create_or_replace_topic_table()\n            .returning(|_, _, _| Ok(()));\n        let sut = TopicStore::from_record_store(\n            Arc::new(mock_record_store),\n            Arc::new(parser_mock),\n            \"cluster_id\",\n            \"topic_name\",\n        );\n\n        let test_file = format!(\"{}/{}\", temp_dir().to_str().unwrap(), rand::random::\u003cusize\u003e());\n        let select_all_query = \"SELECT partition, offset, timestamp, key, payload FROM {:topic} ORDER BY timestamp desc LIMIT {:limit} OFFSET {:offset}\";\n        // act\n        let options = ExportOptions {\n            query: Some(select_all_query.to_string()),\n            output_path: test_file.clone(),\n            overwrite: true,\n            ..Default::default()\n        };\n        let res = sut.export_records(\u0026options);\n        // assert\n        let exported_data = fs::read_to_string(test_file).unwrap();\n        assert!(res.is_ok());\n        assert_eq!(exported_data, \"timestamp;partition;offset;key;payload\");\n    }\n\n    #[test]\n    fn test_overwrite_files() {\n        let mut mock_record_store = MockStore::new();\n        let parser_mock = MockParser::new();\n        mock_record_store\n            .expect_create_or_replace_topic_table()\n            .returning(|_, _, _| Ok(()));\n        mock_record_store.expect_query_records().returning(|_, _| Ok(vec![]));\n        let sut = TopicStore::from_record_store(\n            Arc::new(mock_record_store),\n            Arc::new(parser_mock),\n            \"cluster_id\",\n            \"topic_name\",\n        );\n        let select_all_query = \"SELECT partition, offset, timestamp, key, payload FROM {:topic} ORDER BY timestamp desc LIMIT {:limit} OFFSET {:offset}\";\n        let options = ExportOptions {\n            query: Some(select_all_query.to_string()),\n            output_path: format!(\"{}/test{}\", temp_dir().to_str().unwrap(), rand::random::\u003cusize\u003e()),\n            overwrite: true,\n            ..Default::default()\n        };\n        // truncate the file if overwrite true\n        {\n            let mut options = options.clone();\n            options.overwrite = true;\n            assert!(sut.export_records(\u0026options).is_ok());\n            assert!(sut.export_records(\u0026options).is_ok());\n        }\n        // return err if the file already exists and overwrite is false\n        {\n            let mut options = options;\n            options.overwrite = true;\n            assert!(sut.export_records(\u0026options).is_ok());\n            options.overwrite = false;\n            assert!(sut.export_records(\u0026options).is_err());\n        }\n    }\n\n    fn create_test_record(i: i32) -\u003e ParsedKafkaRecord {\n        ParsedKafkaRecord {\n            payload: Some(\"payload\".into()),\n            key: Some(\"key\".into()),\n            topic: \"topic\".into(),\n            timestamp: Some(123123),\n            partition: i,\n            offset: 0,\n        }\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":5},"fn_name":null}],"covered":42,"coverable":59},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","record_store","types.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Default, Debug, Clone)]\npub struct ExportOptions {\n    pub query: Option\u003cString\u003e,\n    #[serde(rename = \"outputPath\")]\n    pub output_path: String,\n    pub limit: Option\u003ci64\u003e,\n    #[serde(rename = \"parseTimestamp\")]\n    pub parse_timestamp: bool,\n    pub overwrite: bool,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","schema_registry","client.rs"],"content":"use log::{debug, trace};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\nuse url::Url;\n\nuse apache_avro::Schema as AvroSchema;\n\nuse super::error::{SchemaRegistryError, SchemaRegistryResult};\nuse super::http_client::{HttpClient, ReqwestClient};\nuse super::types::{BasicAuth, ResolvedAvroSchema, Schema, Subject};\n\n#[derive(Deserialize)]\nstruct GetSchemaByIdResult {\n    pub schema: String,\n}\n\n#[derive(Clone)]\npub struct CachedSchemaRegistry\u003cC: HttpClient = ReqwestClient\u003e {\n    http_client: C,\n    endpoint: String,\n    schema_cache_by_id: Arc\u003cRwLock\u003cHashMap\u003ci32, ResolvedAvroSchema\u003e\u003e\u003e,\n}\n\nimpl CachedSchemaRegistry\u003cReqwestClient\u003e {\n    pub fn new(endpoint: \u0026str, username: Option\u003c\u0026str\u003e, password: Option\u003c\u0026str\u003e) -\u003e Self {\n        assert!(!endpoint.is_empty());\n        let auth = if let Some(username) = username {\n            assert!(!username.is_empty());\n            let auth = BasicAuth {\n                username: username.to_string(),\n                password: password.map(|p| p.to_owned()),\n            };\n            Some(auth)\n        } else {\n            None\n        };\n        let http_client = ReqwestClient::new(auth);\n        CachedSchemaRegistry::new_with_client(endpoint, http_client)\n    }\n}\n\nimpl\u003cC: HttpClient\u003e CachedSchemaRegistry\u003cC\u003e {\n    pub fn new_with_client(endpoint: \u0026str, http_client: C) -\u003e Self {\n        Self {\n            http_client,\n            endpoint: endpoint.into(),\n            schema_cache_by_id: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    pub async fn post_schema(\u0026self, subject_name: \u0026str, schema: \u0026str) -\u003e SchemaRegistryResult\u003c()\u003e {\n        #[derive(Serialize)]\n        struct PostRequest {\n            schema: String,\n        }\n        let url = Url::parse(\u0026self.endpoint)?.join(format!(\"/subjects/{}/versions\", subject_name).as_str())?;\n        let request = PostRequest { schema: schema.into() };\n        match AvroSchema::parse_str(schema) {\n            Ok(_) =\u003e Ok(self.http_client.post(url.as_str(), request).await?),\n            Err(err) =\u003e Err(SchemaRegistryError::SchemaParsing(format!(\"Invalid schema {}\", err))),\n        }\n    }\n\n    pub async fn list_subjects(\u0026self) -\u003e SchemaRegistryResult\u003cVec\u003cString\u003e\u003e {\n        let url = Url::parse(\u0026self.endpoint)?.join(\"subjects\")?;\n        let res = self.http_client.get(url.as_ref()).await?;\n        Ok(res)\n    }\n\n    pub async fn get_subject(\u0026self, subject_name: \u0026str) -\u003e SchemaRegistryResult\u003cSubject\u003e {\n        debug!(\"Get subject {}\", subject_name);\n        Ok(Subject {\n            subject: subject_name.into(),\n            versions: self.get_versions(subject_name).await?,\n            compatibility: self.get_compatibility_level(subject_name).await?,\n        })\n    }\n\n    pub async fn delete_subject(\u0026self, subject_name: \u0026str) -\u003e SchemaRegistryResult\u003c()\u003e {\n        debug!(\"Deleting subject {}\", subject_name);\n        let url = Url::parse(\u0026self.endpoint)?.join(format!(\"/subjects/{}\", subject_name).as_str())?;\n        Ok(self.http_client.delete(url.as_str()).await?)\n    }\n\n    pub async fn delete_version(\u0026self, subject_name: \u0026str, version: i32) -\u003e SchemaRegistryResult\u003c()\u003e {\n        debug!(\"Deleting subject {} version {}\", subject_name, version);\n        let url =\n            Url::parse(\u0026self.endpoint)?.join(format!(\"/subjects/{}/versions/{}\", subject_name, version).as_str())?;\n        Ok(self.http_client.delete(url.as_str()).await?)\n    }\n\n    pub async fn get_schema_by_id(\u0026self, id: i32) -\u003e SchemaRegistryResult\u003cResolvedAvroSchema\u003e {\n        trace!(\"Getting schema {} by id.\", id);\n        {\n            if let Some(cached) = self.schema_cache_by_id.read().await.get(\u0026id) {\n                trace!(\"Schema found in cache\");\n                return Ok(cached.clone());\n            }\n        }\n        {\n            trace!(\"Schema not found in cache, retrieving\");\n            let url = Url::parse(\u0026self.endpoint)?.join(format!(\"/schemas/ids/{}\", id).as_str())?;\n            let schema: GetSchemaByIdResult = self.http_client.get(url.as_str()).await?;\n            let schema = AvroSchema::parse_str(schema.schema.as_str()).map_err(|err| {\n                SchemaRegistryError::SchemaParsing(format!(\"Unable to parse the schema from schema registry\\n{}\", err))\n            })?;\n            let res = ResolvedAvroSchema::from(id, schema);\n            self.schema_cache_by_id.write().await.insert(id, res.clone());\n            Ok(res)\n        }\n    }\n\n    async fn get_compatibility_level(\u0026self, subject_name: \u0026str) -\u003e SchemaRegistryResult\u003cString\u003e {\n        #[derive(Deserialize)]\n        struct CompatibilityResponse {\n            #[serde(alias = \"compatibilityLevel\")]\n            compatibility_level: String,\n        }\n        let url = Url::parse(\u0026self.endpoint)?.join(format!(\"/config/{}?defaultToGlobal=true\", subject_name).as_str())?;\n        let response: CompatibilityResponse = self.http_client.get(url.as_ref()).await?;\n        Ok(response.compatibility_level)\n    }\n\n    async fn get_versions(\u0026self, subject_name: \u0026str) -\u003e SchemaRegistryResult\u003cVec\u003cSchema\u003e\u003e {\n        let url = Url::parse(\u0026self.endpoint)?.join(format!(\"/subjects/{}/versions/\", subject_name).as_str())?;\n        let versions: Vec\u003ci32\u003e = self.http_client.get(url.as_ref()).await?;\n        let mut schemas = Vec::\u003cSchema\u003e::new();\n        for v in versions {\n            let url = url.join(\u0026v.to_string())?;\n            let schema: Schema = self.http_client.get(url.as_ref()).await?;\n            schemas.push(schema);\n        }\n        Ok(schemas)\n    }\n\n    pub async fn get_last_schema(\u0026self, subject_name: \u0026str) -\u003e SchemaRegistryResult\u003cResolvedAvroSchema\u003e {\n        let schemas = self.get_versions(subject_name).await?;\n        let last = schemas.iter().max_by(|x, y| x.version.cmp(\u0026y.version));\n\n        if let Some(last) = last {\n            let schema = AvroSchema::parse_str(last.schema.as_str()).map_err(|err| {\n                SchemaRegistryError::SchemaParsing(format!(\"Unable to parse the schema from schema registry\\n{}\", err))\n            })?;\n            Ok(ResolvedAvroSchema::from(last.id, schema))\n        } else {\n            Err(SchemaRegistryError::SchemaNotFound(format!(\n                \"Schema {} not found\",\n                subject_name\n            )))\n        }\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":74},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","schema_registry","error.rs"],"content":"use super::http_client::HttpClientError;\n\n#[derive(Debug, PartialEq)]\npub enum SchemaRegistryError {\n    SchemaNotFound(String),\n    SchemaParsing(String),\n    HttpClient(String),\n    InvalidUrl(String),\n}\n\npub type SchemaRegistryResult\u003cT\u003e = core::result::Result\u003cT, SchemaRegistryError\u003e;\n\nimpl From\u003curl::ParseError\u003e for SchemaRegistryError {\n    fn from(url: url::ParseError) -\u003e Self {\n        Self::InvalidUrl(url.to_string())\n    }\n}\nimpl From\u003cHttpClientError\u003e for SchemaRegistryError {\n    fn from(err: HttpClientError) -\u003e Self {\n        SchemaRegistryError::HttpClient(format!(\"Http client error {:?}\", err))\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","schema_registry","http_client.rs"],"content":"use async_trait::async_trait;\nuse log::warn;\nuse reqwest::{\n    header::{HeaderMap, CONTENT_TYPE},\n    RequestBuilder,\n};\nuse serde::{de::DeserializeOwned, Serialize};\n\nuse super::BasicAuth;\n\n#[derive(Debug, PartialEq, Eq)]\npub enum HttpClientError {\n    Unknown(String),\n    Decode(String),\n    Code(u16),\n}\n\npub(super) type Result\u003cT\u003e = std::result::Result\u003cT, HttpClientError\u003e;\n\n#[async_trait]\npub trait HttpClient: Sync + Send {\n    async fn get\u003cT: 'static + DeserializeOwned\u003e(\u0026self, url: \u0026str) -\u003e Result\u003cT\u003e;\n    async fn delete(\u0026self, url: \u0026str) -\u003e Result\u003c()\u003e;\n    async fn post\u003cT: Serialize + Send + Sync\u003e(\u0026self, url: \u0026str, data: T) -\u003e Result\u003c()\u003e;\n}\n\npub struct ReqwestClient {\n    client: reqwest::Client,\n    timeout_seconds: u64,\n    auth: Option\u003cBasicAuth\u003e,\n}\n\n#[async_trait]\nimpl HttpClient for ReqwestClient {\n    async fn post\u003cT: Serialize + Send + Sync\u003e(\u0026self, url: \u0026str, data: T) -\u003e Result\u003c()\u003e {\n        let request = self\n            .client\n            .post(url.to_string())\n            .body(serde_json::to_string(\u0026data).unwrap())\n            .headers({\n                let mut h = HeaderMap::new();\n                h.insert(CONTENT_TYPE, \"application/json\".parse().unwrap());\n                h\n            });\n        let response = self.send_request(request).await?;\n        if response.status().is_success() {\n            Ok(())\n        } else {\n            let error_code = response.status().as_u16();\n            let text = response.text().await.unwrap();\n            warn!(\"Unable to create a schema {:?}\", text);\n            Err(HttpClientError::Code(error_code))\n        }\n    }\n    async fn get\u003cT: 'static + DeserializeOwned\u003e(\u0026self, url: \u0026str) -\u003e Result\u003cT\u003e {\n        let request = self.client.get(url.to_string());\n        let response = self.send_request(request).await?;\n        if response.status().is_success() {\n            let res = response.json().await?;\n            Ok(res)\n        } else {\n            Err(HttpClientError::Code(response.status().as_u16()))\n        }\n    }\n\n    async fn delete(\u0026self, url: \u0026str) -\u003e Result\u003c()\u003e {\n        let request = self.client.delete(url.to_string());\n        let response = self.send_request(request).await?;\n        if response.status().is_success() {\n            Ok(())\n        } else {\n            Err(HttpClientError::Code(response.status().as_u16()))\n        }\n    }\n}\n\nimpl ReqwestClient {\n    pub fn new(auth: Option\u003cBasicAuth\u003e) -\u003e Self {\n        Self {\n            client: Default::default(),\n            timeout_seconds: 10,\n            auth,\n        }\n    }\n\n    async fn send_request(\u0026self, mut request: RequestBuilder) -\u003e Result\u003creqwest::Response\u003e {\n        request = request.timeout(core::time::Duration::from_secs(self.timeout_seconds));\n        if let Some(auth) = \u0026self.auth {\n            request = request.basic_auth(auth.username.to_owned(), auth.password.to_owned());\n        }\n        Ok(request.send().await?)\n    }\n}\n\nimpl From\u003creqwest::Error\u003e for HttpClientError {\n    fn from(err: reqwest::Error) -\u003e Self {\n        if let Some(error_code) = err.status() {\n            HttpClientError::Code(error_code.as_u16())\n        } else if err.is_decode() {\n            HttpClientError::Decode(err.to_string())\n        } else {\n            HttpClientError::Unknown(err.to_string())\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use httpmock::{\n        Method::{GET, POST},\n        MockServer,\n    };\n    use serde::Deserialize;\n\n    use crate::lib::schema_registry::http_client::HttpClientError;\n\n    use super::{HttpClient, ReqwestClient};\n\n    #[tokio::test]\n    async fn test_post_request() {\n        let server = MockServer::start();\n        let sut = ReqwestClient::new(None);\n        // return Ok when the request is successful\n        {\n            let server_mock = server.mock(|when, then| {\n                when.method(POST).path(\"/happy_path\");\n                then.status(200);\n            });\n            let res = sut.post(server.url(\"/happy_path\").as_str(), \u0026\"{}\").await;\n            assert!(res.is_ok(), \"Received {:?}\", res);\n            server_mock.assert();\n        }\n        // return the error code if any\n        {\n            let server_mock = server.mock(|when, then| {\n                when.method(POST).path(\"/not_found\");\n                then.status(404);\n            });\n            let res = sut.post(server.url(\"/not_found\").as_str(), \u0026\"{}\").await;\n            assert_eq!(res.err().unwrap(), HttpClientError::Code(404));\n            server_mock.assert();\n        }\n    }\n\n    #[tokio::test]\n    async fn test_get_request() {\n        let server = MockServer::start();\n        let sut = ReqwestClient::new(None);\n        #[derive(Deserialize, Debug)]\n        struct MockResponse {\n            id: String,\n        }\n        // return Ok when the request is successful\n        {\n            let server_mock = server.mock(|when, then| {\n                when.method(GET).path(\"/happy_path\");\n                then.status(200)\n                    .header(\"content-type\", \"text/json\")\n                    .body(\"{\\\"id\\\":\\\"123\\\"}\");\n            });\n            let res = sut.get::\u003cMockResponse\u003e(server.url(\"/happy_path\").as_str()).await;\n            assert!(res.is_ok());\n            assert_eq!(res.unwrap().id, \"123\");\n            server_mock.assert();\n        }\n        // return deserialization error if an unexpected body is received\n        {\n            let server_mock = server.mock(|when, then| {\n                when.method(GET).path(\"/invalid_response\");\n                then.status(200)\n                    .header(\"content-type\", \"text/json\")\n                    .body(\"{\\\"unknown_field\\\":\\\"123\\\"}\");\n            });\n            let res = sut.get::\u003cMockResponse\u003e(server.url(\"/invalid_response\").as_str()).await;\n            assert!(res.is_err());\n            assert!(matches!(res.err().unwrap(), HttpClientError::Decode(..)));\n            server_mock.assert();\n        }\n        // return the error code if any\n        {\n            let server_mock = server.mock(|when, then| {\n                when.method(GET).path(\"/not_found\");\n                then.status(404);\n            });\n            let res = sut.get::\u003cMockResponse\u003e(server.url(\"/not_found\").as_str()).await;\n            assert_eq!(res.err().unwrap(), HttpClientError::Code(404));\n            server_mock.assert();\n        }\n    }\n}\n","traces":[{"line":35,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":32,"coverable":41},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","schema_registry","mod.rs"],"content":"mod client;\nmod error;\nmod http_client;\nmod resolved_avro_schema;\nmod types;\n\npub use client::CachedSchemaRegistry;\npub use error::SchemaRegistryError;\npub use types::{BasicAuth, ResolvedAvroSchema, Schema, Subject};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","schema_registry","resolved_avro_schema.rs"],"content":"use std::collections::HashMap;\n\nuse apache_avro::{schema::Name, Schema};\n\nuse super::types::ResolvedAvroSchema;\n\nimpl ResolvedAvroSchema {\n    pub fn from(schema_id: i32, schema: Schema) -\u003e Self {\n        let refs = extract_all_refs(\u0026schema);\n        Self {\n            schema_id,\n            schema,\n            resolved_schemas: refs,\n        }\n    }\n}\n\nfn extract_all_refs(s: \u0026Schema) -\u003e HashMap\u003cName, Schema\u003e {\n    // set the namespace of the parent if it's not specified\n    fn ns_name(name: \u0026Name, parent_ns: \u0026Option\u003cString\u003e) -\u003e Name {\n        Name {\n            namespace: name.namespace.clone().or_else(|| parent_ns.to_owned()),\n            name: name.name.clone(),\n        }\n    }\n    fn _extract(s: \u0026Schema, parent_ns: \u0026Option\u003cString\u003e, cache: \u0026mut HashMap\u003cName, Schema\u003e) {\n        match s {\n            Schema::Array(s) =\u003e _extract(s, parent_ns, cache),\n            Schema::Map(s) =\u003e _extract(s, parent_ns, cache),\n            Schema::Union(s) =\u003e s.variants().iter().for_each(|s| _extract(s, parent_ns, cache)),\n            Schema::Record { name, fields, .. } =\u003e {\n                let parent = name.namespace.clone().or_else(|| parent_ns.to_owned());\n                fields.iter().for_each(|f| _extract(\u0026f.schema, \u0026parent, cache));\n                cache.insert(ns_name(name, parent_ns), s.clone());\n            }\n            Schema::Enum { name, .. } =\u003e {\n                cache.insert(ns_name(name, parent_ns), s.clone());\n            }\n            Schema::Fixed { name, .. } =\u003e {\n                cache.insert(ns_name(name, parent_ns), s.clone());\n            }\n            _ =\u003e (),\n        }\n    }\n    let mut cache = HashMap::new();\n    _extract(s, \u0026None, \u0026mut cache);\n    cache\n}\n\n#[cfg(test)]\nmod tests {\n    use std::{collections::HashSet, fs};\n\n    use apache_avro::{schema::Name, Schema};\n\n    use super::extract_all_refs;\n\n    #[test]\n    fn test_extract_all_refs_different_ns() {\n        let test_schema = fs::read_to_string(\"src/lib/schema_registry/avro_test_files/ref_to_another_ns.json\").unwrap();\n        let schema = Schema::parse_str(\u0026test_schema).unwrap();\n        let res = extract_all_refs(\u0026schema);\n        // assert\n        let names: HashSet\u003c_\u003e = res.keys().map(|n| n.to_owned()).collect();\n        assert!(names.contains(\u0026name(\"testTarget\", Some(\"nested.ns\"))));\n    }\n\n    #[test]\n    fn test_extract_all_refs() {\n        let test_schema = fs::read_to_string(\"src/lib/schema_registry/avro_test_files/schema.json\").unwrap();\n        let schema = Schema::parse_str(\u0026test_schema).unwrap();\n        let res = extract_all_refs(\u0026schema);\n        // assert\n        let names: HashSet\u003c_\u003e = res.keys().map(|n| n.to_owned()).collect();\n        assert_eq!(\n            names,\n            HashSet::from_iter(vec![\n                name(\"userInfo1\", Some(\"my.example\")),\n                name(\"userInfo2\", Some(\"my.example\")),\n                name(\"userInfo3\", Some(\"my.nested\")),\n                name(\"userInfo4\", Some(\"my.nested\")),\n                name(\"Suit\", Some(\"my.nested\")),\n                name(\"userInfo5\", Some(\"my.example\")),\n                name(\"userInfo6\", Some(\"my.example\")),\n                name(\"Suit\", Some(\"my.example\"))\n            ])\n        );\n    }\n\n    fn name(n: \u0026str, ns: Option\u003c\u0026str\u003e) -\u003e Name {\n        Name {\n            name: n.into(),\n            namespace: ns.map(|s| s.to_string()),\n        }\n    }\n}\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":39},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":39},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":24,"coverable":24},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","schema_registry","types.rs"],"content":"use std::collections::HashMap;\n\nuse apache_avro::schema::{Name, Schema as AvroSchema};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Deserialize, Serialize, Clone)]\npub struct Subject {\n    pub subject: String,\n    pub compatibility: String,\n    pub versions: Vec\u003cSchema\u003e,\n}\n\n#[derive(Debug, Deserialize, Serialize, Clone)]\npub struct Schema {\n    pub id: i32,\n    pub version: i32,\n    pub schema: String,\n}\n\n#[derive(Clone)]\npub struct BasicAuth {\n    pub username: String,\n    pub password: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Clone)]\npub struct ResolvedAvroSchema {\n    pub schema_id: i32,\n    pub schema: AvroSchema,\n    pub resolved_schemas: HashMap\u003cName, AvroSchema\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","types.rs"],"content":"use std::time::{Duration, UNIX_EPOCH};\n\nuse serde::{Deserialize, Serialize};\nuse time::format_description::well_known;\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]\npub struct KafkaRecord\u003cT\u003e {\n    pub payload: Option\u003cT\u003e,\n    pub key: Option\u003cT\u003e,\n    pub topic: String,\n    /**\n    Unix timestamp in ms\n    */\n    pub timestamp: Option\u003cu64\u003e,\n    pub partition: i32,\n    pub offset: i64,\n    //todo: headers\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]\npub enum ParserMode {\n    String,\n    Avro,\n}\n\npub type RawKafkaRecord = KafkaRecord\u003cVec\u003cu8\u003e\u003e;\npub type ParsedKafkaRecord = KafkaRecord\u003cString\u003e;\n\nimpl ParsedKafkaRecord {\n    pub fn to_csv_line(\u0026self, parse_timestamp: bool) -\u003e String {\n        let unix_timestamp = self.timestamp.unwrap_or_default();\n        let timestamp = if parse_timestamp {\n            // Creates a new SystemTime from the specified number of whole seconds\n            let d = UNIX_EPOCH + Duration::from_millis(unix_timestamp);\n            // Create DateTime from SystemTime\n            time::OffsetDateTime::from(d).format(\u0026well_known::Rfc3339).unwrap()\n        } else {\n            unix_timestamp.to_string()\n        };\n        format!(\n            \"{};{};{};{};{}\",\n            timestamp,\n            self.partition,\n            self.offset,\n            self.key.clone().unwrap_or_default(),\n            self.payload.clone().unwrap_or_default()\n        )\n    }\n}\n\nimpl ParsedKafkaRecord {\n    pub(crate) fn to_string_header() -\u003e String {\n        format!(\"{};{};{};{};{}\", \"timestamp\", \"partition\", \"offset\", \"key\", \"payload\")\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":5},"fn_name":null}],"covered":12,"coverable":15},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","main.rs"],"content":"#![cfg_attr(all(not(debug_assertions), target_os = \"windows\"), windows_subsystem = \"windows\")]\nextern crate log;\n\n#[cfg(feature = \"integration_tests\")]\nmod integration_tests;\n\nmod api;\nmod lib;\nmod telemetry;\n\nuse crate::api::{\n    admin::{\n        create_topic, delete_consumer_group, delete_topic, describe_consumer_group, get_consumer_group_state,\n        get_last_offsets, get_topic_info, list_consumer_groups, list_topics, set_consumer_group,\n    },\n    configuration::{get_configuration, write_configuration},\n    consumer::{export_records, get_consumer_state, get_records_page, start_consumer, stop_consumer},\n    producer::produce_record,\n    schema_registry::{delete_subject, delete_subject_version, get_subject, list_subjects, post_schema},\n    utils::{export_datastore, parse_keystore, parse_truststore},\n};\nuse api::AppState;\nuse tauri::Manager;\nuse telemetry::log_active_user;\n\nfn main() {\n    env_logger::init();\n    log_active_user();\n    tauri::Builder::default()\n        .invoke_handler(tauri::generate_handler![\n            // utils\n            export_datastore,\n            parse_keystore,\n            parse_truststore,\n            // producer\n            produce_record,\n            // consumer\n            start_consumer,\n            stop_consumer,\n            get_consumer_state,\n            get_records_page,\n            export_records,\n            // schema\n            list_subjects,\n            get_subject,\n            delete_subject,\n            delete_subject_version,\n            post_schema,\n            // config\n            get_configuration,\n            write_configuration,\n            // admin topics\n            list_topics,\n            get_topic_info,\n            create_topic,\n            delete_topic,\n            get_last_offsets,\n            // admin consumer groups\n            get_consumer_group_state,\n            list_consumer_groups,\n            describe_consumer_group,\n            set_consumer_group,\n            delete_consumer_group,\n        ])\n        .setup(|app| {\n            app.manage(AppState::new(app.app_handle()));\n            Ok(())\n        })\n        .run(tauri::generate_context!())\n        .expect(\"error while running tauri application\");\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":42},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","telemetry.rs"],"content":"use std::time::{SystemTime, UNIX_EPOCH};\n\nuse log::debug;\nuse serde::Serialize;\n#[derive(Serialize, Debug)]\nstruct GraphiteMetric {\n    // Graphite style name (required)\n    name: String,\n    // the resolution of the metric in seconds (required)\n    interval: u32,\n    // float64 value (required)\n    value: i32,\n    // unix timestamp in seconds (required)\n    time: u64,\n    // list of key=value pairs of tags (optional)\n    tags: Vec\u003cString\u003e,\n}\n\npub fn log_active_user() {\n    let url = \"https://graphite-prod-01-eu-west-0.grafana.net/graphite/metrics\";\n    if let Some(token) = std::option_env!(\"GRAPHITE_TOKEN\") {\n        debug!(\"Telemetry log active user\");\n        let metrics = vec![GraphiteMetric {\n            name: \"insulator2.active_user\".into(),\n            interval: 1,\n            value: 1,\n            time: SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs(),\n            tags: vec![get_locale_tag(), get_os_tag()],\n        }];\n        let client = reqwest::blocking::Client::new();\n        let res = client.post(url).bearer_auth(token).json(\u0026metrics).send();\n        debug!(\"Telemetry send result: {:?}\", res);\n    }\n}\n\nfn get_locale_tag() -\u003e String {\n    use sys_locale::get_locale;\n    format!(\"locale={}\", get_locale().unwrap_or_else(|| String::from(\"unknown\")))\n}\n\nfn get_os_tag() -\u003e String {\n    format!(\"os={}\", std::env::consts::OS)\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":17}]};
        var previousData = {"files":[{"path":["/","Users","andrewinci","Development","insulator2","backend","build.rs"],"content":"fn main() {\n    tauri_build::build()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","api","admin.rs"],"content":"use std::collections::HashMap;\n\nuse log::debug;\n\nuse crate::lib::{\n    admin::{ConsumerGroupInfo, PartitionOffset, Topic, TopicInfo},\n    consumer::types::ConsumerSessionConfiguration,\n};\n\nuse super::{error::ApiResult, AppState};\n\n#[tauri::command]\npub async fn list_topics(cluster_id: \u0026str, state: tauri::State\u003c'_, AppState\u003e) -\u003e ApiResult\u003cVec\u003cTopic\u003e\u003e {\n    debug!(\"Retrieve the list of topics\");\n    let cluster = state.get_cluster(cluster_id).await?;\n    Ok(cluster.kafka_admin_client.list_topics().await?)\n}\n\n#[tauri::command]\npub async fn get_topic_info(\n    cluster_id: \u0026str,\n    topic_name: \u0026str,\n    state: tauri::State\u003c'_, AppState\u003e,\n) -\u003e ApiResult\u003cTopicInfo\u003e {\n    debug!(\"Retrieve topic info for {}\", topic_name);\n    let cluster = state.get_cluster(cluster_id).await?;\n    Ok(cluster.kafka_admin_client.get_topic_info(topic_name).await?)\n}\n\n#[tauri::command]\npub async fn delete_topic(cluster_id: \u0026str, topic_name: \u0026str, state: tauri::State\u003c'_, AppState\u003e) -\u003e ApiResult\u003c()\u003e {\n    debug!(\"Deleting topic {}\", topic_name);\n    let cluster = state.get_cluster(cluster_id).await?;\n    Ok(cluster.kafka_admin_client.delete_topic(topic_name).await?)\n}\n\n#[tauri::command]\npub async fn create_topic(\n    cluster_id: \u0026str,\n    topic_name: \u0026str,\n    partitions: i32,\n    isr: i32,\n    compacted: bool,\n    state: tauri::State\u003c'_, AppState\u003e,\n) -\u003e ApiResult\u003c()\u003e {\n    debug!(\"Create new topic\");\n    let cluster = state.get_cluster(cluster_id).await?;\n    Ok(cluster\n        .kafka_admin_client\n        .create_topic(topic_name, partitions, isr, compacted)\n        .await?)\n}\n\n#[tauri::command]\npub async fn list_consumer_groups(cluster_id: \u0026str, state: tauri::State\u003c'_, AppState\u003e) -\u003e ApiResult\u003cVec\u003cString\u003e\u003e {\n    debug!(\"Retrieve the list of consumer groups\");\n    let cluster = state.get_cluster(cluster_id).await?;\n    Ok(cluster.kafka_admin_client.list_consumer_groups()?)\n}\n\n#[tauri::command]\npub async fn describe_consumer_group(\n    cluster_id: \u0026str,\n    consumer_group_name: \u0026str,\n    ignore_cache: Option\u003cbool\u003e,\n    state: tauri::State\u003c'_, AppState\u003e,\n) -\u003e ApiResult\u003cConsumerGroupInfo\u003e {\n    debug!(\"Describe consumer group\");\n    let cluster = state.get_cluster(cluster_id).await?;\n    Ok(cluster\n        .kafka_admin_client\n        .describe_consumer_group(consumer_group_name, ignore_cache.unwrap_or(false))\n        .await?)\n}\n\n#[tauri::command]\npub async fn get_consumer_group_state(\n    cluster_id: \u0026str,\n    consumer_group_name: \u0026str,\n    state: tauri::State\u003c'_, AppState\u003e,\n) -\u003e ApiResult\u003cString\u003e {\n    debug!(\"Get consumer group\");\n    let cluster = state.get_cluster(cluster_id).await?;\n    Ok(cluster\n        .kafka_admin_client\n        .get_consumer_group_state(consumer_group_name)?)\n}\n\n#[tauri::command]\npub async fn set_consumer_group(\n    cluster_id: \u0026str,\n    consumer_group_name: \u0026str,\n    topics: Vec\u003c\u0026str\u003e,\n    offset_config: ConsumerSessionConfiguration,\n    state: tauri::State\u003c'_, AppState\u003e,\n) -\u003e ApiResult\u003c()\u003e {\n    debug!(\"Create consumer group {}\", consumer_group_name);\n    let cluster = state.get_cluster(cluster_id).await?;\n    Ok(cluster\n        .kafka_admin_client\n        .set_consumer_group(consumer_group_name, \u0026topics, \u0026offset_config)?)\n}\n\n#[tauri::command]\npub async fn get_last_offsets(\n    cluster_id: \u0026str,\n    topic_names: Vec\u003c\u0026str\u003e,\n    state: tauri::State\u003c'_, AppState\u003e,\n) -\u003e ApiResult\u003cHashMap\u003cString, Vec\u003cPartitionOffset\u003e\u003e\u003e {\n    debug!(\"Get last offset for topics {:?}\", topic_names);\n    let cluster = state.get_cluster(cluster_id).await?;\n    Ok(cluster.kafka_admin_client.get_last_offsets(\u0026topic_names).await?)\n}\n\n#[tauri::command]\npub async fn delete_consumer_group(\n    cluster_id: \u0026str,\n    consumer_group_name: \u0026str,\n    state: tauri::State\u003c'_, AppState\u003e,\n) -\u003e ApiResult\u003c()\u003e {\n    debug!(\"Deleting consumer group {}\", consumer_group_name);\n    let cluster = state.get_cluster(cluster_id).await?;\n    Ok(cluster\n        .kafka_admin_client\n        .delete_consumer_group(consumer_group_name)\n        .await?)\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":53},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","api","cluster.rs"],"content":"use log::{debug, trace};\nuse std::{collections::HashMap, sync::Arc};\nuse tokio::sync::RwLock;\n\nuse crate::lib::{\n    admin::KafkaAdmin,\n    configuration::InsulatorConfig,\n    consumer::{ConsumerError, KafkaConsumer},\n    error_callback::ErrorCallback,\n    parser::Parser,\n    producer::KafkaProducer,\n    record_store::SqliteStore,\n    record_store::TopicStore,\n    schema_registry::CachedSchemaRegistry,\n};\n\nuse super::error::{ApiError, ApiResult};\n\ntype TopicName = String;\n\npub struct Cluster {\n    pub cluster_id: String,\n    pub config: InsulatorConfig,\n    pub schema_registry_client: Option\u003cArc\u003cCachedSchemaRegistry\u003e\u003e,\n    pub kafka_admin_client: Arc\u003cKafkaAdmin\u003e,\n    pub kafka_producer: Arc\u003cKafkaProducer\u003e,\n    pub parser: Arc\u003cParser\u003e,\n    pub store: Arc\u003cSqliteStore\u003e,\n    active_kafka_consumers: Arc\u003cRwLock\u003cHashMap\u003cTopicName, Arc\u003cKafkaConsumer\u003e\u003e\u003e\u003e,\n    error_callback: ErrorCallback\u003cApiError\u003e,\n}\n\nimpl Cluster {\n    pub fn new(cluster_id: \u0026str, config: \u0026InsulatorConfig, error_callback: ErrorCallback\u003cApiError\u003e) -\u003e ApiResult\u003cSelf\u003e {\n        let cluster_config = config.get_cluster_config(cluster_id)?;\n        let (schema_registry_client, parser) = {\n            if let Some(s_config) = \u0026cluster_config.schema_registry {\n                let ptr = Arc::new(CachedSchemaRegistry::new(\n                    s_config.endpoint.as_str(),\n                    s_config.username.as_deref(),\n                    s_config.password.as_deref(),\n                ));\n                (Some(ptr.clone()), Arc::new(Parser::new(Some(ptr))))\n            } else {\n                (None, Arc::new(Parser::new(None)))\n            }\n        };\n        Ok(Cluster {\n            cluster_id: cluster_id.to_string(),\n            schema_registry_client,\n            active_kafka_consumers: Arc::new(RwLock::new(HashMap::new())),\n            kafka_admin_client: Arc::new(KafkaAdmin::new(\u0026cluster_config, config.get_kafka_tmo())?),\n            kafka_producer: Arc::new(KafkaProducer::new(\u0026cluster_config, parser.clone())),\n            parser,\n            store: Arc::new(SqliteStore::new(config.get_sql_tmo())),\n            error_callback,\n            config: config.clone(),\n        })\n    }\n\n    pub async fn get_consumer(\u0026self, topic_name: \u0026str) -\u003e Arc\u003cKafkaConsumer\u003e {\n        {\n            if let Some(consumer) = self.active_kafka_consumers.read().await.get(topic_name) {\n                trace!(\"Consumer for {} found in cache\", topic_name);\n                return consumer.clone();\n            }\n        }\n        {\n            debug!(\"Create consumer for topic {}\", topic_name);\n            let cluster_config = self\n                .config\n                .get_cluster_config(\u0026self.cluster_id)\n                .expect(\"Cluster id not found\"); //todo: bubble up the error\n\n            // create a new table for the consumer\n            let topic_store =\n                TopicStore::from_record_store(self.store.clone(), self.parser.clone(), \u0026self.cluster_id, topic_name);\n            // build the consumer callback\n            let error_cb = self.error_callback.clone();\n            let consumer_callback: ErrorCallback\u003cConsumerError\u003e = Arc::new(move |err| (*error_cb)(err.into()));\n            let consumer = Arc::new(KafkaConsumer::new(\n                \u0026cluster_config,\n                topic_name,\n                topic_store,\n                consumer_callback,\n                self.config.get_kafka_tmo(),\n            ));\n            self.active_kafka_consumers\n                .write()\n                .await\n                .insert(topic_name.to_string(), consumer.clone());\n            consumer\n        }\n    }\n\n    pub async fn get_topic_store(\u0026self, topic_name: \u0026str) -\u003e Arc\u003cTopicStore\u003e {\n        let consumer = self.get_consumer(topic_name).await;\n        consumer.topic_store.clone()\n    }\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":46},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","api","configuration.rs"],"content":"use log::debug;\n\nuse crate::lib::configuration::InsulatorConfig;\n\nuse super::{error::ApiResult, AppState};\n\n#[tauri::command]\npub fn get_configuration(state: tauri::State\u003c'_, AppState\u003e) -\u003e ApiResult\u003cInsulatorConfig\u003e {\n    debug!(\"Retrieve configuration\");\n    Ok(state.configuration_provider.get_configuration()?)\n}\n\n#[tauri::command]\npub fn write_configuration(\n    configuration: InsulatorConfig,\n    state: tauri::State\u003c'_, AppState\u003e,\n) -\u003e ApiResult\u003cInsulatorConfig\u003e {\n    debug!(\"Write configuration\");\n    Ok(state\n        .configuration_provider\n        .write_configuration(\u0026configuration)\n        .map(|_| configuration)?)\n}\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":9},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","api","consumer.rs"],"content":"use log::debug;\n\nuse crate::lib::{\n    consumer::{types::ConsumerState, ConsumerConfiguration},\n    record_store::types::ExportOptions,\n};\n\nuse super::{error::ApiResult, types::GetPageResponse, AppState};\n\n#[tauri::command]\npub async fn start_consumer(\n    cluster_id: \u0026str,\n    topic: \u0026str,\n    config: ConsumerConfiguration,\n    state: tauri::State\u003c'_, AppState\u003e,\n) -\u003e ApiResult\u003c()\u003e {\n    let consumer = state.get_cluster(cluster_id).await?.get_consumer(topic).await;\n    Ok(consumer.start(\u0026config).await?)\n}\n\n#[tauri::command]\npub async fn get_consumer_state(\n    cluster_id: \u0026str,\n    topic: \u0026str,\n    state: tauri::State\u003c'_, AppState\u003e,\n) -\u003e ApiResult\u003cConsumerState\u003e {\n    let consumer = state.get_cluster(cluster_id).await?.get_consumer(topic).await;\n    Ok(consumer.get_consumer_state().await?)\n}\n\n#[tauri::command]\npub async fn stop_consumer(cluster_id: \u0026str, topic: \u0026str, state: tauri::State\u003c'_, AppState\u003e) -\u003e ApiResult\u003c()\u003e {\n    let consumer = state.get_cluster(cluster_id).await?.get_consumer(topic).await;\n    Ok(consumer.stop().await?)\n}\n\n#[tauri::command]\npub async fn get_records_page(\n    cluster_id: \u0026str,\n    topic: \u0026str,\n    page_number: usize,\n    query: Option\u003c\u0026str\u003e,\n    state: tauri::State\u003c'_, AppState\u003e,\n) -\u003e ApiResult\u003cGetPageResponse\u003e {\n    debug!(\"Get records page\");\n    const PAGE_SIZE: usize = 20;\n    let cluster = state.get_cluster(cluster_id).await?;\n    let topic_store = cluster.get_topic_store(topic).await;\n    let records = topic_store.get_records(query, (page_number * PAGE_SIZE) as i64, PAGE_SIZE as i64, None)?;\n    let records_count = records.len();\n    Ok(GetPageResponse {\n        records,\n        next_page: if records_count == PAGE_SIZE {\n            Some(page_number + 1)\n        } else {\n            None\n        },\n        prev_page: if page_number \u003e= 1 { Some(page_number - 1) } else { None },\n    })\n}\n\n#[tauri::command]\npub async fn export_records(\n    cluster_id: \u0026str,\n    topic: \u0026str,\n    options: ExportOptions,\n    state: tauri::State\u003c'_, AppState\u003e,\n) -\u003e ApiResult\u003c()\u003e {\n    let store = state.get_cluster(cluster_id).await?.get_topic_store(topic).await;\n    Ok(store.export_records(\u0026options)?)\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":24},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","api","error.rs"],"content":"use crate::lib::{\n    admin::AdminError, avro::AvroError, configuration::ConfigError, consumer::ConsumerError, producer::ProducerError,\n    record_store::StoreError, schema_registry::SchemaRegistryError,\n};\nuse serde::{Deserialize, Serialize};\n\npub type ApiResult\u003cT\u003e = std::result::Result\u003cT, ApiError\u003e;\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct ApiError {\n    #[serde(rename = \"errorType\")]\n    pub error_type: String,\n    pub message: String,\n}\n\nimpl From\u003cSchemaRegistryError\u003e for ApiError {\n    fn from(err: SchemaRegistryError) -\u003e Self {\n        match err {\n            SchemaRegistryError::SchemaNotFound(message) =\u003e ApiError {\n                error_type: \"Schema registry error: Schema not found\".into(),\n                message,\n            },\n            SchemaRegistryError::SchemaParsing(message) =\u003e ApiError {\n                error_type: \"Schema registry error: Unable to parse the schema\".into(),\n                message,\n            },\n            SchemaRegistryError::HttpClient(message) =\u003e ApiError {\n                error_type: \"Schema registry error: HTTPClient\".into(),\n                message,\n            },\n            SchemaRegistryError::InvalidUrl(message) =\u003e ApiError {\n                error_type: \"Schema registry error: Invalid URL\".into(),\n                message,\n            },\n        }\n    }\n}\n\nimpl From\u003cStoreError\u003e for ApiError {\n    fn from(value: StoreError) -\u003e Self {\n        match value {\n            StoreError::SqlError(message) =\u003e ApiError {\n                error_type: \"Records store error: SQL\".into(),\n                message,\n            },\n            StoreError::IO(message) =\u003e ApiError {\n                error_type: \"Records store error: IO\".into(),\n                message,\n            },\n            StoreError::RecordParse(message) =\u003e ApiError {\n                error_type: \"Records store error: Parsing the record\".into(),\n                message,\n            },\n        }\n    }\n}\n\nimpl From\u003cConsumerError\u003e for ApiError {\n    fn from(value: ConsumerError) -\u003e Self {\n        match value {\n            ConsumerError::RDKafka(message) =\u003e ApiError {\n                error_type: \"Consumer error: RDKafkaLib\".into(),\n                message,\n            },\n            ConsumerError::RecordStore(_, records_store_error) =\u003e records_store_error.into(),\n            ConsumerError::AlreadyRunning(message) =\u003e ApiError {\n                error_type: \"Consumer error\".into(),\n                message,\n            },\n        }\n    }\n}\n\nimpl From\u003cAdminError\u003e for ApiError {\n    fn from(value: AdminError) -\u003e Self {\n        match value {\n            AdminError::TopicNotFound(topic_name) =\u003e ApiError {\n                error_type: \"Admin client\".into(),\n                message: format!(\"Topic {} not found.\", topic_name),\n            },\n            AdminError::RDKafka(message) =\u003e ApiError {\n                error_type: \"RDKafkaLib error\".into(),\n                message,\n            },\n            AdminError::ConsumerError(consumer_error) =\u003e consumer_error.into(),\n        }\n    }\n}\n\nimpl From\u003cConfigError\u003e for ApiError {\n    fn from(value: ConfigError) -\u003e Self {\n        match value {\n            ConfigError::IO(msg) =\u003e ApiError {\n                error_type: \"IO error handling user configurations\".into(),\n                message: msg,\n            },\n            ConfigError::JSONSerde(msg) =\u003e ApiError {\n                error_type: \"JSON error handling user configurations\".into(),\n                message: msg,\n            },\n            ConfigError::TOMLSerde(msg) =\u003e ApiError {\n                error_type: \"TOML error handling user configurations\".into(),\n                message: msg,\n            },\n            ConfigError::LegacyConfiguration(msg) =\u003e ApiError {\n                error_type: \"Error loading the legacy configuration\".into(),\n                message: msg,\n            },\n            ConfigError::ClusterNotFound(cluster_id) =\u003e ApiError {\n                error_type: \"User configuration error\".into(),\n                message: format!(\"Cluster {} not found\", cluster_id),\n            },\n        }\n    }\n}\n\nimpl From\u003cProducerError\u003e for ApiError {\n    fn from(value: ProducerError) -\u003e Self {\n        match value {\n            ProducerError::MissingAvroConfiguration =\u003e Self {\n                error_type: \"Missing avro configuration\".into(),\n                message: \"Unable to parse the record to avro\".into(),\n            },\n            ProducerError::RDKafka(message) =\u003e ApiError {\n                error_type: \"RDKafkaLib error trying to produce\".into(),\n                message,\n            },\n            ProducerError::AvroParse(avro_error) =\u003e avro_error.into(),\n        }\n    }\n}\n\nimpl From\u003cAvroError\u003e for ApiError {\n    fn from(value: AvroError) -\u003e Self {\n        match value {\n            AvroError::InvalidNumber(message) =\u003e ApiError {\n                error_type: \"Avro error: InvalidNumber\".into(),\n                message,\n            },\n            AvroError::MissingAvroSchemaReference(message) =\u003e ApiError {\n                error_type: \"Avro error: MissingAvroSchemaReference\".into(),\n                message,\n            },\n            AvroError::MissingField(message) =\u003e ApiError {\n                error_type: \"Avro error: MissingField\".into(),\n                message,\n            },\n            AvroError::SchemaProvider(message, _) =\u003e ApiError {\n                error_type: \"Avro error: SchemaProvider\".into(),\n                message,\n            },\n            AvroError::InvalidUnion(message) =\u003e ApiError {\n                error_type: \"Avro error: InvalidUnion\".into(),\n                message,\n            },\n            AvroError::Unsupported(message) =\u003e ApiError {\n                error_type: \"Avro error: Unsupported\".into(),\n                message,\n            },\n            AvroError::InvalidAvroHeader(message) =\u003e ApiError {\n                error_type: \"Avro error: InvalidAvroHeader\".into(),\n                message,\n            },\n            AvroError::ParseAvroValue(message) =\u003e ApiError {\n                error_type: \"Avro error: ParseAvroValue\".into(),\n                message,\n            },\n            AvroError::ParseJsonValue(message) =\u003e ApiError {\n                error_type: \"Avro error: ParseJsonValue\".into(),\n                message,\n            },\n            AvroError::InvalidEnum(message) =\u003e ApiError {\n                error_type: \"Avro error: InvalidEnum\".into(),\n                message,\n            },\n        }\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":48},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","api","mod.rs"],"content":"pub mod admin;\nmod cluster;\npub mod configuration;\npub mod consumer;\nmod error;\nmod notification;\npub mod producer;\npub mod schema_registry;\nmod state;\nmod types;\npub mod utils;\npub use state::AppState;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","api","notification.rs"],"content":"use tauri::{AppHandle, Manager};\n\nuse super::error::ApiError;\n\npub fn _notify_error(error_type: \u0026str, message: \u0026str, app: \u0026AppHandle) {\n    app.app_handle()\n        .emit_all(\n            \"error\",\n            ApiError {\n                error_type: error_type.to_string(),\n                message: message.to_string(),\n            },\n        )\n        .expect(\"unable to send a notification to the frontend\");\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":5},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","api","producer.rs"],"content":"use crate::lib::types::ParserMode;\n\nuse super::{error::ApiResult, AppState};\n\n#[tauri::command]\npub async fn produce_record(\n    cluster_id: \u0026str,\n    topic: \u0026str,\n    key: \u0026str,\n    value: Option\u003c\u0026str\u003e, // None would be a tombstone\n    mode: ParserMode,\n    state: tauri::State\u003c'_, AppState\u003e,\n) -\u003e ApiResult\u003c()\u003e {\n    let cluster = state.get_cluster(cluster_id).await?;\n    Ok(cluster.kafka_producer.produce(topic, key, value, mode).await?)\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","api","schema_registry.rs"],"content":"use crate::lib::schema_registry::Subject;\nuse log::debug;\n\nuse super::{\n    error::{ApiError, ApiResult},\n    AppState,\n};\n\n#[tauri::command]\npub async fn list_subjects(cluster_id: \u0026str, state: tauri::State\u003c'_, AppState\u003e) -\u003e ApiResult\u003cVec\u003cString\u003e\u003e {\n    debug!(\"List schema schema registry subjects\");\n    let client = state.get_schema_reg_client(cluster_id).await?.ok_or(ApiError {\n        error_type: \"Configuration error\".into(),\n        message: \"Missing schema registry configuration\".into(),\n    })?;\n    Ok(client.list_subjects().await?)\n}\n\n#[tauri::command]\npub async fn get_subject(subject_name: \u0026str, cluster_id: \u0026str, state: tauri::State\u003c'_, AppState\u003e) -\u003e ApiResult\u003cSubject\u003e {\n    debug!(\"Retrieve all schema version for subject {}\", subject_name);\n    let client = state.get_schema_reg_client(cluster_id).await?.ok_or(ApiError {\n        error_type: \"Configuration error\".into(),\n        message: \"Missing schema registry configuration\".into(),\n    })?;\n    Ok(client.get_subject(subject_name).await?)\n}\n\n#[tauri::command]\npub async fn delete_subject(subject_name: \u0026str, cluster_id: \u0026str, state: tauri::State\u003c'_, AppState\u003e) -\u003e ApiResult\u003c()\u003e {\n    debug!(\"Deleting subject {}\", subject_name);\n    let client = state.get_schema_reg_client(cluster_id).await?.ok_or(ApiError {\n        error_type: \"Configuration error\".into(),\n        message: \"Missing schema registry configuration\".into(),\n    })?;\n    Ok(client.delete_subject(subject_name).await?)\n}\n\n#[tauri::command]\npub async fn delete_subject_version(\n    subject_name: \u0026str,\n    version: i32,\n    cluster_id: \u0026str,\n    state: tauri::State\u003c'_, AppState\u003e,\n) -\u003e ApiResult\u003c()\u003e {\n    debug!(\"Deleting subject {} version {}\", subject_name, version);\n    let client = state.get_schema_reg_client(cluster_id).await?.ok_or(ApiError {\n        error_type: \"Configuration error\".into(),\n        message: \"Missing schema registry configuration\".into(),\n    })?;\n    Ok(client.delete_version(subject_name, version).await?)\n}\n\n#[tauri::command]\npub async fn post_schema(\n    subject_name: \u0026str,\n    schema: \u0026str,\n    cluster_id: \u0026str,\n    state: tauri::State\u003c'_, AppState\u003e,\n) -\u003e ApiResult\u003c()\u003e {\n    debug!(\"Create subject {}\", subject_name);\n    let client = state.get_schema_reg_client(cluster_id).await?.ok_or(ApiError {\n        error_type: \"Configuration error\".into(),\n        message: \"Missing schema registry configuration\".into(),\n    })?;\n    Ok(client.post_schema(subject_name, schema).await?)\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":30},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","api","state.rs"],"content":"use std::{collections::HashMap, sync::Arc};\n\nuse log::debug;\nuse tauri::Manager;\nuse tokio::sync::RwLock;\n\nuse crate::lib::{\n    configuration::ConfigurationProvider, error_callback::ErrorCallback, schema_registry::CachedSchemaRegistry,\n};\n\nuse super::{\n    cluster::Cluster,\n    error::{ApiError, ApiResult},\n};\n\ntype ClusterId = String;\n\npub struct AppState {\n    clusters: Arc\u003cRwLock\u003cHashMap\u003cClusterId, Arc\u003cCluster\u003e\u003e\u003e\u003e,\n    pub configuration_provider: Arc\u003cConfigurationProvider\u003e,\n    error_callback: ErrorCallback\u003cApiError\u003e,\n}\n\nimpl AppState {\n    pub fn new(app_handle: tauri::AppHandle) -\u003e Self {\n        AppState {\n            clusters: Default::default(),\n            configuration_provider: Arc::new(ConfigurationProvider::new()),\n            error_callback: Arc::new(move |err| {\n                app_handle.emit_all(\"error\", err).ok();\n            }),\n        }\n    }\n\n    pub async fn get_cluster(\u0026self, cluster_id: \u0026str) -\u003e ApiResult\u003cArc\u003cCluster\u003e\u003e {\n        {\n            if let Some(cluster) = self.clusters.read().await.get(cluster_id) {\n                return Ok(cluster.clone());\n            }\n        }\n        {\n            debug!(\"Init cluster {}\", cluster_id);\n            let cluster = self.build_new_cluster(cluster_id, self.error_callback.clone())?;\n            let cluster = Arc::new(cluster);\n            self.clusters.write().await.insert(cluster_id.into(), cluster.clone());\n            Ok(cluster)\n        }\n    }\n\n    pub async fn get_schema_reg_client(\u0026self, cluster_id: \u0026str) -\u003e ApiResult\u003cOption\u003cArc\u003cCachedSchemaRegistry\u003e\u003e\u003e {\n        let cluster = self.get_cluster(cluster_id).await?;\n        Ok(cluster.schema_registry_client.as_ref().cloned())\n    }\n\n    fn build_new_cluster(\u0026self, cluster_id: \u0026str, error_callback: ErrorCallback\u003cApiError\u003e) -\u003e ApiResult\u003cCluster\u003e {\n        debug!(\"Init cluster {}\", cluster_id);\n        let configuration = self.configuration_provider.get_configuration()?;\n        Cluster::new(cluster_id, \u0026configuration, error_callback)\n    }\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":19},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","api","types.rs"],"content":"use serde::Serialize;\n\nuse crate::lib::types::ParsedKafkaRecord;\n\n#[derive(Serialize, Debug)]\npub struct GetPageResponse {\n    pub records: Vec\u003cParsedKafkaRecord\u003e,\n    #[serde(rename = \"nextPage\")]\n    pub next_page: Option\u003cusize\u003e,\n    #[serde(rename = \"prevPage\")]\n    pub prev_page: Option\u003cusize\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","api","utils.rs"],"content":"use log::{debug, error};\n\nuse super::error::{ApiError, ApiResult};\nuse super::AppState;\nuse rust_keystore::KeyStore;\nuse serde::{Deserialize, Serialize};\n\n#[tauri::command]\npub async fn export_datastore(cluster_id: \u0026str, output_path: \u0026str, state: tauri::State\u003c'_, AppState\u003e) -\u003e ApiResult\u003c()\u003e {\n    debug!(\"Start export database\");\n    Ok(state.get_cluster(cluster_id).await?.store.export_db(output_path)?)\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct UserCertificate {\n    certificate: String,\n    key: String,\n}\n\n#[tauri::command]\npub async fn parse_truststore(location: \u0026str, password: Option\u003c\u0026str\u003e) -\u003e ApiResult\u003cString\u003e {\n    debug!(\"Parsing truststore {}\", \u0026location);\n    let ca_certificate = KeyStore::try_load(location)\n        .and_then(|c| c.certificates(password))\n        .map(|certs| certs[0].pem.clone());\n    ca_certificate.map_err(|err| {\n        error!(\"Unable to load the truststore: {:?}\", err);\n        ApiError {\n            error_type: \"Legacy config\".into(),\n            message: \"Unable to correctly parse the truststore\".into(),\n        }\n    })\n}\n\n#[tauri::command]\npub async fn parse_keystore(location: \u0026str, password: Option\u003c\u0026str\u003e) -\u003e ApiResult\u003cUserCertificate\u003e {\n    debug!(\"Parsing keystore {}\", \u0026location);\n    let user_cert = KeyStore::try_load(location)\n        .and_then(|c| c.certificates(password))\n        .map(|certs| certs[0].clone());\n\n    if let Ok(certificate) = user_cert {\n        if let (certificate, Some(key)) = (certificate.pem, certificate.private_key) {\n            return Ok(UserCertificate {\n                certificate,\n                key: key.pkcs8_pem,\n            });\n        }\n    }\n    Err(ApiError {\n        error_type: \"Legacy config\".into(),\n        message: \"Unable to correctly parse the keystore\".into(),\n    })\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":26},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","integration_tests","consumer_group_admin_it.rs"],"content":"#![cfg(test)]\nuse rdkafka::{\n    consumer::{BaseConsumer, Consumer},\n    producer::{BaseProducer, BaseRecord},\n};\nuse std::time::Duration;\n\nuse crate::{integration_tests::KafkaTest, lib::admin::KafkaAdmin};\n\n#[tokio::test]\nasync fn test_consumer_groups_admin_client() {\n    // arrange\n    let test_fixture = KafkaTest::new();\n\n    let consumer: BaseConsumer = test_fixture.build_kafka_client();\n    let producer: BaseProducer = test_fixture.build_kafka_client();\n    let cluster_config = test_fixture.build_cluster_config();\n\n    let sut = KafkaAdmin::new(\u0026cluster_config, test_fixture.tmo).expect(\"Unable to create the admin client\");\n    let test_topic_name = \"test_topic_name\";\n    // produce a record to create the topic\n    producer\n        .send(BaseRecord::to(\u0026test_topic_name).key(\"key\").payload(\"content\"))\n        .expect(\"Unable to produce the message\");\n\n    // test list consumer groups\n    {\n        // arrange\n        // create a consumer group by consuming the test topic\n        consumer\n            .subscribe(\u0026[\u0026test_topic_name])\n            .expect(\"Unable to subscribe to the test topic\");\n        let consumed = consumer.poll(Duration::from_secs(60)).unwrap();\n        assert!(consumed.is_ok());\n        // act\n        let res = sut.list_consumer_groups().expect(\"\");\n        // assert\n        assert_eq!(res, vec![test_fixture.default_consumer_group])\n    }\n\n    // test create consumer groups\n    {\n        let test_consumer_group = \"test-consumer-group\";\n        // act\n        let res = sut.set_consumer_group(\n            test_consumer_group,\n            \u0026[\u0026test_topic_name],\n            \u0026crate::lib::consumer::types::ConsumerSessionConfiguration::Beginning,\n        );\n        // assert\n        assert!(res.is_ok());\n        let consumer_groups = consumer\n            .fetch_group_list(None, test_fixture.tmo)\n            .expect(\"Unable to retrieve the list of consumer groups\");\n        assert!(!consumer_groups\n            .groups()\n            .iter()\n            .filter(|cg| cg.name() == test_consumer_group)\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .is_empty())\n    }\n\n    // test delete consumer group\n    {\n        let test_consumer_group = \"test-delete-consumer-group\";\n        sut.set_consumer_group(\n            test_consumer_group,\n            \u0026[\u0026test_topic_name],\n            \u0026crate::lib::consumer::types::ConsumerSessionConfiguration::Beginning,\n        )\n        .expect(\"Unable to create the consumer group for the test\");\n        // act\n        let res = sut.delete_consumer_group(test_consumer_group).await;\n        // assert\n        assert!(res.is_ok());\n        let consumer_groups = consumer\n            .fetch_group_list(None, test_fixture.tmo)\n            .expect(\"Unable to retrieve the list of consumer groups\");\n        assert!(consumer_groups\n            .groups()\n            .iter()\n            .filter(|cg| cg.name() == test_consumer_group)\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .is_empty())\n    }\n\n    // test describe consumer group\n    {\n        let test_consumer_group = \"test-delete-consumer-group\";\n        sut.set_consumer_group(\n            test_consumer_group,\n            \u0026[\u0026test_topic_name],\n            \u0026crate::lib::consumer::types::ConsumerSessionConfiguration::Beginning,\n        )\n        .expect(\"Unable to create the consumer group for the test\");\n        // act\n        let res = sut\n            .describe_consumer_group(test_consumer_group, true)\n            .await\n            .expect(\"Unable to describe the consumer group\");\n        // assert\n        assert_eq!(res.offsets.len(), 1);\n        assert_eq!(res.offsets[0].offset, 0);\n        assert_eq!(res.offsets[0].topic, test_topic_name);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","integration_tests","mod.rs"],"content":"#![cfg(test)]\n\nuse once_cell::sync::Lazy;\nuse rdkafka::{config::FromClientConfig, ClientConfig};\nuse std::time::Duration;\nuse testcontainers::{clients, images::kafka};\n\nuse crate::lib::configuration::{ClusterConfig, Favorites};\n\nmod consumer_group_admin_it;\nmod topic_admin_it;\n\nstatic DOCKER: Lazy\u003cclients::Cli\u003e = Lazy::new(clients::Cli::default);\n\nstruct KafkaTest\u003c'a\u003e {\n    pub tmo: Duration,\n    pub default_consumer_group: String,\n    pub bootstrap_servers: String,\n    _kafka_node: testcontainers::Container\u003c'a, kafka::Kafka\u003e,\n}\n\nimpl\u003c'a\u003e KafkaTest\u003c'a\u003e {\n    fn new() -\u003e Self {\n        let tmo = Duration::from_secs(30);\n        let kafka_node = DOCKER.run(kafka::Kafka::default());\n\n        let bootstrap_servers = format!(\"127.0.0.1:{}\", kafka_node.get_host_port_ipv4(kafka::KAFKA_PORT));\n        kafka_node.start();\n\n        Self {\n            tmo,\n            default_consumer_group: \"testcontainer-rs\".into(),\n            bootstrap_servers,\n            _kafka_node: kafka_node,\n        }\n    }\n\n    fn build_kafka_client\u003cT: FromClientConfig\u003e(\u0026self) -\u003e T {\n        ClientConfig::new()\n            .set(\"group.id\", self.default_consumer_group.to_string())\n            .set(\"bootstrap.servers\", self.bootstrap_servers.to_string())\n            .set(\"session.timeout.ms\", \"6000\")\n            .set(\"enable.auto.commit\", \"true\")\n            .set(\"auto.offset.reset\", \"earliest\")\n            .create()\n            .expect(\"Unable to create the kafka client\")\n    }\n\n    fn build_cluster_config(\u0026self) -\u003e ClusterConfig {\n        ClusterConfig {\n            id: \"cluster-id\".into(),\n            name: \"test-cluster-name\".into(),\n            endpoint: self.bootstrap_servers.to_string(),\n            authentication: crate::lib::configuration::AuthenticationConfig::None,\n            schema_registry: None,\n            favorites: Favorites::default(),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","integration_tests","topic_admin_it.rs"],"content":"#![cfg(test)]\n\nuse rdkafka::{\n    consumer::{stream_consumer::StreamConsumer, Consumer},\n    producer::{FutureProducer, FutureRecord},\n};\nuse std::{collections::HashSet, time::Duration};\n\nuse crate::{integration_tests::KafkaTest, lib::admin::KafkaAdmin};\n\n#[tokio::test]\nasync fn test_topic_admin_client() {\n    // arrange\n    let test_fixture = KafkaTest::new();\n\n    let consumer: StreamConsumer = test_fixture.build_kafka_client();\n    let cluster_config = test_fixture.build_cluster_config();\n\n    let sut = KafkaAdmin::new(\u0026cluster_config, test_fixture.tmo).expect(\"Unable to create the admin client\");\n\n    // test create a topic\n    {\n        let test_topic_name = \"test_topic_name\";\n        let partition_count = 7_usize;\n        // act\n        sut.create_topic(test_topic_name, partition_count as i32, 1, false)\n            .await\n            .expect(\"Unable to create the test topic\");\n\n        // assert\n        let metadata = consumer\n            .fetch_metadata(None, test_fixture.tmo)\n            .expect(\"Unable to retrieve the metadata\");\n        let tp: Vec\u003c_\u003e = metadata\n            .topics()\n            .iter()\n            .map(|t| (t.name(), t.partitions().len()))\n            .collect();\n\n        assert!(tp.contains(\u0026(test_topic_name, partition_count)))\n    }\n\n    // test retrieve the list of topics\n    {\n        sut.create_topic(\"another_test_topic\", 1, 1, true)\n            .await\n            .expect(\"Unable to create a test topic\");\n        // act\n        let res = sut.list_topics().await.expect(\"Unable to retrieve the list of topics\");\n        // assert\n        let topic_set: HashSet\u003c_\u003e = res.iter().map(|t| (t.name.clone(), t.partitions.len())).collect();\n        let metadata = consumer\n            .fetch_metadata(None, test_fixture.tmo)\n            .expect(\"Unable to retrieve the metadata\");\n\n        let expected_topics: HashSet\u003c_\u003e = metadata\n            .topics()\n            .iter()\n            .map(|t| (t.name().to_string(), t.partitions().len()))\n            .collect();\n\n        assert_eq!(topic_set, expected_topics)\n    }\n\n    // test get topic\n    {\n        // arrange\n        let test_topic_name = \"test_get_topic\";\n        let partition_count = 3_usize;\n        sut.create_topic(test_topic_name, partition_count as i32, 1, true)\n            .await\n            .expect(\"Unable to create a test topic\");\n        // act\n        let res = sut.get_topic(test_topic_name).expect(\"Unable to get topic\");\n        // assert\n        assert_eq!(res.name, test_topic_name.to_string());\n        assert_eq!(res.partitions.len(), partition_count);\n    }\n\n    // test get topic info\n    {\n        // arrange\n        let test_topic_name = \"test_get_topic_info\";\n        let partition_count = 3_usize;\n        sut.create_topic(test_topic_name, partition_count as i32, 1, true)\n            .await\n            .expect(\"Unable to create a test topic\");\n        // act\n        let res = sut.get_topic_info(test_topic_name).await.expect(\"get_topic_info error\");\n        // assert\n        assert_eq!(res.name, test_topic_name.to_string());\n        assert_eq!(res.partitions.len(), partition_count);\n        assert_eq!(\n            res.configurations.get(\"cleanup.policy\").unwrap(),\n            \u0026Some(\"compact\".to_string())\n        );\n    }\n\n    // delete topic test\n    {\n        // arrange\n        let test_topic_name = \"test_delete_topic\";\n        sut.create_topic(test_topic_name, 1, 1, true)\n            .await\n            .expect(\"Unable to create a test topic\");\n        // act\n        let res = sut.delete_topic(test_topic_name).await;\n        // assert\n        assert!(res.is_ok())\n    }\n\n    // get last offset\n    {\n        // arrange\n        let expected_offset = 13;\n        let test_topic_name = \"test_get_last_offset\";\n        let producer: FutureProducer = test_fixture.build_kafka_client();\n        sut.create_topic(test_topic_name, 1, 1, true)\n            .await\n            .expect(\"Unable to create a test topic\");\n        // produce some records to increase the offset\n        for i in 0..expected_offset {\n            producer\n                .send(\n                    FutureRecord::to(test_topic_name)\n                        .payload(\u0026format!(\"test_message {}\", i))\n                        .key(\u0026format!(\"Key {}\", i)),\n                    Duration::from_secs(0),\n                )\n                .await\n                .expect(\"Unable to produce the message\");\n        }\n        // act\n        let res = sut\n            .get_last_offsets(\u0026[test_topic_name])\n            .await\n            .expect(\"get_last_offsets error\");\n\n        // assert\n        let topic_result = res.get(test_topic_name).expect(\"Invalid result\");\n        // since there is only one partition we expect to get only one offset\n        assert_eq!(topic_result.len(), 1);\n        assert_eq!(topic_result[0].offset, expected_offset)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","admin","client.rs"],"content":"use std::sync::Arc;\nuse std::time::Duration;\n\nuse crate::lib::configuration::{build_kafka_client_config, ClusterConfig};\nuse log::debug;\nuse rdkafka::admin::AdminClient;\nuse rdkafka::{client::DefaultClientContext, consumer::BaseConsumer};\nuse rdkafka::{Offset, TopicPartitionList};\nuse tokio::sync::RwLock;\n\nuse super::error::AdminResult;\n\npub struct KafkaAdmin {\n    pub(super) config: ClusterConfig,\n    pub(super) timeout: Duration,\n    pub(super) consumer: BaseConsumer,\n    pub(super) admin_client: AdminClient\u003cDefaultClientContext\u003e,\n    pub(super) all_topic_partition_list: Arc\u003cRwLock\u003cTopicPartitionList\u003e\u003e,\n}\n\nimpl KafkaAdmin {\n    pub fn new(config: \u0026ClusterConfig, kafka_timeout: Duration) -\u003e AdminResult\u003cSelf\u003e {\n        Ok(KafkaAdmin {\n            config: config.clone(),\n            timeout: kafka_timeout,\n            consumer: build_kafka_client_config(config, None).create()?,\n            admin_client: build_kafka_client_config(config, None).create()?,\n            all_topic_partition_list: Arc::new(RwLock::new(TopicPartitionList::new())),\n        })\n    }\n\n    pub(super) async fn get_all_topic_partition_list(\u0026self, ignore_cache: bool) -\u003e AdminResult\u003cTopicPartitionList\u003e {\n        {\n            let topic_partition_list = self.all_topic_partition_list.read().await;\n            if !ignore_cache \u0026\u0026 topic_partition_list.count() \u003e 0 {\n                return Ok(topic_partition_list.clone());\n            }\n        }\n        let mut topic_partition_list = TopicPartitionList::new();\n        debug!(\"Retrieve the list of all topics/partition\");\n        let topics = self.list_topics().await?;\n        debug!(\"Build the topic/partition list\");\n        for topic in topics {\n            for partition in topic.partitions {\n                topic_partition_list.add_partition_offset(\u0026topic.name, partition.id, Offset::End)?;\n            }\n        }\n        {\n            *self.all_topic_partition_list.write().await = topic_partition_list.clone();\n        }\n        Ok(topic_partition_list)\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":116},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":17,"coverable":20},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","admin","consumer_admin.rs"],"content":"use log::{debug, trace};\n\nuse super::{error::AdminResult, ConsumerGroupInfo, KafkaAdmin};\nuse crate::lib::{\n    admin::TopicPartitionOffset,\n    configuration::build_kafka_client_config,\n    consumer::{types::ConsumerSessionConfiguration, KafkaConsumer},\n};\nuse rdkafka::{\n    admin::AdminOptions,\n    consumer::{BaseConsumer, Consumer},\n};\nuse rdkafka::{consumer::CommitMode, Offset};\n\nimpl KafkaAdmin {\n    pub async fn delete_consumer_group(\u0026self, consumer_group_name: \u0026str) -\u003e AdminResult\u003c()\u003e {\n        debug!(\"Deleting consumer group {}\", consumer_group_name);\n        let res = self\n            .admin_client\n            .delete_groups(\u0026[consumer_group_name], \u0026AdminOptions::default())\n            .await?;\n        assert_eq!(res.len(), 1);\n        match res.first().unwrap() {\n            Ok(_) =\u003e Ok(()),\n            Err(err) =\u003e Err(err.1.into()),\n        }\n    }\n\n    pub fn set_consumer_group(\n        \u0026self,\n        consumer_group_name: \u0026str,\n        topic_names: \u0026[\u0026str],\n        config: \u0026ConsumerSessionConfiguration,\n    ) -\u003e AdminResult\u003c()\u003e {\n        let consumer = build_kafka_client_config(\u0026self.config, Some(consumer_group_name)).create()?;\n\n        debug!(\"assign offsets for each topic\");\n        KafkaConsumer::update_consumer_assignment(\u0026consumer, topic_names, config, self.timeout)?;\n\n        debug!(\"store offset to commit\");\n        for t in consumer.assignment()?.elements() {\n            trace!(\n                \"Store topic {:?} partition {:?} offset {:?}\",\n                t.topic(),\n                t.partition(),\n                t.offset().to_raw()\n            );\n            consumer.store_offset(t.topic(), t.partition(), t.offset().to_raw().unwrap() - 1)?;\n        }\n\n        debug!(\"commit consumer state\");\n        Ok(consumer.commit_consumer_state(CommitMode::Sync)?)\n    }\n\n    pub fn list_consumer_groups(\u0026self) -\u003e AdminResult\u003cVec\u003cString\u003e\u003e {\n        let groups = self.consumer.fetch_group_list(None, self.timeout)?;\n        let group_names: Vec\u003c_\u003e = groups.groups().iter().map(|g| g.name().to_string()).collect();\n        Ok(group_names)\n    }\n\n    pub async fn describe_consumer_group(\n        \u0026self,\n        consumer_group_name: \u0026str,\n        ignore_cache: bool,\n    ) -\u003e AdminResult\u003cConsumerGroupInfo\u003e {\n        // create a consumer with the defined consumer_group_name.\n        // NOTE: the consumer shouldn't join the consumer group, otherwise it'll cause a re-balance\n        debug!(\"Build the consumer for tsumer group {}\", consumer_group_name);\n        let consumer: BaseConsumer = build_kafka_client_config(\u0026self.config, Some(consumer_group_name)).create()?;\n\n        debug!(\"Build the topic/partition list\");\n        let topic_partition_lst = self.get_all_topic_partition_list(ignore_cache).await?;\n\n        debug!(\"Retrieve any committed offset to the consumer group\");\n        // allow up to 1 minute of tmo for big clusters and slow connections\n        let committed_offsets = consumer.committed_offsets(topic_partition_lst, self.timeout).unwrap();\n\n        debug!(\"Build API response\");\n        let offsets: Vec\u003c_\u003e = committed_offsets\n            .elements()\n            .iter()\n            .filter(|tpo| tpo.offset() != Offset::Invalid)\n            .map(|r| TopicPartitionOffset {\n                topic: r.topic().into(),\n                partition_id: r.partition(),\n                offset: r.offset().to_raw().unwrap(),\n            })\n            .collect();\n        debug!(\"Retrieve completed\");\n        Ok(ConsumerGroupInfo {\n            name: consumer_group_name.into(),\n            offsets,\n        })\n    }\n\n    pub fn get_consumer_group_state(\u0026self, consumer_group_name: \u0026str) -\u003e AdminResult\u003cString\u003e {\n        debug!(\"Retrieve consumer group status\");\n        let fetch_group_response = self\n            .consumer\n            .fetch_group_list(Some(consumer_group_name), self.timeout)?;\n        let groups: Vec\u003c_\u003e = fetch_group_response.groups().iter().collect();\n        assert_eq!(groups.len(), 1);\n        Ok(groups[0].state().to_string())\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":53},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":35,"coverable":53},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","admin","error.rs"],"content":"use rdkafka::{error::KafkaError, types::RDKafkaErrorCode};\n\nuse crate::lib::consumer::ConsumerError;\n\n#[derive(Debug)]\npub enum AdminError {\n    /// topic (Name) not found\n    TopicNotFound(String),\n    /// RDKafka errors\n    RDKafka(String),\n    // Consumer error\n    ConsumerError(ConsumerError),\n}\n\npub type AdminResult\u003cT\u003e = Result\u003cT, AdminError\u003e;\n\nimpl From\u003cKafkaError\u003e for AdminError {\n    fn from(error: KafkaError) -\u003e Self {\n        AdminError::RDKafka(error.to_string())\n    }\n}\nimpl From\u003cRDKafkaErrorCode\u003e for AdminError {\n    fn from(value: RDKafkaErrorCode) -\u003e Self {\n        AdminError::RDKafka(value.to_string())\n    }\n}\n//todo: change with the consumer error\nimpl From\u003cConsumerError\u003e for AdminError {\n    fn from(value: ConsumerError) -\u003e Self {\n        AdminError::ConsumerError(value)\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":6},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","admin","mod.rs"],"content":"mod client;\nmod consumer_admin;\nmod error;\nmod topic_admin;\nmod types;\n\npub use client::KafkaAdmin;\npub use error::*;\npub use types::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","admin","topic_admin.rs"],"content":"use log::{debug, warn};\nuse std::{collections::HashMap, vec};\n\nuse crate::lib::admin::error::AdminError;\n\nuse super::{\n    error::AdminResult,\n    types::{PartitionInfo, PartitionOffset, Topic, TopicInfo},\n    KafkaAdmin, Partition,\n};\nuse rdkafka::{admin::ResourceSpecifier, Offset, TopicPartitionList};\nuse rdkafka::{\n    admin::{AdminOptions, NewTopic, TopicReplication},\n    consumer::Consumer,\n};\n\nimpl KafkaAdmin {\n    pub async fn list_topics(\u0026self) -\u003e AdminResult\u003cVec\u003cTopic\u003e\u003e {\n        {\n            // delete cache of topics/partitions map\n            *self.all_topic_partition_list.write().await = TopicPartitionList::new();\n        }\n        self.internal_list_topics(None)\n    }\n\n    pub fn get_topic(\u0026self, topic_name: \u0026str) -\u003e AdminResult\u003cTopic\u003e {\n        let topic_list = self.internal_list_topics(Some(topic_name))?;\n        if let Some(topic) = topic_list.first() {\n            Ok(topic.to_owned())\n        } else {\n            warn!(\n                \"Topic not found or more than one topic with the same name {}\",\n                topic_name\n            );\n            Err(AdminError::TopicNotFound(topic_name.to_string()))\n        }\n    }\n\n    pub async fn delete_topic(\u0026self, topic_name: \u0026str) -\u003e AdminResult\u003c()\u003e {\n        debug!(\"Deleting topic {}\", topic_name);\n        let res = self\n            .admin_client\n            .delete_topics(\u0026[topic_name], \u0026AdminOptions::default())\n            .await?;\n        match res.first() {\n            Some(Ok(_)) =\u003e Ok(()),\n            Some(Err(err)) =\u003e Err(err.1.into()),\n            None =\u003e Err(AdminError::TopicNotFound(topic_name.to_string())),\n        }\n    }\n\n    pub async fn get_topic_info(\u0026self, topic_name: \u0026str) -\u003e AdminResult\u003cTopicInfo\u003e {\n        let topic = self.get_topic(topic_name)?;\n\n        // retrieve the last offsets\n        let mut tp = TopicPartitionList::new();\n        for p_id in 0..topic.partitions.len() {\n            tp.add_partition_offset(topic_name, p_id as i32, Offset::End)?;\n        }\n        let Topic { name, partitions } = topic;\n        Ok(TopicInfo {\n            name: name.to_string(),\n            partitions: partitions\n                .iter()\n                .map(|p| PartitionInfo {\n                    id: p.id,\n                    isr: p.isr,\n                    replicas: p.replicas,\n                })\n                .collect(),\n            configurations: self.get_topic_configuration(topic_name).await?,\n        })\n    }\n\n    // return a list in which the index is the partition id and the value is the offset\n    pub async fn get_last_offsets(\u0026self, topic_names: \u0026[\u0026str]) -\u003e AdminResult\u003cHashMap\u003cString, Vec\u003cPartitionOffset\u003e\u003e\u003e {\n        let all_partitions = self.get_all_topic_partition_list(false).await?;\n        let mut topic_partition_list = TopicPartitionList::new();\n        for topic in topic_names {\n            for tpo in all_partitions.elements_for_topic(topic) {\n                topic_partition_list.add_partition_offset(topic, tpo.partition(), Offset::End)?;\n            }\n        }\n        let offsets = self.consumer.offsets_for_times(topic_partition_list, self.timeout)?;\n        let mut res = HashMap::\u003cString, Vec\u003cPartitionOffset\u003e\u003e::new();\n        offsets.elements().iter().for_each(|t| {\n            if !res.contains_key(t.topic()) {\n                res.insert(t.topic().into(), vec![]);\n            }\n            let partition_offsets = res.get_mut(t.topic()).unwrap();\n            partition_offsets.push(PartitionOffset {\n                partition_id: t.partition(),\n                offset: t.offset().to_raw().unwrap(),\n            })\n        });\n        Ok(res)\n    }\n\n    pub async fn create_topic(\u0026self, name: \u0026str, num_partitions: i32, isr: i32, compacted: bool) -\u003e AdminResult\u003c()\u003e {\n        let new_topic = NewTopic {\n            name,\n            num_partitions,\n            config: vec![(\"cleanup.policy\", if compacted { \"compact\" } else { \"delete\" })],\n            replication: TopicReplication::Fixed(isr),\n        };\n        let res = self\n            .admin_client\n            .create_topics(vec![\u0026new_topic], \u0026AdminOptions::default())\n            .await?;\n        let res = res\n            .first()\n            .ok_or_else(|| AdminError::RDKafka(\"Invalid result from create topic api call.\".into()))?;\n        match res {\n            Ok(_) =\u003e {\n                debug!(\"Topic created successfully\");\n                Ok(())\n            }\n            Err(err) =\u003e {\n                warn!(\"{:?}\", err);\n                Err(err.1.into())\n            }\n        }\n    }\n\n    pub async fn get_topic_configuration(\u0026self, topic_name: \u0026str) -\u003e AdminResult\u003cHashMap\u003cString, Option\u003cString\u003e\u003e\u003e {\n        debug!(\"Retrieving the topic configurations\");\n        let responses = self\n            .admin_client\n            .describe_configs([\u0026ResourceSpecifier::Topic(topic_name)], \u0026AdminOptions::default())\n            .await?;\n        let mut configurations = HashMap::\u003cString, Option\u003cString\u003e\u003e::new();\n        if let Some(Ok(topic_config)) = responses.first() {\n            topic_config.entries.iter().for_each(|c| {\n                configurations.insert(c.name.clone(), c.value.as_ref().cloned());\n            });\n        }\n        Ok(configurations)\n    }\n\n    fn internal_list_topics(\u0026self, topic: Option\u003c\u0026str\u003e) -\u003e AdminResult\u003cVec\u003cTopic\u003e\u003e {\n        let topics: Vec\u003c_\u003e = self\n            .consumer\n            .fetch_metadata(topic, self.timeout)?\n            .topics()\n            .iter()\n            .map(|t| Topic {\n                name: t.name().to_string(),\n                partitions: t\n                    .partitions()\n                    .iter()\n                    .map(|m| Partition {\n                        id: m.id(),\n                        isr: m.isr().len(),\n                        replicas: m.replicas().len(),\n                    })\n                    .collect(),\n            })\n            .collect();\n        Ok(topics)\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":193},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":180},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":180},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":180},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":5},"fn_name":null}],"covered":82,"coverable":92},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","admin","types.rs"],"content":"use std::collections::HashMap;\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Topic {\n    pub name: String,\n    pub partitions: Vec\u003cPartition\u003e,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Partition {\n    pub id: i32,\n    pub isr: usize,\n    pub replicas: usize,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct TopicInfo {\n    pub name: String,\n    pub partitions: Vec\u003cPartitionInfo\u003e,\n    pub configurations: HashMap\u003cString, Option\u003cString\u003e\u003e,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct PartitionInfo {\n    pub id: i32,\n    pub isr: usize,\n    pub replicas: usize,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct ConsumerGroupInfo {\n    pub name: String,\n    pub offsets: Vec\u003cTopicPartitionOffset\u003e,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct TopicPartitionOffset {\n    pub topic: String,\n    pub partition_id: i32,\n    pub offset: i64,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct PartitionOffset {\n    #[serde(rename = \"partitionId\")]\n    pub partition_id: i32,\n    pub offset: i64,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","avro","avro_parser.rs"],"content":"use std::sync::Arc;\n\nuse super::schema_provider::SchemaProvider;\n\npub struct AvroParser\u003cS: SchemaProvider\u003e {\n    pub(super) schema_provider: Arc\u003cS\u003e,\n}\n\nimpl\u003cS: SchemaProvider\u003e AvroParser\u003cS\u003e {\n    pub fn new(schema_provider: Arc\u003cS\u003e) -\u003e Self {\n        Self { schema_provider }\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","avro","avro_to_json.rs"],"content":"use super::{\n    avro_parser::AvroParser,\n    error::{AvroError, AvroResult},\n    helpers::get_schema_id_from_record_header,\n    schema_provider::SchemaProvider,\n};\nuse apache_avro::{from_avro_datum, schema::Name, types::Value as AvroValue, Schema};\nuse num_bigint::BigInt;\nuse rust_decimal::Decimal;\nuse serde_json::{json, Map, Value as JsonValue};\nuse std::{collections::HashMap, io::Cursor};\n\nimpl\u003cS: SchemaProvider\u003e AvroParser\u003cS\u003e {\n    pub async fn avro_to_json(\u0026self, raw: \u0026[u8]) -\u003e AvroResult\u003cString\u003e {\n        // retrieve the schema from the id on the record header\n        let id = get_schema_id_from_record_header(raw)?;\n\n        let schema = self.schema_provider.get_schema_by_id(id).await?;\n        let mut data = Cursor::new(\u0026raw[5..]);\n\n        // parse the avro record into an AvroValue\n        let record =\n            from_avro_datum(\u0026schema.schema, \u0026mut data, None).map_err(|err| AvroError::ParseAvroValue(err.to_string()))?;\n        let json = map(\u0026record, \u0026schema.schema, \u0026None, \u0026schema.resolved_schemas)?;\n        let res = serde_json::to_string(\u0026json).map_err(|err| AvroError::ParseJsonValue(err.to_string()))?;\n        Ok(res)\n    }\n}\n\nfn map(\n    value: \u0026AvroValue,\n    schema: \u0026Schema,\n    parent_ns: \u0026Option\u003cString\u003e,\n    ref_cache: \u0026HashMap\u003cName, Schema\u003e,\n) -\u003e AvroResult\u003cJsonValue\u003e {\n    match (value, schema) {\n        (AvroValue::Null, Schema::Null) =\u003e Ok(JsonValue::Null),\n        (AvroValue::Boolean(v), Schema::Boolean) =\u003e Ok(json!(*v)),\n        (AvroValue::Int(v), Schema::Int) =\u003e Ok(json!(*v)),\n        (AvroValue::Long(v), Schema::Long) =\u003e Ok(json!(*v)),\n        (AvroValue::Float(v), Schema::Float) =\u003e Ok(json!(*v)),\n        (AvroValue::Double(v), Schema::Double) =\u003e Ok(json!(*v)),\n        (AvroValue::String(v), Schema::String) =\u003e Ok(json!(*v)),\n        (AvroValue::Array(v), Schema::Array(s)) =\u003e parse_array(v, s, parent_ns, ref_cache),\n        (AvroValue::Map(vec), Schema::Map(s)) =\u003e parse_map(vec, s, parent_ns, ref_cache),\n        (\n            AvroValue::Record(vec),\n            Schema::Record {\n                name, fields, lookup, ..\n            },\n        ) =\u003e parse_record(vec, lookup, fields, name, parent_ns, ref_cache),\n        (AvroValue::Date(v), Schema::Date) =\u003e Ok(json!(*v)),\n        (AvroValue::TimeMillis(v), Schema::TimeMillis) =\u003e Ok(json!(*v)),\n        (AvroValue::TimeMicros(v), Schema::TimeMicros) =\u003e Ok(json!(*v)),\n        (AvroValue::TimestampMillis(v), Schema::TimestampMillis) =\u003e Ok(json!(*v)),\n        (AvroValue::TimestampMicros(v), Schema::TimestampMicros) =\u003e Ok(json!(*v)),\n        (AvroValue::Uuid(v), Schema::Uuid) =\u003e Ok(json!(*v)),\n        (AvroValue::Bytes(v), Schema::Bytes) =\u003e Ok(json!(*v)),\n        (\n            AvroValue::Decimal(v),\n            Schema::Decimal {\n                precision: _,\n                scale,\n                inner: _,\n            },\n        ) =\u003e parse_decimal(v, scale),\n        (AvroValue::Duration(v), Schema::Duration) =\u003e Ok(json!(format!(\n            \"{:?} months {:?} days {:?} millis\",\n            v.months(),\n            v.days(),\n            v.millis()\n        ))),\n        (AvroValue::Union(i, v), Schema::Union(s)) =\u003e {\n            let schema = s\n                .variants()\n                .get(*i as usize)\n                .ok_or_else(|| AvroError::InvalidUnion(format!(\"Missing schema index {} in the union {:?}\", *i, s)))?;\n            map(v, schema, parent_ns, ref_cache)\n        }\n        (AvroValue::Enum(_, v), Schema::Enum { name: _, .. }) =\u003e Ok(json!(*v)),\n        (AvroValue::Fixed(_, v), Schema::Fixed { .. }) =\u003e Ok(json!(*v)),\n        (value, Schema::Ref { name }) =\u003e parse_ref(ref_cache, name, parent_ns, value),\n        (_, s) =\u003e Err(AvroError::Unsupported(format!(\n            \"Unexpected value/schema tuple. Schema: {:?}\",\n            s\n        ))),\n    }\n}\n\nfn parse_ref(\n    ref_cache: \u0026HashMap\u003cName, Schema\u003e,\n    name: \u0026Name,\n    parent_ns: \u0026Option\u003cString\u003e,\n    value: \u0026AvroValue,\n) -\u003e AvroResult\u003cJsonValue\u003e {\n    let schema = ref_cache\n        .get(\n            \u0026(Name {\n                namespace: name.namespace.clone().or_else(|| parent_ns.to_owned()),\n                name: name.name.clone(),\n            }),\n        )\n        .ok_or_else(|| AvroError::MissingAvroSchemaReference(name.to_string()))?;\n    map(value, schema, \u0026name.namespace, ref_cache)\n}\n\nfn parse_decimal(v: \u0026apache_avro::Decimal, scale: \u0026usize) -\u003e AvroResult\u003cJsonValue\u003e {\n    let arr = \u003cVec\u003cu8\u003e\u003e::try_from(v).map_err(|err| AvroError::InvalidNumber(err.to_string()))?;\n    let value = BigInt::from_signed_bytes_be(\u0026arr);\n    let num = i64::try_from(value).map_err(|err| AvroError::InvalidNumber(err.to_string()))?;\n    let decimal = Decimal::new(num, scale.to_owned() as u32);\n    Ok(json!(decimal))\n}\n\nfn parse_record(\n    vec: \u0026[(String, AvroValue)],\n    lookup: \u0026std::collections::BTreeMap\u003cString, usize\u003e,\n    fields: \u0026[apache_avro::schema::RecordField],\n    name: \u0026Name,\n    parent_ns: \u0026Option\u003cString\u003e,\n    ref_cache: \u0026HashMap\u003cName, Schema\u003e,\n) -\u003e AvroResult\u003cJsonValue\u003e {\n    let mut json_map = Map::new();\n    for (k, v) in vec.iter() {\n        let field_index = lookup.get(k).ok_or_else(|| AvroError::MissingField(k.to_string()))?;\n        json_map.insert(\n            k.clone(),\n            map(\n                v,\n                \u0026fields.get(*field_index).unwrap().schema,\n                \u0026name.namespace.clone().or_else(|| parent_ns.to_owned()),\n                ref_cache,\n            )?,\n        );\n    }\n    Ok(JsonValue::Object(json_map))\n}\n\nfn parse_map(\n    vec: \u0026HashMap\u003cString, AvroValue\u003e,\n    s: \u0026Schema,\n    parent_ns: \u0026Option\u003cString\u003e,\n    ref_cache: \u0026HashMap\u003cName, Schema\u003e,\n) -\u003e AvroResult\u003cJsonValue\u003e {\n    let mut json_map = Map::new();\n    for (k, v) in vec.iter() {\n        json_map.insert(k.clone(), map(v, s, parent_ns, ref_cache)?);\n    }\n    Ok(JsonValue::Object(json_map))\n}\n\nfn parse_array(\n    v: \u0026[AvroValue],\n    s: \u0026Schema,\n    parent_ns: \u0026Option\u003cString\u003e,\n    ref_cache: \u0026HashMap\u003cName, Schema\u003e,\n) -\u003e AvroResult\u003cJsonValue\u003e {\n    let mut json_vec = Vec::new();\n    for v in v.iter() {\n        json_vec.push(map(v, s, parent_ns, ref_cache)?);\n    }\n    Ok(JsonValue::Array(json_vec))\n}\n\n#[cfg(test)]\nmod tests {\n    use std::sync::Arc;\n\n    use apache_avro::{to_avro_datum, types::Record, types::Value as AvroValue, Schema as ApacheAvroSchema, Writer};\n    use async_trait::async_trait;\n\n    use crate::lib::{avro::error::AvroResult, schema_registry::ResolvedAvroSchema};\n\n    use super::{AvroParser, SchemaProvider};\n    struct MockSchemaRegistry {\n        schema: String,\n    }\n\n    #[async_trait]\n    impl SchemaProvider for MockSchemaRegistry {\n        async fn get_schema_by_id(\u0026self, _: i32) -\u003e AvroResult\u003cResolvedAvroSchema\u003e {\n            Ok(ResolvedAvroSchema::from(\n                123,\n                ApacheAvroSchema::parse_str(\u0026self.schema).unwrap(),\n            ))\n        }\n        async fn get_schema_by_name(\u0026self, _name: \u0026str) -\u003e AvroResult\u003cResolvedAvroSchema\u003e {\n            todo!()\n        }\n    }\n\n    fn get_sut(schema: String) -\u003e AvroParser\u003cMockSchemaRegistry\u003e {\n        AvroParser::new(Arc::new(MockSchemaRegistry { schema }))\n    }\n\n    #[tokio::test]\n    async fn test_simple_types_parsing() {\n        let raw_schema = r#\"\n    {\n        \"fields\": [\n            { \"name\": \"null_field\", \"type\": \"null\" },\n            { \"name\": \"boolean_field\", \"type\": \"boolean\" },\n            { \"name\": \"int_field\", \"type\": \"int\" },\n            { \"name\": \"long_field\", \"type\": \"long\" },\n            { \"name\": \"float_field\", \"type\": \"float\" },\n            { \"name\": \"double_field\", \"type\": \"double\" },\n            { \"name\": \"bytes_field\", \"type\": \"bytes\" },\n            { \"name\": \"string_field\", \"type\": \"string\" }\n        ],\n        \"name\": \"sampleRecord\",\n        \"namespace\": \"com.example.namespace\",\n        \"type\": \"record\"}\"#;\n        let schema = ApacheAvroSchema::parse_str(raw_schema).unwrap();\n        let writer = Writer::new(\u0026schema, Vec::new());\n        let mut record = Record::new(writer.schema()).unwrap();\n        record.put(\"null_field\", AvroValue::Null);\n        record.put(\"boolean_field\", true);\n        record.put(\"int_field\", 12);\n        record.put(\"long_field\", 12345667);\n        record.put(\"float_field\", 123.123f32);\n        record.put(\"double_field\", 12.12f64);\n        record.put(\"bytes_field\", AvroValue::Bytes(vec![0x01, 0x02, 0xaa]));\n        record.put(\"string_field\", \"YO!! test\");\n        let mut encoded = to_avro_datum(\u0026schema, record).unwrap();\n        // add 1 magic byte + 4 id bytes\n        let mut raw: Vec\u003cu8\u003e = vec![0x00, 0x00, 0x00, 0x00, 0x00];\n        raw.append(\u0026mut encoded);\n\n        let res = get_sut(raw_schema.to_string()).avro_to_json(\u0026raw[..]).await.unwrap();\n\n        assert_eq!(\n            res,\n            r#\"{\"boolean_field\":true,\"bytes_field\":[1,2,170],\"double_field\":12.12,\"float_field\":123.12300109863281,\"int_field\":12,\"long_field\":12345667,\"null_field\":null,\"string_field\":\"YO!! test\"}\"#\n        )\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":33,"coverable":86},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","avro","error.rs"],"content":"use crate::lib::schema_registry::SchemaRegistryError;\n\n#[derive(Debug, PartialEq)]\npub enum AvroError {\n    InvalidNumber(String),\n    MissingAvroSchemaReference(String),\n    MissingField(String),\n    SchemaProvider(String, SchemaRegistryError),\n    InvalidUnion(String),\n    Unsupported(String),\n    InvalidAvroHeader(String),\n    ParseAvroValue(String),\n    ParseJsonValue(String),\n    InvalidEnum(String),\n}\n\npub type AvroResult\u003cT\u003e = std::result::Result\u003cT, AvroError\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","avro","helpers.rs"],"content":"use super::error::{AvroError, AvroResult};\n\npub(super) fn get_schema_id_from_record_header(raw: \u0026[u8]) -\u003e AvroResult\u003ci32\u003e {\n    const AVRO_MAGIC_BYTE: u8 = 0x00;\n    if raw.len() \u003c= 5 || raw[0] != AVRO_MAGIC_BYTE {\n        return Err(AvroError::InvalidAvroHeader(\n            \"Supported avro messages should start with 0x00 follow by the schema id (4 bytes)\".into(),\n        ));\n    }\n    let arr = \u003c[u8; 4]\u003e::try_from(\u0026raw[1..5])\n        .map_err(|_| AvroError::InvalidAvroHeader(\"Invalid record. Unable to extract the schema id.\".into()))?;\n    Ok(i32::from_be_bytes(arr))\n}\n\npub(super) fn build_record_header(schema_id: i32) -\u003e Vec\u003cu8\u003e {\n    let mut res = vec![0x00];\n    let mut id = Vec::from(schema_id.to_be_bytes());\n    res.append(\u0026mut id);\n    res\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{build_record_header, get_schema_id_from_record_header};\n\n    #[test]\n    fn test_get_schema_id_from_raw() {\n        let raw: Vec\u003cu8\u003e = vec![0x00, 0x00, 0x01, 0x86, 0xc5, 0x00, 0x00, 0x00];\n        let id = get_schema_id_from_record_header(\u0026raw).unwrap();\n        assert_eq!(id, 100037)\n    }\n\n    #[test]\n    fn test_too_short_record_fails() {\n        let raw: Vec\u003cu8\u003e = vec![0x00, 0x00, 0x01, 0x86, 0xc5, 0x00, 0x00, 0x00];\n        let id = get_schema_id_from_record_header(\u0026raw).unwrap();\n        assert_eq!(id, 100037)\n    }\n\n    #[test]\n    fn test_missing_magic_byte_fails() {\n        let raw: Vec\u003cu8\u003e = vec![0x00, 0x00, 0x01, 0x86, 0xc5, 0x00, 0x00, 0x00];\n        let id = get_schema_id_from_record_header(\u0026raw).unwrap();\n        assert_eq!(id, 100037)\n    }\n\n    #[test]\n    fn build_record_header_happy_path() {\n        let raw = build_record_header(100037);\n        assert_eq!(raw, vec![0x00, 0x00, 0x01, 0x86, 0xc5])\n    }\n}\n","traces":[{"line":3,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":5,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":10,"coverable":12},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","avro","json_to_avro.rs"],"content":"use std::{collections::HashMap, str::FromStr};\n\nuse apache_avro::{schema::Name, to_avro_datum, types::Value as AvroValue, Schema};\nuse log::error;\n\nuse super::{\n    avro_parser::AvroParser, error::AvroResult, helpers::build_record_header, schema_provider::SchemaProvider, AvroError,\n};\nuse crate::lib::schema_registry::ResolvedAvroSchema;\nuse serde_json::Value as JsonValue;\n\nimpl\u003cS: SchemaProvider\u003e AvroParser\u003cS\u003e {\n    pub async fn json_to_avro(\u0026self, json: \u0026str, schema_name: \u0026str) -\u003e AvroResult\u003cVec\u003cu8\u003e\u003e {\n        let schema = self.schema_provider.get_schema_by_name(schema_name).await?;\n        Self::json_to_avro_with_schema(self, json, schema)\n    }\n\n    pub fn json_to_avro_with_schema(\u0026self, json: \u0026str, schema: ResolvedAvroSchema) -\u003e AvroResult\u003cVec\u003cu8\u003e\u003e {\n        let json_value = JsonValue::from_str(json).map_err(|err| AvroError::ParseJsonValue(err.to_string()))?;\n        let mut res = build_record_header(schema.schema_id);\n        let avro_value = json_to_avro_map(\u0026json_value, \u0026schema.schema, \u0026schema.resolved_schemas)?;\n        let mut avro_record = to_avro_datum(\u0026schema.schema, avro_value.clone()).map_err(|err| {\n            error!(\n                \"\\n\\tUnable to parse {:?}\\n\\tUsing schema: {:?}\\n\\tError: {:?}\",\n                avro_value, \u0026schema.schema, err\n            );\n            AvroError::ParseAvroValue(err.to_string())\n        })?;\n        res.append(\u0026mut avro_record);\n        Ok(res)\n    }\n}\n\nfn json_to_avro_map(j: \u0026JsonValue, s: \u0026Schema, ref_map: \u0026HashMap\u003cName, Schema\u003e) -\u003e AvroResult\u003cAvroValue\u003e {\n    match (\u0026s, j) {\n        // complex types\n        (Schema::Record { fields, .. }, JsonValue::Object(obj)) =\u003e map_json_fields_to_record(fields, obj, ref_map),\n        (Schema::Array(items_schema), JsonValue::Array(values)) =\u003e map_json_array_to_avro(values, items_schema, ref_map),\n        (Schema::Union(union_schema), JsonValue::Null) =\u003e {\n            let (position, _) = union_schema.find_schema(\u0026AvroValue::Null).ok_or_else(|| {\n                AvroError::InvalidUnion(format!(\n                    \"Cannot set null to the union. Supported options are: {:?}\",\n                    union_schema.variants()\n                ))\n            })?;\n            Ok(AvroValue::Union(position as u32, AvroValue::Null.into()))\n        }\n        (Schema::Union(union_schema), JsonValue::Object(obj)) =\u003e map_union(obj, union_schema, ref_map),\n        (Schema::Map(schema), JsonValue::Object(obj)) =\u003e {\n            let mut avro_map = HashMap::new();\n            for (key, value) in obj {\n                avro_map.insert(key.to_string(), json_to_avro_map(value, schema, ref_map)?);\n            }\n            Ok(AvroValue::Map(avro_map))\n        }\n        // simple types\n        (Schema::Null, JsonValue::Null) =\u003e Ok(AvroValue::Null),\n        (Schema::Boolean, JsonValue::Bool(v)) =\u003e Ok(AvroValue::Boolean(*v)),\n        (Schema::String, JsonValue::String(s)) =\u003e Ok(AvroValue::String(s.clone())),\n        (Schema::Enum { symbols, .. }, JsonValue::String(s)) =\u003e {\n            let (index, value) = symbols\n                .iter()\n                .enumerate()\n                .find(|(_, v)| v.to_string().eq(s))\n                .ok_or_else(|| AvroError::InvalidEnum(format!(\"Invalid enum {} expected one of {:?}\", s, symbols)))?;\n            Ok(AvroValue::Enum(index as u32, value.into()))\n        }\n        // numbers\n        (Schema::Int, JsonValue::Number(n)) =\u003e {\n            let n = n\n                .as_i64()\n                .and_then(|v| i32::try_from(v).ok())\n                .ok_or_else(|| AvroError::InvalidNumber(format!(\"Unable to convert {} to Int\", n)))?;\n            Ok(AvroValue::Int(n))\n        }\n        (Schema::Long, JsonValue::Number(n)) =\u003e {\n            let n = n\n                .as_i64()\n                .ok_or_else(|| AvroError::InvalidNumber(format!(\"Unable to convert {} to Long\", n)))?;\n            Ok(AvroValue::Long(n))\n        }\n        (Schema::Float, JsonValue::Number(n)) =\u003e {\n            let n = n\n                .as_f64()\n                .map(|v| v as f32)\n                .ok_or_else(|| AvroError::InvalidNumber(format!(\"Unable to convert {} to Float\", n)))?;\n            Ok(AvroValue::Float(n))\n        }\n        (Schema::Double, JsonValue::Number(n)) =\u003e {\n            let n = n\n                .as_f64()\n                .ok_or_else(|| AvroError::InvalidNumber(format!(\"Unable to convert {} to Double\", n)))?;\n            Ok(AvroValue::Double(n))\n        }\n        (Schema::Ref { name }, value) =\u003e {\n            let schema = ref_map.get(name).ok_or_else(|| {\n                AvroError::MissingAvroSchemaReference(format!(\"Unable to resolve reference {}\", name.to_string()))\n            })?;\n            json_to_avro_map(value, schema, ref_map)\n        }\n        // (\n        //     Schema::Decimal {\n        //         precision,\n        //         scale,\n        //         inner,\n        //     },\n        //     JsonValue::Number(n),\n        // ) =\u003e todo!(),\n\n        // Schema::Fixed { name, aliases, doc, size } =\u003e todo!(),\n        // Schema::Uuid =\u003e todo!(),\n        // // time\n        // Schema::Date =\u003e todo!(),\n        // Schema::TimeMillis =\u003e todo!(),\n        // Schema::TimeMicros =\u003e todo!(),\n        // Schema::TimestampMillis =\u003e todo!(),\n        // Schema::TimestampMicros =\u003e todo!(),\n        // Schema::Duration =\u003e todo!(),\n        // todo:\n        //(Schema::Bytes, JsonValue::String(s)) =\u003e todo!(),\n        (schema, value) =\u003e Err(AvroError::Unsupported(format!(\n            \"Unsupported Schema-JsonValue tuple: \\n\\n{:?}\\n\\n{:?}\",\n            schema, value\n        ))),\n    }\n}\n\nfn map_union(\n    obj: \u0026serde_json::Map\u003cString, JsonValue\u003e,\n    union_schema: \u0026apache_avro::schema::UnionSchema,\n    ref_map: \u0026HashMap\u003cName, Schema\u003e,\n) -\u003e Result\u003cAvroValue, AvroError\u003e {\n    let fields_vec: Vec\u003c(\u0026String, \u0026JsonValue)\u003e = obj.iter().collect();\n    if fields_vec.len() != 1 {\n        Err(AvroError::InvalidUnion(format!(\n            \"Invalid union. Expected one of: {:?}\",\n            union_schema.variants()\n        )))\n    } else {\n        let (union_branch_name, value) = *fields_vec.first().unwrap();\n        let index_schema = union_schema\n            .variants()\n            .iter()\n            .enumerate()\n            .find(|(_, s)| get_schema_name(s).eq(union_branch_name));\n        if let Some((index, current_schema)) = index_schema {\n            let value = json_to_avro_map(value, current_schema, ref_map)?;\n            Ok(AvroValue::Union(index as u32, value.into()))\n        } else {\n            Err(AvroError::InvalidUnion(format!(\n                \"Unsupported union specifier: {}\",\n                union_branch_name\n            )))\n        }\n    }\n}\n\nfn get_schema_name(s: \u0026Schema) -\u003e \u0026str {\n    match s {\n        Schema::Null =\u003e \"null\",\n        Schema::Boolean =\u003e \"boolean\",\n        Schema::Int =\u003e \"int\",\n        Schema::Long =\u003e \"long\",\n        Schema::Float =\u003e \"float\",\n        Schema::Double =\u003e \"double\",\n        Schema::Bytes =\u003e \"bytes\",\n        Schema::String =\u003e \"string\",\n        Schema::Record { name, .. } =\u003e \u0026name.name,\n        _ =\u003e {\n            //todo: support the other types\n            let message = format!(\"Unable to retrieve the name of the schema {:?}\", s);\n            error!(\"{}\", message);\n            panic!(\"{}\", message);\n        }\n    }\n}\n\nfn map_json_array_to_avro(\n    values: \u0026Vec\u003cJsonValue\u003e,\n    items_schema: \u0026Schema,\n    ref_map: \u0026HashMap\u003cName, Schema\u003e,\n) -\u003e Result\u003cAvroValue, AvroError\u003e {\n    let mut vec = vec![];\n    for value in values {\n        let avro_value = json_to_avro_map(value, items_schema, ref_map)?;\n        vec.push(avro_value);\n    }\n    Ok(AvroValue::Array(vec))\n}\n\nfn map_json_fields_to_record(\n    fields: \u0026Vec\u003capache_avro::schema::RecordField\u003e,\n    obj: \u0026serde_json::Map\u003cString, JsonValue\u003e,\n    ref_map: \u0026HashMap\u003cName, Schema\u003e,\n) -\u003e Result\u003cAvroValue, AvroError\u003e {\n    let mut record_fields: Vec\u003c(String, AvroValue)\u003e = vec![];\n    for field in fields {\n        let field_value = obj\n            .get(\u0026field.name)\n            .ok_or_else(|| AvroError::MissingField(field.name.clone()))?;\n        let avro_field = json_to_avro_map(field_value, \u0026field.schema, ref_map)?;\n        record_fields.push((field.name.clone(), avro_field));\n    }\n    Ok(AvroValue::Record(record_fields))\n}\n\n#[cfg(test)]\nmod tests {\n\n    use std::collections::BTreeMap;\n    use std::collections::HashMap;\n\n    use apache_avro::{schema::RecordField, Schema};\n\n    use super::map_json_fields_to_record;\n    use crate::lib::avro::AvroError;\n\n    use apache_avro::types::Value as AvroValue;\n    use serde_json::json;\n    use serde_json::Value as JsonValue;\n\n    #[test]\n    fn test_map_record() {\n        let obj = {\n            let mut obj_map = serde_json::Map::new();\n            obj_map.insert(\"sample\".to_string(), json!(1));\n            obj_map\n        };\n        let fields = vec![build_record_field(\"sample\", apache_avro::Schema::Int)];\n\n        // happy path\n        {\n            let res = map_json_fields_to_record(\u0026fields, \u0026obj, \u0026HashMap::new());\n            assert_eq!(\n                res,\n                Ok(AvroValue::Record(vec![(\"sample\".to_string(), AvroValue::Int(1))]))\n            );\n        }\n\n        // parse a json object with a missing field return an error\n        {\n            let fields = vec![\n                build_record_field(\"sample\", apache_avro::Schema::Int),\n                build_record_field(\"sample_2\", apache_avro::Schema::Int),\n            ];\n            let res = map_json_fields_to_record(\u0026fields, \u0026obj, \u0026HashMap::new());\n            assert_eq!(res, Err(AvroError::MissingField(\"sample_2\".into())))\n        }\n\n        // parse nested record\n        {\n            let obj_parent = {\n                let mut obj_map = serde_json::Map::new();\n                obj_map.insert(\"sample\".into(), json!(2));\n                obj_map.insert(\"nested\".into(), JsonValue::Object(obj));\n                obj_map\n            };\n            let nested_schema = Schema::Record {\n                name: \"Nested\".into(),\n                aliases: None,\n                doc: None,\n                fields: fields,\n                lookup: BTreeMap::\u003cString, usize\u003e::new(),\n            };\n            let fields = vec![\n                build_record_field(\"sample\", apache_avro::Schema::Int),\n                build_record_field(\"nested\", nested_schema),\n            ];\n            let res = map_json_fields_to_record(\u0026fields, \u0026obj_parent, \u0026HashMap::new());\n            assert_eq!(\n                res,\n                Ok(AvroValue::Record(vec![\n                    (\"sample\".to_string(), AvroValue::Int(2)),\n                    (\n                        \"nested\".to_string(),\n                        AvroValue::Record(vec![(\"sample\".into(), AvroValue::Int(1))])\n                    ),\n                ]))\n            );\n        }\n    }\n\n    fn build_record_field(name: \u0026str, schema: Schema) -\u003e RecordField {\n        RecordField {\n            name: name.into(),\n            doc: Default::default(),\n            default: Default::default(),\n            schema: schema,\n            order: apache_avro::schema::RecordFieldOrder::Ignore,\n            position: Default::default(),\n        }\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":16,"coverable":106},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","avro","mod.rs"],"content":"mod avro_parser;\nmod avro_to_json;\nmod error;\nmod helpers;\nmod json_to_avro;\nmod schema_provider;\n\npub use avro_parser::AvroParser;\npub use error::AvroError;\npub use schema_provider::SchemaProvider;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","avro","schema_provider.rs"],"content":"use async_trait::async_trait;\n\nuse crate::lib::schema_registry::{CachedSchemaRegistry, ResolvedAvroSchema};\n\nuse super::error::{AvroError, AvroResult};\n\n#[async_trait]\npub trait SchemaProvider: Send + Sync {\n    async fn get_schema_by_id(\u0026self, id: i32) -\u003e AvroResult\u003cResolvedAvroSchema\u003e;\n    async fn get_schema_by_name(\u0026self, name: \u0026str) -\u003e AvroResult\u003cResolvedAvroSchema\u003e;\n}\n\n#[async_trait]\nimpl SchemaProvider for CachedSchemaRegistry {\n    async fn get_schema_by_id(\u0026self, id: i32) -\u003e AvroResult\u003cResolvedAvroSchema\u003e {\n        self.get_schema_by_id(id)\n            .await\n            .map_err(|err| AvroError::SchemaProvider(format!(\"Unable to retrieve the schema id {}\", id), err))\n    }\n    async fn get_schema_by_name(\u0026self, name: \u0026str) -\u003e AvroResult\u003cResolvedAvroSchema\u003e {\n        self.get_last_schema(name)\n            .await\n            .map_err(|err| AvroError::SchemaProvider(format!(\"Unable to retrieve the schema {}\", name), err))\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":8},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","configuration","configuration_provider.rs"],"content":"use super::error::ConfigResult;\nuse super::legacy_config::LegacyConfiguration;\nuse super::store_types::StoreConfig;\nuse super::InsulatorConfig;\nuse dirs::home_dir;\nuse std::path::PathBuf;\nuse std::{fs, path::Path};\n\n#[derive(Default)]\npub struct ConfigurationProvider {\n    config_path: PathBuf,\n    legacy_config_path: PathBuf,\n}\n\nimpl ConfigurationProvider {\n    pub fn new() -\u003e Self {\n        let mut config_path = home_dir().expect(\"Unable to retrieve the home directory\");\n        let mut legacy_config_path = config_path.clone();\n        config_path.push(\".insulator2.toml\");\n        legacy_config_path.push(\".insulator.config\");\n        ConfigurationProvider {\n            config_path,\n            legacy_config_path,\n        }\n    }\n\n    pub fn get_configuration(\u0026self) -\u003e ConfigResult\u003cInsulatorConfig\u003e {\n        match Path::exists(\u0026self.config_path) {\n            // read file content\n            true =\u003e {\n                let raw_config = fs::read_to_string(\u0026self.config_path)?;\n                let conf = toml::from_str::\u003cStoreConfig\u003e(\u0026raw_config)?;\n                Ok(InsulatorConfig::from(conf))\n            }\n            // if the file doesn't exists return the default\n            false =\u003e {\n                match Path::exists(\u0026self.legacy_config_path) {\n                    true =\u003e {\n                        // try to import the legacy config\n                        let raw_config = fs::read_to_string(\u0026self.legacy_config_path)?;\n                        let legacy_config = serde_json::from_str::\u003cLegacyConfiguration\u003e(\u0026raw_config)?;\n                        Ok(InsulatorConfig::try_from(legacy_config)?)\n                    }\n                    false =\u003e Ok(InsulatorConfig::default()),\n                }\n            }\n        }\n    }\n\n    pub fn write_configuration(\u0026self, configuration: \u0026InsulatorConfig) -\u003e ConfigResult\u003c()\u003e {\n        // validate input\n        configuration.clusters.iter().for_each(|c| {\n            assert!(!c.endpoint.is_empty());\n            match \u0026c.schema_registry {\n                Some(s) =\u003e assert!(!s.endpoint.is_empty()),\n                None =\u003e {}\n            }\n        });\n        let as_store = StoreConfig::from(configuration);\n        let raw_config = toml::to_string_pretty(\u0026as_store)?;\n        fs::write(\u0026self.config_path, raw_config)?;\n        Ok(())\n    }\n\n    #[cfg(test)]\n    fn from_config_path(config_path: \u0026str) -\u003e Self {\n        ConfigurationProvider {\n            config_path: PathBuf::from(config_path),\n            legacy_config_path: PathBuf::from(config_path),\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use std::{env::temp_dir, fs};\n\n    use crate::lib::configuration::InsulatorConfig;\n\n    use super::ConfigurationProvider;\n\n    fn get_test_config_path() -\u003e String {\n        let mut dir = temp_dir();\n        dir.push(\"test_config\");\n        dir.to_str().unwrap().into()\n    }\n\n    #[test]\n    fn test_retrieve_config() {\n        let tmp_config_file = get_test_config_path();\n        let sut = ConfigurationProvider::from_config_path(\u0026tmp_config_file);\n\n        // retrieve config the first time returns the default\n        {\n            fs::remove_file(\u0026tmp_config_file).ok();\n            let res = sut.get_configuration();\n            assert!(res.is_ok());\n            assert_eq!(res.unwrap(), InsulatorConfig::default());\n        }\n    }\n\n    #[test]\n    fn test_write_config() {\n        // write a default config\n        {\n            let sut = ConfigurationProvider::from_config_path(\u0026get_test_config_path());\n            let res = sut.write_configuration(\u0026InsulatorConfig::default());\n            assert!(res.is_ok());\n        }\n        // write a config with a cluster authentication and schema registry\n        {\n            let mut config = InsulatorConfig::default();\n            config.clusters.push(crate::lib::configuration::ClusterConfig {\n                id: \"7213059c-c744-45ef-a380-3f6997b44377\".into(),\n                name: \"test_cluster\".into(),\n                endpoint: \"localhost:9092\".into(),\n                authentication: crate::lib::configuration::AuthenticationConfig::Sasl {\n                    username: \"test\".into(),\n                    password: \"test\".into(),\n                    scram: true,\n                },\n                schema_registry: Some(crate::lib::configuration::SchemaRegistryConfig {\n                    endpoint: \"endpoint\".into(),\n                    username: Some(\"username\".into()),\n                    password: Some(\"password\".into()),\n                }),\n                ..Default::default()\n            });\n            config.clusters.push(crate::lib::configuration::ClusterConfig {\n                id: \"1213059c-c744-45ef-a380-3f6997b44377\".into(),\n                name: \"test_cluster_2\".into(),\n                endpoint: \"localhost:9092\".into(),\n                authentication: crate::lib::configuration::AuthenticationConfig::None,\n                schema_registry: None,\n                ..Default::default()\n            });\n            let sut = ConfigurationProvider::from_config_path(\u0026get_test_config_path());\n            let res = sut.write_configuration(\u0026InsulatorConfig::default());\n            assert!(res.is_ok())\n        }\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":14,"coverable":29},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","configuration","error.rs"],"content":"#[derive(Debug)]\npub enum ConfigError {\n    IO(String),\n    JSONSerde(String),\n    TOMLSerde(String),\n    LegacyConfiguration(String),\n    ClusterNotFound(String),\n}\n\npub type ConfigResult\u003cT\u003e = Result\u003cT, ConfigError\u003e;\n\nimpl From\u003cstd::io::Error\u003e for ConfigError {\n    fn from(error: std::io::Error) -\u003e Self {\n        ConfigError::IO(error.to_string())\n    }\n}\n\nimpl From\u003cserde_json::Error\u003e for ConfigError {\n    fn from(error: serde_json::Error) -\u003e Self {\n        ConfigError::JSONSerde(error.to_string())\n    }\n}\n\nimpl From\u003ctoml::de::Error\u003e for ConfigError {\n    fn from(error: toml::de::Error) -\u003e Self {\n        ConfigError::TOMLSerde(error.to_string())\n    }\n}\n\nimpl From\u003ctoml::ser::Error\u003e for ConfigError {\n    fn from(error: toml::ser::Error) -\u003e Self {\n        ConfigError::TOMLSerde(error.to_string())\n    }\n}\n\nimpl From\u003crust_keystore::error::Error\u003e for ConfigError {\n    fn from(err: rust_keystore::error::Error) -\u003e Self {\n        Self::LegacyConfiguration(format!(\"{:?}\", err))\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":10},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","configuration","kafka_client_config.rs"],"content":"use rdkafka::ClientConfig;\n\nuse crate::lib::configuration::{AuthenticationConfig, ClusterConfig};\n\npub fn build_kafka_client_config(cluster: \u0026ClusterConfig, group_id: Option\u003c\u0026str\u003e) -\u003e ClientConfig {\n    let mut config = ClientConfig::new();\n    let group_id = group_id.unwrap_or(\"insulator-2\");\n    config\n        .set(\"bootstrap.servers\", \u0026cluster.endpoint)\n        .set(\"session.timeout.ms\", \"60_000\")\n        .set(\"enable.auto.commit\", \"false\")\n        .set(\"enable.auto.offset.store\", \"false\")\n        .set(\"offset.store.method\", \"broker\")\n        .set(\"group.id\", group_id)\n        .set(\"api.version.request\", \"true\")\n        .set(\"debug\", \"all\");\n    match \u0026cluster.authentication {\n        AuthenticationConfig::None =\u003e {\n            config.set(\"security.protocol\", \"PLAINTEXT\");\n        }\n        AuthenticationConfig::Sasl {\n            username,\n            password,\n            scram,\n        } =\u003e {\n            config\n                .set(\"security.protocol\", \"SASL_SSL\")\n                .set(\"sasl.mechanisms\", if *scram { \"SCRAM-SHA-256\" } else { \"PLAIN\" })\n                .set(\"ssl.endpoint.identification.algorithm\", \"https\")\n                .set(\"sasl.username\", username)\n                .set(\"sasl.password\", password);\n        }\n\n        AuthenticationConfig::Ssl {\n            ca,\n            certificate,\n            key,\n            key_password,\n        } =\u003e {\n            config\n                .set(\"security.protocol\", \"ssl\")\n                .set(\"ssl.ca.pem\", ca)\n                .set(\"ssl.certificate.pem\", certificate)\n                .set(\"ssl.key.pem\", key);\n\n            if let Some(password) = key_password {\n                config.set(\"ssl.key.password\", password);\n            }\n        }\n    }\n    config\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":8},"fn_name":null}],"covered":10,"coverable":29},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","configuration","legacy_config.rs"],"content":"use super::{\n    error::{ConfigError, ConfigResult},\n    AuthenticationConfig, ClusterConfig, InsulatorConfig, SchemaRegistryConfig, Theme,\n};\nuse log::{debug, warn};\nuse serde::Deserialize;\n\n// insulator v1 config\n#[derive(Debug, Default, Deserialize)]\npub(crate) struct LegacyConfiguration {\n    clusters: Vec\u003cLegacyCluster\u003e,\n    theme: Theme,\n}\n\n#[derive(Debug, Default, Deserialize)]\nstruct LegacyCluster {\n    pub guid: String,\n    pub name: String,\n    pub endpoint: String,\n\n    #[serde(rename = \"useSSL\")]\n    pub use_ssl: bool,\n    #[serde(rename = \"sslConfiguration\")]\n    pub ssl_configuration: Option\u003cSslConfigurationLegacy\u003e,\n\n    #[serde(rename = \"useSasl\")]\n    pub use_sasl: bool,\n    #[serde(rename = \"saslConfiguration\")]\n    pub sasl_configuration: Option\u003cSaslConfigurationLegacy\u003e,\n\n    #[serde(rename = \"schemaRegistryConfig\")]\n    schema_registry_config: Option\u003cSchemaRegistryConfigurationLegacy\u003e,\n}\n\n#[derive(Debug, Default, Deserialize)]\nstruct SslConfigurationLegacy {\n    #[serde(rename = \"sslTruststoreLocation\")]\n    pub ssl_truststore_location: Option\u003cString\u003e,\n    #[serde(rename = \"sslTruststorePassword\")]\n    pub ssl_truststore_password: Option\u003cString\u003e,\n    #[serde(rename = \"sslKeystoreLocation\")]\n    pub ssl_keystore_location: Option\u003cString\u003e,\n    #[serde(rename = \"sslKeyStorePassword\")]\n    pub ssl_keystore_password: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Default, Deserialize)]\nstruct SaslConfigurationLegacy {\n    #[serde(rename = \"saslUsername\")]\n    pub sasl_username: Option\u003cString\u003e,\n    #[serde(rename = \"saslPassword\")]\n    pub sasl_password: Option\u003cString\u003e,\n    #[serde(rename = \"useScram\")]\n    pub use_scram: Option\u003cbool\u003e,\n}\n\n#[derive(Debug, Default, Deserialize)]\nstruct SchemaRegistryConfigurationLegacy {\n    pub endpoint: Option\u003cString\u003e,\n    pub username: Option\u003cString\u003e,\n    pub password: Option\u003cString\u003e,\n}\n\nimpl TryFrom\u003cLegacyConfiguration\u003e for InsulatorConfig {\n    type Error = ConfigError;\n\n    fn try_from(legacy: LegacyConfiguration) -\u003e std::result::Result\u003cSelf, Self::Error\u003e {\n        let mut config = InsulatorConfig {\n            theme: legacy.theme,\n            clusters: vec![], //populated below\n            ..Default::default()\n        };\n        let mut clusters = Vec::new();\n        for c in legacy.clusters {\n            debug!(\"Parsing cluster {}\", c.name);\n            let schema_registry = c.schema_registry_config.and_then(map_schema_registry);\n            let authentication = if c.use_sasl \u0026\u0026 c.sasl_configuration.is_some() {\n                map_sasl_config(c.sasl_configuration.unwrap())\n            } else if c.use_ssl \u0026\u0026 c.ssl_configuration.is_some() {\n                map_ssl_config(c.ssl_configuration.unwrap())\n            } else {\n                Ok(AuthenticationConfig::None)\n            };\n            if let Ok(authentication) = authentication {\n                clusters.push(ClusterConfig {\n                    id: c.guid.clone(),\n                    name: c.name.clone(),\n                    endpoint: c.endpoint.clone().replace(\"https://\", \"\").replace(\"http://\", \"\"),\n                    authentication,\n                    schema_registry,\n                    ..Default::default()\n                });\n            } else {\n                warn!(\"Unable to parse cluster config. {:?}\", authentication);\n            }\n        }\n        config.clusters = clusters;\n        Ok(config)\n    }\n}\n\nfn map_sasl_config(legacy: SaslConfigurationLegacy) -\u003e ConfigResult\u003cAuthenticationConfig\u003e {\n    if let (Some(username), Some(password)) = (legacy.sasl_username, legacy.sasl_password) {\n        Ok(AuthenticationConfig::Sasl {\n            username,\n            password,\n            scram: legacy.use_scram.unwrap_or(false),\n        })\n    } else {\n        Err(ConfigError::LegacyConfiguration(\n            \"Invalid sasl configuration found. Username and password must be non-empty\".into(),\n        ))\n    }\n}\n\nfn map_ssl_config(legacy: SslConfigurationLegacy) -\u003e ConfigResult\u003cAuthenticationConfig\u003e {\n    if let (Some(truststore_location), Some(keystore_location)) =\n        (legacy.ssl_truststore_location, legacy.ssl_keystore_location)\n    {\n        debug!(\"Parsing truststore {}\", \u0026truststore_location);\n        let ca_certificate = \u0026rust_keystore::KeyStore::try_load(\u0026truststore_location)?\n            .certificates(legacy.ssl_truststore_password.as_deref())?[0];\n\n        debug!(\"Parsing keystore {}\", \u0026keystore_location);\n        let user_certificate = \u0026rust_keystore::KeyStore::try_load(\u0026keystore_location)?\n            .certificates(legacy.ssl_keystore_password.as_deref())?[0];\n\n        Ok(AuthenticationConfig::Ssl {\n            ca: ca_certificate.pem.clone(),\n            certificate: user_certificate.pem.clone(),\n            key: user_certificate\n                .private_key\n                .as_ref()\n                .ok_or_else(|| ConfigError::LegacyConfiguration(\"Unable to parse the keystore\".into()))?\n                .pkcs8_pem\n                .clone(),\n            key_password: None,\n        })\n    } else {\n        Err(ConfigError::LegacyConfiguration(\n            \"Invalid ssl configuration found. truststore and keystore locations are required\".into(),\n        ))\n    }\n}\n\nfn map_schema_registry(legacy: SchemaRegistryConfigurationLegacy) -\u003e Option\u003cSchemaRegistryConfig\u003e {\n    if let Some(endpoint) = legacy.endpoint {\n        Some(SchemaRegistryConfig {\n            endpoint,\n            username: legacy.username.filter(|s| !s.is_empty()),\n            password: legacy.password.filter(|s| !s.is_empty()),\n        })\n    } else {\n        None\n    }\n}\n","traces":[{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":54},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","configuration","mod.rs"],"content":"mod configuration_provider;\nmod error;\nmod kafka_client_config;\nmod legacy_config;\nmod store_types;\nmod types;\n\npub use configuration_provider::ConfigurationProvider;\npub use error::*;\npub use kafka_client_config::build_kafka_client_config;\npub use types::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","configuration","store_types.rs"],"content":"use std::collections::HashMap;\n\nuse serde::{Deserialize, Serialize};\n\nuse super::{AuthenticationConfig, ClusterConfig, Favorites, InsulatorConfig, SchemaRegistryConfig, Theme};\n\n#[derive(Serialize, Deserialize, Debug, Default, PartialEq, Eq)]\npub struct StoreConfig {\n    pub theme: Theme,\n    #[serde(rename = \"showNotifications\")]\n    pub show_notifications: bool,\n    #[serde(rename = \"useRegex\")]\n    pub use_regex: bool,\n    #[serde(rename = \"sqlTimeoutSeconds\")]\n    pub sql_timeout_secs: Option\u003cu32\u003e,\n    #[serde(rename = \"kafkaTimeoutSeconds\")]\n    pub kafka_timeout_secs: Option\u003cu32\u003e,\n    pub clusters: HashMap\u003cString, StoreCluster\u003e,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone, Default, PartialEq, Eq)]\npub struct StoreCluster {\n    pub name: String,\n    pub endpoint: String,\n    pub authentication: StoreAuthentication,\n    #[serde(rename = \"schemaRegistry\")]\n    pub schema_registry: Option\u003cSchemaRegistryConfig\u003e,\n    pub favorites: Option\u003cFavorites\u003e,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone, Default, PartialEq, Eq)]\n#[serde(tag = \"type\")]\npub enum StoreAuthentication {\n    Ssl {\n        ca: String,\n        certificate: String,\n        key: String,\n        #[serde(rename = \"keyPassword\")]\n        key_password: Option\u003cString\u003e,\n    },\n    Sasl {\n        username: String,\n        password: String,\n        scram: bool,\n    },\n    #[default]\n    None,\n}\n\nimpl From\u003cStoreAuthentication\u003e for AuthenticationConfig {\n    fn from(s: StoreAuthentication) -\u003e Self {\n        match s {\n            StoreAuthentication::Ssl {\n                ca,\n                certificate,\n                key,\n                key_password,\n            } =\u003e AuthenticationConfig::Ssl {\n                ca,\n                certificate,\n                key,\n                key_password,\n            },\n            StoreAuthentication::Sasl {\n                username,\n                password,\n                scram,\n            } =\u003e AuthenticationConfig::Sasl {\n                username,\n                password,\n                scram,\n            },\n            StoreAuthentication::None =\u003e AuthenticationConfig::None,\n        }\n    }\n}\n\nfn store_cluster_to_config(id: String, store: StoreCluster) -\u003e ClusterConfig {\n    ClusterConfig {\n        id,\n        name: store.name,\n        endpoint: store.endpoint,\n        authentication: store.authentication.into(),\n        schema_registry: store.schema_registry,\n        favorites: store.favorites.unwrap_or_default(),\n    }\n}\n\nimpl From\u003cStoreConfig\u003e for InsulatorConfig {\n    fn from(\n        StoreConfig {\n            theme,\n            show_notifications,\n            use_regex,\n            clusters,\n            sql_timeout_secs,\n            kafka_timeout_secs,\n        }: StoreConfig,\n    ) -\u003e Self {\n        let converted_clusters = clusters\n            .into_iter()\n            .map(|(id, c)| store_cluster_to_config(id, c))\n            .collect();\n        InsulatorConfig {\n            theme,\n            show_notifications,\n            use_regex,\n            sql_timeout_secs: sql_timeout_secs.unwrap_or(10),\n            kafka_timeout_secs: kafka_timeout_secs.unwrap_or(15),\n            clusters: converted_clusters,\n        }\n    }\n}\n\nimpl From\u003cAuthenticationConfig\u003e for StoreAuthentication {\n    fn from(authentication_config: AuthenticationConfig) -\u003e Self {\n        match authentication_config {\n            AuthenticationConfig::Ssl {\n                ca,\n                certificate,\n                key,\n                key_password,\n            } =\u003e StoreAuthentication::Ssl {\n                ca,\n                certificate,\n                key,\n                key_password,\n            },\n            AuthenticationConfig::Sasl {\n                username,\n                password,\n                scram,\n            } =\u003e StoreAuthentication::Sasl {\n                username,\n                password,\n                scram,\n            },\n            AuthenticationConfig::None =\u003e StoreAuthentication::None,\n        }\n    }\n}\n\nimpl From\u003cClusterConfig\u003e for StoreCluster {\n    fn from(config: ClusterConfig) -\u003e Self {\n        StoreCluster {\n            name: config.name,\n            endpoint: config.endpoint,\n            authentication: config.authentication.into(),\n            schema_registry: config.schema_registry,\n            favorites: Some(config.favorites),\n        }\n    }\n}\n\nimpl From\u003c\u0026InsulatorConfig\u003e for StoreConfig {\n    fn from(config: \u0026InsulatorConfig) -\u003e Self {\n        StoreConfig {\n            theme: config.theme,\n            show_notifications: config.show_notifications,\n            use_regex: config.use_regex,\n            sql_timeout_secs: Some(config.sql_timeout_secs),\n            kafka_timeout_secs: Some(config.kafka_timeout_secs),\n            clusters: config\n                .clusters\n                .clone()\n                .into_iter()\n                .map(|c| (c.id.clone(), c.into()))\n                .collect(),\n        }\n    }\n}\n","traces":[{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":7,"coverable":44},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","configuration","types.rs"],"content":"use std::time::Duration;\n\nuse serde::{Deserialize, Serialize};\n\nuse super::error::{ConfigError, ConfigResult};\n\n#[derive(Serialize, Deserialize, Debug, PartialEq, Eq, Clone)]\npub struct InsulatorConfig {\n    pub theme: Theme,\n    #[serde(rename = \"showNotifications\")]\n    pub show_notifications: bool,\n    #[serde(rename = \"useRegex\")]\n    pub use_regex: bool,\n    #[serde(rename = \"sqlTimeoutSeconds\")]\n    pub sql_timeout_secs: u32,\n    #[serde(rename = \"kafkaTimeoutSeconds\")]\n    pub kafka_timeout_secs: u32,\n    pub clusters: Vec\u003cClusterConfig\u003e,\n}\n\nimpl InsulatorConfig {\n    pub fn get_kafka_tmo(\u0026self) -\u003e Duration {\n        Duration::from_secs(self.kafka_timeout_secs as u64)\n    }\n    pub fn get_sql_tmo(\u0026self) -\u003e Duration {\n        Duration::from_secs(self.sql_timeout_secs as u64)\n    }\n    pub fn get_cluster_config(\u0026self, cluster_id: \u0026str) -\u003e ConfigResult\u003cClusterConfig\u003e {\n        self.clusters\n            .iter()\n            .find(|c| c.id == cluster_id)\n            .cloned()\n            .ok_or_else(|| ConfigError::ClusterNotFound(cluster_id.to_string()))\n    }\n}\n\nimpl Default for InsulatorConfig {\n    fn default() -\u003e Self {\n        Self {\n            show_notifications: true,\n            use_regex: true,\n            sql_timeout_secs: 10,\n            clusters: vec![],\n            kafka_timeout_secs: 20,\n            theme: Theme::Dark,\n        }\n    }\n}\n\n#[derive(Serialize, Deserialize, Debug, PartialEq, Eq, Default, Clone, Copy)]\npub enum Theme {\n    #[default]\n    Dark,\n    Light,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone, Default, PartialEq, Eq)]\npub struct ClusterConfig {\n    pub id: String,\n    pub name: String,\n    pub endpoint: String,\n    pub authentication: AuthenticationConfig,\n    #[serde(rename = \"schemaRegistry\")]\n    pub schema_registry: Option\u003cSchemaRegistryConfig\u003e,\n    pub favorites: Favorites,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone, Default, PartialEq, Eq)]\npub enum AuthenticationConfig {\n    Ssl {\n        ca: String,\n        certificate: String,\n        key: String,\n        #[serde(rename = \"keyPassword\")]\n        key_password: Option\u003cString\u003e,\n    },\n    Sasl {\n        username: String,\n        password: String,\n        scram: bool,\n    },\n    #[default]\n    None,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]\npub struct SchemaRegistryConfig {\n    pub endpoint: String,\n    pub username: Option\u003cString\u003e,\n    pub password: Option\u003cString\u003e,\n}\n\n#[derive(Serialize, Deserialize, Debug, Default, Clone, PartialEq, Eq)]\npub struct Favorites {\n    pub topics: Vec\u003cString\u003e,\n    pub schemas: Vec\u003cString\u003e,\n    pub consumers: Vec\u003cString\u003e,\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":5},"fn_name":null}],"covered":2,"coverable":10},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","consumer","client.rs"],"content":"use crate::lib::{\n    configuration::{build_kafka_client_config, ClusterConfig},\n    consumer::types::{ConsumerConfiguration, ConsumerSessionConfiguration, ConsumerState},\n    error_callback::ErrorCallback,\n    record_store::TopicStore,\n    types::RawKafkaRecord,\n};\nuse futures::{lock::Mutex, StreamExt};\nuse log::{debug, error, warn};\nuse rdkafka::{\n    consumer::{Consumer as ApacheKafkaConsumer, StreamConsumer},\n    message::OwnedMessage,\n    Message, Offset, TopicPartitionList,\n};\nuse std::{sync::Arc, time::Duration};\nuse tauri::async_runtime::JoinHandle;\n\nuse super::error::{ConsumerError, ConsumerResult};\n\npub struct KafkaConsumer {\n    cluster_config: ClusterConfig,\n    topic: String,\n    loop_handle: Arc\u003cMutex\u003cOption\u003cJoinHandle\u003c()\u003e\u003e\u003e\u003e,\n    error_callback: ErrorCallback\u003cConsumerError\u003e,\n    pub topic_store: Arc\u003cTopicStore\u003e,\n    timeout: Duration,\n}\n\nimpl KafkaConsumer {\n    pub fn new(\n        cluster_config: \u0026ClusterConfig,\n        topic: \u0026str,\n        topic_store: TopicStore,\n        error_cb: ErrorCallback\u003cConsumerError\u003e,\n        timeout: Duration,\n    ) -\u003e Self {\n        KafkaConsumer {\n            error_callback: error_cb,\n            cluster_config: cluster_config.clone(),\n            topic: topic.to_string(),\n            loop_handle: Arc::new(Mutex::new(None)),\n            topic_store: Arc::new(topic_store),\n            timeout,\n        }\n    }\n\n    pub fn update_consumer_assignment(\n        consumer: \u0026rdkafka::consumer::StreamConsumer,\n        topics: \u0026[\u0026str],\n        config: \u0026ConsumerSessionConfiguration,\n        tmo: Duration,\n    ) -\u003e ConsumerResult\u003c()\u003e {\n        let metadata = consumer.fetch_metadata(if topics.len() == 1 { Some(topics[0]) } else { None }, tmo)?;\n        let topic_partition: Vec\u003c_\u003e = metadata\n            .topics()\n            .iter()\n            .filter(|t| topics.contains(\u0026t.name()))\n            .flat_map(|t| t.partitions().iter().map(|p| (t.name(), p.id())))\n            .collect();\n\n        let mut timestamp_assignment = consumer.assignment()?;\n        match config {\n            ConsumerSessionConfiguration::Beginning =\u003e {\n                for (t, p) in topic_partition {\n                    timestamp_assignment.add_partition_offset(t, p, Offset::Beginning)?;\n                }\n            }\n            ConsumerSessionConfiguration::End =\u003e {\n                for (t, p) in topic_partition {\n                    timestamp_assignment.add_partition_offset(t, p, Offset::End)?;\n                }\n            }\n            ConsumerSessionConfiguration::Custom {\n                start_timestamp,\n                stop_timestamp: _,\n            } =\u003e {\n                // note: the offsets_for_times function takes a TopicPartitionList in which the\n                // offset is the timestamp in ms (instead of the actual offset) and returns a\n                // new TopicPartitionList with the actual offset\n                for (t, p) in topic_partition {\n                    timestamp_assignment.add_partition_offset(t, p, Offset::Offset(*start_timestamp))?;\n                }\n            }\n        }\n        let assignment = consumer.offsets_for_times(timestamp_assignment, tmo)?;\n        consumer.assign(\u0026assignment)?;\n        debug!(\"Partition assigned {:?}\", assignment);\n        Ok(())\n    }\n\n    pub async fn start(\u0026self, consumer_config: \u0026ConsumerConfiguration) -\u003e ConsumerResult\u003c()\u003e {\n        let topic = self.topic.clone();\n        if self.loop_handle.lock().await.is_some() {\n            warn!(\"Try to start an already running consumer\");\n            return Err(ConsumerError::AlreadyRunning(format!(\n                \"A consumer is already running for {}\",\n                topic\n            )));\n        }\n        // set the handle to the consumer loop\n        *self.loop_handle.clone().lock().await = Some(tauri::async_runtime::spawn({\n            // clone arcs for the closure below\n            let consumer: StreamConsumer = build_kafka_client_config(\u0026self.cluster_config, None)\n                .create()\n                .expect(\"Unable to create kafka the consumer\");\n\n            // configure the consumer\n            if let Err(err) = KafkaConsumer::update_consumer_assignment(\n                \u0026consumer,\n                \u0026[\u0026topic],\n                \u0026consumer_config.consumer_start_config,\n                self.timeout,\n            ) {\n                error!(\"{:?}\", err);\n                (self.error_callback)(err);\n                panic!(\"Unable to continue\");\n            }\n\n            let loop_handle = self.loop_handle.clone();\n            let topic_store = self.topic_store.clone();\n            let consumer_config = consumer_config.clone();\n            let error_callback = self.error_callback.clone();\n            async move { consumer_loop(\u0026consumer, \u0026consumer_config, \u0026topic_store, \u0026error_callback, loop_handle).await }\n        }));\n        Ok(())\n    }\n\n    pub async fn stop(\u0026self) -\u003e ConsumerResult\u003c()\u003e {\n        _stop(self.loop_handle.clone()).await\n    }\n\n    pub async fn get_consumer_state(\u0026self) -\u003e ConsumerResult\u003cConsumerState\u003e {\n        Ok(ConsumerState {\n            is_running: self.loop_handle.clone().lock().await.is_some(),\n            record_count: self\n                .topic_store\n                .get_records_count()\n                .map_err(|err| ConsumerError::RecordStore(\"Unable to retrieve the records count\".into(), err))?,\n        })\n    }\n}\n\nfn get_stop_timestamp(consumer_config: \u0026ConsumerConfiguration) -\u003e Option\u003cu64\u003e {\n    // retrieve the stop timestamp if specified\n    if let ConsumerSessionConfiguration::Custom {\n        stop_timestamp: Some(stop),\n        ..\n    } = \u0026consumer_config.consumer_start_config\n    {\n        Some(*stop as u64)\n    } else {\n        None\n    }\n}\n\nasync fn consumer_loop(\n    consumer: \u0026StreamConsumer,\n    consumer_config: \u0026ConsumerConfiguration,\n    topic_store: \u0026TopicStore,\n    error_callback: \u0026ErrorCallback\u003cConsumerError\u003e,\n    loop_handle: Arc\u003cMutex\u003cOption\u003cJoinHandle\u003c()\u003e\u003e\u003e\u003e,\n) {\n    let stop_timestamp = get_stop_timestamp(consumer_config);\n\n    // setup a new store\n    topic_store\n        .setup(consumer_config.compactify)\n        .expect(\"Unable to create the internal store\");\n\n    // infinite consumer loop\n    debug!(\"Start consumer loop\");\n    loop {\n        match consumer.stream().next().await {\n            Some(Ok(msg)) =\u003e {\n                handle_consumed_message(\u0026msg.detach(), topic_store, stop_timestamp, consumer, error_callback).await;\n            }\n            Some(Err(err)) =\u003e {\n                error!(\"An error occurs consuming from kafka: {}\", err);\n                error_callback(err.into());\n                _stop(loop_handle.clone()).await.expect(\"Unable to stop the consumer\");\n                break;\n            }\n            None =\u003e {\n                error!(\"Consumer unexpectedly returned no messages\");\n                break;\n            }\n        }\n    }\n}\n\nasync fn handle_consumed_message(\n    msg: \u0026OwnedMessage,\n    topic_store: \u0026TopicStore,\n    stop_timestamp: Option\u003cu64\u003e,\n    consumer: \u0026StreamConsumer,\n    error_callback: \u0026ErrorCallback\u003cConsumerError\u003e,\n) {\n    let record = map_kafka_record(msg);\n    if record.timestamp.unwrap_or(u64::MIN) \u003c stop_timestamp.unwrap_or(u64::MAX) {\n        topic_store.insert_record(\u0026record).await.unwrap_or_else(|err| {\n            error_callback(ConsumerError::RecordStore(\n                \"Unable to store the record\".to_string(),\n                err,\n            ))\n        });\n    } else {\n        // pause consumption on the record partition\n        let mut tpl = TopicPartitionList::new();\n        tpl.add_partition(\u0026record.topic, record.partition);\n        match consumer.pause(\u0026tpl) {\n            Ok(_) =\u003e {\n                debug!(\"Pause consuming {} partition {}\", record.topic, record.partition);\n            }\n            Err(err) =\u003e error!(\n                \"Unable to pause consuming {} partition {}: {:?}\",\n                record.topic, record.partition, err\n            ),\n        }\n    }\n}\n\nasync fn _stop(loop_handle: Arc\u003cMutex\u003cOption\u003cJoinHandle\u003c()\u003e\u003e\u003e\u003e) -\u003e ConsumerResult\u003c()\u003e {\n    debug!(\"Consumer stopped\");\n    if let Some(handle) = \u0026*loop_handle.lock().await {\n        handle.abort();\n    }\n    *loop_handle.lock().await = None;\n    Ok(())\n}\n\nfn map_kafka_record(msg: \u0026OwnedMessage) -\u003e RawKafkaRecord {\n    RawKafkaRecord {\n        payload: msg.payload().map(|v| v.to_owned()),\n        key: msg.key().map(|v| v.to_owned()),\n        topic: msg.topic().into(),\n        partition: msg.partition(),\n        offset: msg.offset(),\n        timestamp: msg.timestamp().to_millis().map(|v| v as u64),\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":13,"coverable":101},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","consumer","error.rs"],"content":"use rdkafka::error::KafkaError;\n\n#[derive(Debug)]\npub enum ConsumerError {\n    RDKafka(String),\n    RecordStore(String, crate::lib::record_store::StoreError),\n    AlreadyRunning(String),\n}\npub type ConsumerResult\u003cT\u003e = Result\u003cT, ConsumerError\u003e;\n\nimpl From\u003cKafkaError\u003e for ConsumerError {\n    fn from(error: KafkaError) -\u003e Self {\n        ConsumerError::RDKafka(error.to_string())\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","consumer","mod.rs"],"content":"mod client;\nmod error;\npub mod types;\npub use client::KafkaConsumer;\npub use error::ConsumerError;\npub use types::ConsumerConfiguration;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","consumer","types.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct ConsumerConfiguration {\n    pub compactify: bool,\n    pub consumer_start_config: ConsumerSessionConfiguration,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub enum ConsumerSessionConfiguration {\n    Beginning,\n    End,\n    Custom {\n        start_timestamp: i64,        //time in ms\n        stop_timestamp: Option\u003ci64\u003e, //time in ms\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone)]\npub struct ConsumerState {\n    #[serde(rename = \"isRunning\")]\n    pub is_running: bool,\n    #[serde(rename = \"recordCount\")]\n    pub record_count: usize,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","error_callback.rs"],"content":"use std::sync::Arc;\n\npub type ErrorCallback\u003cT\u003e = Arc\u003cdyn Fn(T) + Send + Sync\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","mod.rs"],"content":"pub mod admin;\npub mod avro;\npub mod configuration;\npub mod consumer;\npub mod parser;\n\npub mod error_callback;\npub mod producer;\npub mod record_store;\npub mod schema_registry;\npub mod types;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","parser","error.rs"],"content":"use crate::lib::avro::AvroError;\n\npub enum ParserError {\n    MissingAvroConfiguration,\n    Avro(AvroError),\n}\n\npub type ParserResult\u003cT\u003e = Result\u003cT, ParserError\u003e;\n\nimpl From\u003cAvroError\u003e for ParserError {\n    fn from(value: AvroError) -\u003e Self {\n        ParserError::Avro(value)\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","parser","mod.rs"],"content":"mod error;\nmod string_parser;\n\nuse std::sync::Arc;\n\nuse crate::lib::{\n    avro::{AvroParser, SchemaProvider},\n    schema_registry::CachedSchemaRegistry,\n    types::{ParsedKafkaRecord, RawKafkaRecord},\n};\n\nuse string_parser::parse_string;\n\npub use self::error::ParserError;\nuse self::error::ParserResult;\n\nuse super::types::ParserMode;\n\npub struct Parser\u003cC: SchemaProvider = CachedSchemaRegistry\u003e {\n    avro_parser: Option\u003cAvroParser\u003cC\u003e\u003e,\n}\n\nimpl\u003cC: SchemaProvider\u003e Parser\u003cC\u003e {\n    pub fn new(schema_registry_client: Option\u003cArc\u003cC\u003e\u003e) -\u003e Self {\n        Parser {\n            avro_parser: schema_registry_client.map(|client| AvroParser::new(client)),\n        }\n    }\n\n    pub async fn parse_from_kafka_record(\n        \u0026self,\n        record: \u0026RawKafkaRecord,\n        mode: ParserMode,\n    ) -\u003e ParserResult\u003cParsedKafkaRecord\u003e {\n        let RawKafkaRecord {\n            payload,\n            key,\n            topic,\n            timestamp,\n            partition,\n            offset,\n        } = record.clone();\n        let (key, payload) = match mode {\n            ParserMode::String =\u003e (key.map(|v| parse_string(\u0026v)), payload.map(|v| parse_string(\u0026v))),\n            ParserMode::Avro =\u003e {\n                let avro_parser = self.avro_parser.as_ref().ok_or(ParserError::MissingAvroConfiguration)?;\n                (\n                    key.map(|v| parse_string(\u0026v)),\n                    match payload {\n                        Some(v) =\u003e Some(avro_parser.avro_to_json(\u0026v).await?),\n                        None =\u003e None,\n                    },\n                )\n            }\n        };\n        Ok(ParsedKafkaRecord {\n            key,\n            payload,\n            topic,\n            timestamp,\n            partition,\n            offset,\n        })\n    }\n\n    pub async fn parse_payload_to_avro(\u0026self, payload: \u0026str, topic_name: \u0026str) -\u003e ParserResult\u003cVec\u003cu8\u003e\u003e {\n        if let Some(avro_parser) = self.avro_parser.as_ref() {\n            Ok(avro_parser\n                .json_to_avro(payload, \u0026format!(\"{}-value\", topic_name))\n                .await?)\n        } else {\n            Err(ParserError::MissingAvroConfiguration)\n        }\n    }\n\n    pub fn parse_payload_to_string(\u0026self, payload: \u0026str) -\u003e Vec\u003cu8\u003e {\n        payload.as_bytes().into()\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":34},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","parser","string_parser.rs"],"content":"pub(super) fn parse_string(v: \u0026[u8]) -\u003e String {\n    String::from_utf8_lossy(v).into_owned()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::parse_string;\n\n    #[test]\n    fn parse_empty_array_to_string() {\n        let vec = vec![];\n        let res = parse_string(\u0026vec);\n        assert_eq!(res, \"\")\n    }\n\n    #[test]\n    fn parse_invalid_to_string() {\n        let vec: Vec\u003cu8\u003e = vec![0x00, 0x41, 0xff];\n        let res = parse_string(\u0026vec);\n        assert!(!res.is_empty())\n    }\n}\n","traces":[{"line":1,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":2,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","producer","client.rs"],"content":"use std::sync::Arc;\n\nuse rdkafka::producer::{BaseProducer, BaseRecord};\n\nuse crate::lib::{\n    configuration::{build_kafka_client_config, ClusterConfig},\n    parser::Parser,\n    types::ParserMode,\n};\n\nuse super::{error::ProducerResult, record_parser::KafkaRecordParser};\n\npub struct KafkaProducer\u003cP: KafkaRecordParser = Parser\u003e {\n    producer: BaseProducer,\n    parser: Arc\u003cP\u003e,\n}\n\nimpl\u003cP: KafkaRecordParser\u003e KafkaProducer\u003cP\u003e {\n    pub fn new(cluster_config: \u0026ClusterConfig, parser: Arc\u003cP\u003e) -\u003e Self {\n        let producer: BaseProducer = build_kafka_client_config(cluster_config, None)\n            .create()\n            .expect(\"Unable to create the consumer\"); //todo: bubble up the error\n        Self { producer, parser }\n    }\n    // Use a None value for tombstones\n    pub async fn produce(\u0026self, topic: \u0026str, key: \u0026str, value: Option\u003c\u0026str\u003e, mode: ParserMode) -\u003e ProducerResult\u003c()\u003e {\n        let mut record = BaseRecord::to(topic).key(key);\n        let payload = if let Some(payload) = value {\n            match mode {\n                ParserMode::String =\u003e Some(self.parser.parse_to_string(payload)),\n                ParserMode::Avro =\u003e Some(self.parser.parse_to_avro(payload, topic).await?),\n            }\n        } else {\n            None\n        };\n        if let Some(value) = payload {\n            record = record.payload(\u0026value);\n            Ok(self.producer.send(record).map_err(|err| err.0)?)\n        } else {\n            Ok(self.producer.send(record).map_err(|err| err.0)?)\n        }\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":13},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","producer","error.rs"],"content":"use rdkafka::error::KafkaError;\n\nuse crate::lib::parser::ParserError;\n\npub enum ProducerError {\n    MissingAvroConfiguration,\n    RDKafka(String),\n    AvroParse(crate::lib::avro::AvroError),\n}\n\npub type ProducerResult\u003cT\u003e = Result\u003cT, ProducerError\u003e;\n\nimpl From\u003cKafkaError\u003e for ProducerError {\n    fn from(error: KafkaError) -\u003e Self {\n        ProducerError::RDKafka(error.to_string())\n    }\n}\n\nimpl From\u003cParserError\u003e for ProducerError {\n    fn from(value: ParserError) -\u003e Self {\n        match value {\n            ParserError::MissingAvroConfiguration =\u003e ProducerError::MissingAvroConfiguration,\n            ParserError::Avro(err) =\u003e ProducerError::AvroParse(err),\n        }\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":6},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","producer","mod.rs"],"content":"mod client;\nmod error;\nmod record_parser;\npub use client::KafkaProducer;\npub use error::ProducerError;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","producer","record_parser.rs"],"content":"use async_trait::async_trait;\n\nuse crate::lib::parser::Parser;\n\nuse super::error::ProducerResult;\n\n#[async_trait]\npub trait KafkaRecordParser {\n    fn parse_to_string(\u0026self, payload: \u0026str) -\u003e Vec\u003cu8\u003e;\n    async fn parse_to_avro(\u0026self, payload: \u0026str, topic_name: \u0026str) -\u003e ProducerResult\u003cVec\u003cu8\u003e\u003e;\n}\n\n#[async_trait]\nimpl KafkaRecordParser for Parser {\n    fn parse_to_string(\u0026self, payload: \u0026str) -\u003e Vec\u003cu8\u003e {\n        self.parse_payload_to_string(payload)\n    }\n    async fn parse_to_avro(\u0026self, payload: \u0026str, topic_name: \u0026str) -\u003e ProducerResult\u003cVec\u003cu8\u003e\u003e {\n        Ok(self.parse_payload_to_avro(payload, topic_name).await?)\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","record_store","error.rs"],"content":"use rusqlite::{ffi, Error as SqlError};\n\n#[derive(Debug, PartialEq, Eq)]\npub enum StoreError {\n    SqlError(String),\n    IO(String),\n    RecordParse(String),\n}\n\npub type StoreResult\u003cT\u003e = Result\u003cT, StoreError\u003e;\n\nimpl From\u003cSqlError\u003e for StoreError {\n    fn from(error: SqlError) -\u003e Self {\n        StoreError::SqlError(match error {\n            SqlError::SqliteFailure(ffi::Error { code, .. }, ..) =\u003e match code {\n                rusqlite::ErrorCode::OperationInterrupted =\u003e \"Operation timed out\".into(),\n                _ =\u003e format!(\"{} {:?}\", error, code),\n            },\n            _ =\u003e error.to_string(),\n        })\n    }\n}\nimpl From\u003cstd::io::Error\u003e for StoreError {\n    fn from(error: std::io::Error) -\u003e Self {\n        StoreError::IO(error.to_string())\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":6,"coverable":8},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","record_store","mod.rs"],"content":"mod error;\nmod query;\nmod record_parser;\nmod sqlite_store;\nmod topic_store;\npub mod types;\n\npub use error::StoreError;\npub use sqlite_store::SqliteStore;\npub use topic_store::TopicStore;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","record_store","query.rs"],"content":"#[derive(Debug)]\npub struct Query {\n    pub cluster_id: String,\n    pub topic_name: String,\n    pub offset: i64,\n    pub limit: i64,\n    pub query_template: String,\n}\n\nimpl Query {\n    pub const SELECT_WITH_OFFSET_LIMIT_QUERY : \u0026str = \"SELECT partition, offset, timestamp, key, payload FROM {:topic} ORDER BY timestamp desc LIMIT {:limit} OFFSET {:offset}\";\n\n    #[cfg(test)]\n    pub fn select_any(cluster_id: \u0026str, topic_name: \u0026str, offset: i64, limit: i64) -\u003e Query {\n        Query {\n            cluster_id: cluster_id.into(),\n            topic_name: topic_name.into(),\n            limit,\n            offset,\n            query_template: Query::SELECT_WITH_OFFSET_LIMIT_QUERY.into(),\n        }\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":8},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","record_store","record_parser.rs"],"content":"use async_trait::async_trait;\n\nuse crate::lib::{\n    parser::Parser,\n    types::{ParsedKafkaRecord, ParserMode, RawKafkaRecord},\n};\n\nuse super::error::{StoreError, StoreResult};\n\n#[async_trait]\npub trait KafkaRecordParser {\n    async fn parse_kafka_record(\u0026self, record: \u0026RawKafkaRecord) -\u003e StoreResult\u003cParsedKafkaRecord\u003e;\n}\n\n#[async_trait]\nimpl KafkaRecordParser for Parser {\n    async fn parse_kafka_record(\u0026self, record: \u0026RawKafkaRecord) -\u003e StoreResult\u003cParsedKafkaRecord\u003e {\n        if let Ok(avro_record) = self.parse_from_kafka_record(record, ParserMode::Avro).await {\n            Ok(avro_record)\n        } else {\n            self.parse_from_kafka_record(record, ParserMode::String)\n                .await\n                .map_err(|_| StoreError::RecordParse(\"Unable to parse the kafka record before storing\".to_string()))\n        }\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":6},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","record_store","sqlite_store.rs"],"content":"use core::time;\nuse std::time::{Duration, Instant};\n\nuse crate::lib::types::ParsedKafkaRecord;\nuse log::debug;\nuse r2d2::Pool;\nuse r2d2_sqlite::SqliteConnectionManager;\nuse rusqlite::{backup::Backup, named_params, Connection, OpenFlags};\n\nuse super::{error::StoreResult, query::Query};\n\npub trait RecordStore {\n    fn create_or_replace_topic_table(\u0026self, cluster_id: \u0026str, topic_name: \u0026str, compacted: bool) -\u003e StoreResult\u003c()\u003e;\n    fn query_records(\u0026self, query: \u0026Query, timeout: Option\u003cDuration\u003e) -\u003e StoreResult\u003cVec\u003cParsedKafkaRecord\u003e\u003e;\n    fn insert_record(\u0026self, cluster_id: \u0026str, topic_name: \u0026str, record: \u0026ParsedKafkaRecord) -\u003e StoreResult\u003c()\u003e;\n    fn destroy(\u0026self, cluster_id: \u0026str, topic_name: \u0026str) -\u003e StoreResult\u003c()\u003e;\n}\n\npub struct SqliteStore {\n    pool: Pool\u003cSqliteConnectionManager\u003e,\n    timeout: Duration,\n}\n\nimpl RecordStore for SqliteStore {\n    fn query_records(\u0026self, query: \u0026Query, timeout: Option\u003cDuration\u003e) -\u003e StoreResult\u003cVec\u003cParsedKafkaRecord\u003e\u003e {\n        let parsed_query = Self::parse_query(query);\n        // closure that actually execute the query\n        let _get_records = move |connection: \u0026r2d2::PooledConnection\u003cSqliteConnectionManager\u003e| {\n            let mut stmt = connection.prepare(\u0026parsed_query)?;\n            let records_iter = stmt.query_map([], |row| {\n                Ok(ParsedKafkaRecord {\n                    topic: query.topic_name.clone(),\n                    partition: row.get(0)?,\n                    offset: row.get(1)?,\n                    timestamp: row.get(2)?,\n                    key: row.get(3)?,\n                    payload: row.get(4)?,\n                })\n            })?;\n            let mut records = Vec::new();\n            for r in records_iter {\n                records.push(r?);\n            }\n            Ok(records)\n        };\n        let connection = self.pool.get().unwrap();\n        let start_query = Instant::now();\n        let timeout = timeout.unwrap_or(self.timeout);\n        // setup the progress handler for the connection\n        connection.progress_handler(2500, Some(move || start_query.elapsed() \u003e timeout));\n        // run the query\n        let result = _get_records(\u0026connection);\n        // remove the progress handler attached to the connection before returning the result\n        connection.progress_handler(0, None::\u003cfn() -\u003e bool\u003e);\n        result\n    }\n\n    fn create_or_replace_topic_table(\u0026self, cluster_id: \u0026str, topic_name: \u0026str, compacted: bool) -\u003e StoreResult\u003c()\u003e {\n        let connection = self.pool.get().unwrap();\n        self.destroy(cluster_id, topic_name)?;\n        connection\n            .execute(\n                format!(\n                    \"CREATE TABLE {} (\n                        partition   NUMBER,\n                        offset      NUMBER,\n                        timestamp   NUMBER,\n                        key         TEXT {},\n                        payload     TEXT,\n                        PRIMARY KEY (partition, offset))\",\n                    Self::get_table_name(cluster_id, topic_name),\n                    match compacted {\n                        true =\u003e \"UNIQUE\",\n                        false =\u003e \"\",\n                    }\n                )\n                .as_str(),\n                [],\n            )\n            .unwrap_or_else(|e| panic!(\"Unable to create the table for {} {} {:?}\", cluster_id, topic_name, e));\n        Ok(())\n    }\n\n    fn insert_record(\u0026self, cluster_id: \u0026str, topic_name: \u0026str, record: \u0026ParsedKafkaRecord) -\u003e StoreResult\u003c()\u003e {\n        let connection = self.pool.get().unwrap();\n        connection.execute(\n            format!(\n                \"INSERT OR REPLACE INTO {} (partition, offset, timestamp, key, payload) \n                VALUES (:partition, :offset, :timestamp, :key, :payload)\",\n                Self::get_table_name(cluster_id, topic_name)\n            )\n            .as_str(),\n            named_params! {\n                \":partition\": \u0026record.partition,\n                \":offset\": \u0026record.offset,\n                \":timestamp\": \u0026record.timestamp,\n                \":key\": \u0026record.key,\n                \":payload\": \u0026record.payload,\n            },\n        )?;\n        Ok(())\n    }\n\n    fn destroy(\u0026self, cluster_id: \u0026str, topic_name: \u0026str) -\u003e StoreResult\u003c()\u003e {\n        let connection = self.pool.get().unwrap();\n        connection\n            .execute(\n                format!(\"DROP TABLE IF EXISTS {}\", Self::get_table_name(cluster_id, topic_name)).as_str(),\n                [],\n            )\n            .unwrap_or_else(|_| panic!(\"Unable to create the table for {} {}\", cluster_id, topic_name));\n        Ok(())\n    }\n}\n\nimpl SqliteStore {\n    pub fn new(timeout: Duration) -\u003e Self {\n        let file_name = format!(\"file::memory{}:?cache=shared\u0026mode=memory\", rand::random::\u003cusize\u003e());\n        let flags_r = OpenFlags::SQLITE_OPEN_READ_WRITE | OpenFlags::SQLITE_OPEN_NO_MUTEX | OpenFlags::SQLITE_OPEN_URI;\n        let manager = SqliteConnectionManager::file(file_name)\n            .with_flags(flags_r)\n            .with_init(|conn| {\n                conn.pragma_update(None, \"journal_mode\", \"OFF\").unwrap();\n                conn.pragma_update(None, \"synchronous\", \"OFF\").unwrap();\n                conn.pragma_update(None, \"page_size\", \"4096\").unwrap();\n                conn.pragma_update(None, \"cache_size\", \"16384\").unwrap();\n                conn.pragma_update(None, \"locking_mode\", \"NORMAL\").unwrap();\n                conn.pragma_update(None, \"read_uncommitted\", \"ON\").unwrap();\n                Ok(())\n            });\n        let pool = r2d2::Pool::builder()\n            .max_size(20)\n            .build(manager)\n            .expect(\"Unable to initialize the read only connection pool to the db\");\n        SqliteStore { pool, timeout }\n    }\n\n    #[cfg(test)]\n    fn get_size(\u0026self, query: \u0026Query) -\u003e StoreResult\u003cusize\u003e {\n        use super::error::StoreError;\n\n        let connection = self.pool.get().unwrap();\n        let mut stmt = connection.prepare(format!(\"SELECT count(*) FROM ({})\", Self::parse_query(query)).as_str())?;\n        let rows: Vec\u003c_\u003e = stmt.query_map([], |row| row.get::\u003c_, i64\u003e(0))?.collect();\n        if let Some(Ok(size)) = rows.first() {\n            Ok(*size as usize)\n        } else {\n            Err(StoreError::SqlError(\"Unable to get the table size\".to_string()))\n        }\n    }\n\n    pub fn export_db(\u0026self, output_path: \u0026str) -\u003e StoreResult\u003c()\u003e {\n        let src = self.pool.get().unwrap();\n        let mut dst = Connection::open(output_path)?;\n        let backup = Backup::new(\u0026src, \u0026mut dst)?;\n        backup.run_to_completion(\n            1000,\n            time::Duration::from_millis(100),\n            Some(|p| {\n                debug!(\n                    \"Export in progress: {}%\",\n                    100f32 * ((p.pagecount - p.remaining) as f32 / p.pagecount as f32)\n                )\n            }),\n        )?;\n        Ok(())\n    }\n\n    fn parse_query(query: \u0026Query) -\u003e String {\n        let Query {\n            cluster_id,\n            topic_name,\n            offset,\n            limit,\n            query_template,\n        } = query;\n        let query = query_template\n            .replace(\"{:topic}\", Self::get_table_name(cluster_id, topic_name).as_str())\n            .replace(\"{:limit}\", limit.to_string().as_str())\n            .replace(\"{:offset}\", offset.to_string().as_str());\n        let query = query.trim();\n        if query.ends_with(';') {\n            let mut chars = query.chars();\n            chars.next_back();\n            chars.as_str().into()\n        } else {\n            query.into()\n        }\n    }\n\n    fn get_table_name(cluster_id: \u0026str, topic_name: \u0026str) -\u003e String {\n        format!(\"\\'[{}].[{}]\\'\", cluster_id, topic_name)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::lib::{\n        record_store::{error::StoreError, sqlite_store::Query},\n        types::ParsedKafkaRecord,\n    };\n    use std::{\n        env::temp_dir,\n        sync::Arc,\n        thread::spawn,\n        time::{Duration, Instant},\n    };\n\n    use super::{RecordStore, SqliteStore};\n\n    fn get_test_db_path() -\u003e String {\n        let mut dir = temp_dir();\n        dir.push(\"test.db\");\n        dir.to_str().unwrap().into()\n    }\n\n    #[tokio::test]\n    async fn test_export_database() {\n        // arrange\n        let test_db_path = get_test_db_path();\n        let (cluster_id, topic_name) = (\"cluster_id_example\", \"topic_name_example\");\n        let db = SqliteStore::new(Duration::from_secs(10));\n        db.create_or_replace_topic_table(cluster_id, topic_name, false).unwrap();\n        let test_record = get_test_record(topic_name, 0);\n        db.insert_record(cluster_id, topic_name, \u0026test_record).unwrap();\n        // act\n        let res = db.export_db(\u0026test_db_path);\n        // assert\n        assert!(res.is_ok());\n        //todo: validate DB content\n    }\n\n    #[tokio::test]\n    async fn test_create_table() {\n        let db = SqliteStore::new(Duration::from_secs(10));\n        let res = db.create_or_replace_topic_table(\"cluster_id_example\", \"topic_name_example\", false);\n        assert!(res.is_ok())\n    }\n\n    #[tokio::test]\n    async fn test_insert_and_get_record() {\n        // arrange\n        let (cluster_id, topic_name) = (\"cluster_id_example\", \"topic_name_example\");\n        let db = SqliteStore::new(Duration::from_secs(10));\n        db.create_or_replace_topic_table(cluster_id, topic_name, false)\n            .expect(\"Unable to create the table\");\n        let test_record = get_test_record(topic_name, 0);\n        // act\n        db.insert_record(cluster_id, topic_name, \u0026test_record).unwrap();\n        let records_back = db\n            .query_records(\u0026Query::select_any(cluster_id, topic_name, 0, 1000), None)\n            .unwrap();\n        // assert\n        assert_eq!(records_back.len(), 1);\n        assert_eq!(records_back[0], test_record);\n    }\n\n    #[tokio::test]\n    async fn test_query_timeout() {\n        // arrange\n        let (cluster_id, topic_name) = (\"cluster_id_example\", \"topic_name_example\");\n        let db = SqliteStore::new(Duration::from_micros(1));\n        db.create_or_replace_topic_table(cluster_id, topic_name, false)\n            .expect(\"Unable to create the table\");\n        // act\n        (0..10000).for_each(|i| {\n            db.insert_record(cluster_id, topic_name, \u0026get_test_record(topic_name, i))\n                .unwrap()\n        });\n        let records_back = db.query_records(\u0026Query::select_any(cluster_id, topic_name, 0, 1000), None);\n        // assert\n        assert_eq!(\n            records_back.err().unwrap(),\n            StoreError::SqlError(\"Operation timed out\".into())\n        );\n    }\n\n    #[tokio::test]\n    async fn test_insert_and_get_records() {\n        // arrange\n        let (cluster_id, topic_name) = (\"cluster_id_example\", \"topic_name_example\");\n        let db = SqliteStore::new(Duration::from_secs(10));\n        let test_record1 = get_test_record(topic_name, 0);\n        let test_record2 = ParsedKafkaRecord {\n            offset: 1,\n            payload: Some(\"latest-test\".into()),\n            ..test_record1.clone()\n        };\n        // compacted table should replace old records with same key\n        {\n            db.create_or_replace_topic_table(cluster_id, topic_name, true)\n                .expect(\"Unable to create the table\");\n            // act\n            db.insert_record(cluster_id, topic_name, \u0026test_record1).unwrap();\n            db.insert_record(cluster_id, topic_name, \u0026test_record2).unwrap();\n            let records_back = db\n                .query_records(\u0026Query::select_any(cluster_id, topic_name, 0, 1000), None)\n                .unwrap();\n            // assert\n            assert_eq!(records_back.len(), 1);\n            assert_eq!(records_back[0], test_record2);\n        }\n        // non compacted table should persist all the data\n        {\n            db.create_or_replace_topic_table(cluster_id, topic_name, false)\n                .expect(\"Unable to create the table\");\n            // act\n            db.insert_record(cluster_id, topic_name, \u0026test_record1).unwrap();\n            db.insert_record(cluster_id, topic_name, \u0026test_record2).unwrap();\n            let records_back = db\n                .query_records(\u0026Query::select_any(cluster_id, topic_name, 0, 1000), None)\n                .unwrap();\n            // assert\n            assert_eq!(records_back.len(), 2);\n            assert_eq!(records_back[1], test_record2);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_get_size() {\n        // arrange\n        let (cluster_id, topic_name) = (\"cluster_id_example\", \"topic_name_example\");\n        let db = SqliteStore::new(Duration::from_secs(10));\n        db.create_or_replace_topic_table(cluster_id, topic_name, false)\n            .expect(\"Unable to create the table\");\n        // act\n        db.insert_record(cluster_id, topic_name, \u0026get_test_record(topic_name, 0))\n            .unwrap();\n        db.insert_record(cluster_id, topic_name, \u0026get_test_record(topic_name, 1))\n            .unwrap();\n        db.insert_record(cluster_id, topic_name, \u0026get_test_record(topic_name, 2))\n            .unwrap();\n        let table_size = db\n            .get_size(\u0026Query::select_any(cluster_id, topic_name, 0, 1000))\n            .unwrap();\n        // assert\n        assert_eq!(table_size, 3);\n    }\n\n    #[tokio::test]\n    async fn test_get_size_with_query() {\n        // arrange\n        let (cluster_id, topic_name) = (\"cluster_id_example\", \"topic_name_example\");\n        let db = SqliteStore::new(Duration::from_secs(10));\n        db.create_or_replace_topic_table(cluster_id, topic_name, false)\n            .expect(\"Unable to create the table\");\n        let record1 = ParsedKafkaRecord {\n            key: Some(\"test\".into()),\n            ..get_test_record(topic_name, 1)\n        };\n        let record2 = ParsedKafkaRecord {\n            offset: 2,\n            ..record1.clone()\n        };\n        // act\n        db.insert_record(cluster_id, topic_name, \u0026record1).unwrap();\n        db.insert_record(cluster_id, topic_name, \u0026record2).unwrap();\n        db.insert_record(cluster_id, topic_name, \u0026get_test_record(topic_name, 3))\n            .unwrap();\n        let table_size = db\n            .get_size(\u0026Query {\n                cluster_id: cluster_id.into(),\n                topic_name: topic_name.into(),\n                limit: -1,\n                offset: -1,\n                query_template:\n                    \"SELECT * from {:topic} WHERE key = \\\"test\\\" ORDER BY offset LIMIT {:limit} OFFSET {:offset};\".into(),\n            })\n            .unwrap();\n        // assert\n        assert_eq!(table_size, 2);\n    }\n\n    #[tokio::test]\n    async fn test_use_offset() {\n        // arrange\n        let (cluster_id, topic_name) = (\"cluster_id_example\", \"topic_name_example\");\n        let db = SqliteStore::new(Duration::from_secs(10));\n        db.create_or_replace_topic_table(cluster_id, topic_name, false)\n            .expect(\"Unable to create the table\");\n        // act\n        db.insert_record(cluster_id, topic_name, \u0026get_test_record(topic_name, 0))\n            .unwrap();\n        db.insert_record(cluster_id, topic_name, \u0026get_test_record(topic_name, 1))\n            .unwrap();\n        db.insert_record(cluster_id, topic_name, \u0026get_test_record(topic_name, 2))\n            .unwrap();\n        let first_1000_res = db\n            .query_records(\u0026Query::select_any(cluster_id, topic_name, 0, 1000), None)\n            .unwrap();\n        let first_res = db\n            .query_records(\u0026Query::select_any(cluster_id, topic_name, 1, 1), None)\n            .unwrap();\n        let no_res = db\n            .query_records(\u0026Query::select_any(cluster_id, topic_name, 3, 1000), None)\n            .unwrap();\n        // assert\n        assert_eq!(first_1000_res.len(), 3);\n        assert_eq!(first_res.len(), 1);\n        assert_eq!(no_res.len(), 0);\n    }\n\n    #[ignore]\n    #[tokio::test]\n    async fn bench_insert_and_get_record() {\n        use futures::executor::block_on;\n        // arrange\n        let (cluster_id, topic_name) = (\"cluster_id_example\", \"topic_name_example\");\n        let topic_name2 = \"topic_name_example2\";\n        let db = Arc::new(SqliteStore::new(Duration::from_secs(10)));\n\n        async fn write(id: i32, db: Arc\u003cSqliteStore\u003e, cluster_id: \u0026str, topic_name: \u0026str) {\n            let start = Instant::now();\n            let test_record = get_test_record(topic_name, 0);\n            for i in 0..10_000 {\n                let res = db.insert_record(cluster_id, topic_name, \u0026test_record);\n                if res.is_err() {\n                    println!(\"write-{} {} {:?}\", id, i, res);\n                }\n            }\n            println!(\"write-{} Time elapsed: {:?}\", id, start.elapsed());\n        }\n\n        async fn read(id: i32, db: Arc\u003cSqliteStore\u003e, cluster_id: \u0026str, topic_name: \u0026str) {\n            let start = Instant::now();\n            for i in 0..10_000 {\n                let res = db.query_records(\u0026Query::select_any(cluster_id, topic_name, 0, 1000), None);\n                if res.is_err() {\n                    println!(\"read-{} {} {:?}\", id, i, res);\n                }\n            }\n            println!(\"read-{} Time elapsed: {:?}\", id, start.elapsed());\n        }\n\n        // act\n        // topic1\n        db.create_or_replace_topic_table(cluster_id, topic_name, false)\n            .expect(\"Unable to create the table\");\n        let write1 = spawn({\n            let db = db.clone();\n            move || block_on(write(1, db.clone(), cluster_id, topic_name))\n        });\n\n        let read1 = spawn({\n            let db = db.clone();\n            move || block_on(read(1, db.clone(), cluster_id, topic_name))\n        });\n\n        let read2 = spawn({\n            let db = db.clone();\n            move || block_on(read(2, db.clone(), cluster_id, topic_name))\n        });\n\n        // topic2\n        db.create_or_replace_topic_table(cluster_id, topic_name2, false)\n            .expect(\"Unable to create the table\");\n\n        let write2 = spawn({\n            let db = db.clone();\n            move || block_on(write(2, db.clone(), cluster_id, topic_name2))\n        });\n\n        let read3 = spawn({\n            let db = db.clone();\n            move || block_on(read(2, db.clone(), cluster_id, topic_name2))\n        });\n\n        let read4 = spawn({\n            let db = db;\n            move || block_on(read(2, db.clone(), cluster_id, topic_name2))\n        });\n\n        assert!(write1.join().is_ok());\n        assert!(read1.join().is_ok());\n        assert!(read2.join().is_ok());\n        assert!(write2.join().is_ok());\n        assert!(read3.join().is_ok());\n        assert!(read4.join().is_ok());\n    }\n\n    fn get_test_record(topic_name: \u0026str, offset: i64) -\u003e ParsedKafkaRecord {\n        ParsedKafkaRecord {\n            payload: Some(\"example payload\".to_string()),\n            key: Some(\"key\".into()),\n            topic: topic_name.into(),\n            timestamp: Some(321123321),\n            partition: 2,\n            offset,\n        }\n    }\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":10015},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":10015},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":10015},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":10015},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":10015},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":10015},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":10015},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":10015},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":10015},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":10015},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":10015},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":10015},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":10015},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":10015},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":10015},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":166},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":160},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":160},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":160},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":160},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":160},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":160},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":160},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":10042},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":10042},"fn_name":null}],"covered":116,"coverable":119},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","record_store","topic_store.rs"],"content":"use log::{debug, trace};\nuse rdkafka::message::ToBytes;\n\nuse crate::lib::{\n    parser::Parser,\n    types::{ParsedKafkaRecord, RawKafkaRecord},\n};\nuse std::{\n    fs::OpenOptions,\n    io::{LineWriter, Write},\n    sync::{Arc, RwLock},\n    time::Duration,\n};\n\nuse super::{\n    error::StoreResult,\n    query::Query,\n    record_parser::KafkaRecordParser,\n    sqlite_store::{RecordStore, SqliteStore},\n    types::ExportOptions,\n};\n\npub struct TopicStore\u003cS: RecordStore = SqliteStore, P: KafkaRecordParser = Parser\u003e {\n    cluster_id: String,\n    topic_name: String,\n    store: Arc\u003cS\u003e,\n    parser: Arc\u003cP\u003e,\n    records_counter: RwLock\u003cusize\u003e,\n}\n\nimpl\u003cS: RecordStore, P: KafkaRecordParser\u003e TopicStore\u003cS, P\u003e {\n    pub fn from_record_store(store: Arc\u003cS\u003e, parser: Arc\u003cP\u003e, cluster_id: \u0026str, topic_name: \u0026str) -\u003e Self {\n        store\n            .create_or_replace_topic_table(cluster_id, topic_name, false)\n            .unwrap_or_else(|_| {\n                panic!(\n                    \"Unable to create the table to store the records from topic {}\",\n                    topic_name\n                )\n            });\n        TopicStore {\n            cluster_id: cluster_id.to_string(),\n            topic_name: topic_name.to_string(),\n            store,\n            parser,\n            records_counter: Default::default(),\n        }\n    }\n\n    pub fn setup(\u0026self, compactify: bool) -\u003e StoreResult\u003c()\u003e {\n        *self.records_counter.write().unwrap() = 0;\n        self.store\n            .create_or_replace_topic_table(\u0026self.cluster_id, \u0026self.topic_name, compactify)\n    }\n\n    pub fn get_records(\n        \u0026self,\n        query: Option\u003c\u0026str\u003e,\n        offset: i64,\n        limit: i64,\n        timeout: Option\u003cDuration\u003e,\n    ) -\u003e StoreResult\u003cVec\u003cParsedKafkaRecord\u003e\u003e {\n        self.store.query_records(\n            \u0026Query {\n                cluster_id: self.cluster_id.clone(),\n                topic_name: self.topic_name.clone(),\n                offset,\n                limit,\n                query_template: match query {\n                    Some(query) =\u003e query,\n                    None =\u003e Query::SELECT_WITH_OFFSET_LIMIT_QUERY,\n                }\n                .into(),\n            },\n            timeout,\n        )\n    }\n\n    pub async fn insert_record(\u0026self, record: \u0026RawKafkaRecord) -\u003e StoreResult\u003c()\u003e {\n        *self.records_counter.write().unwrap() += 1;\n        let parsed_record = self.parser.parse_kafka_record(record).await?;\n        self.store\n            .insert_record(\u0026self.cluster_id, \u0026self.topic_name, \u0026parsed_record)\n    }\n\n    pub fn get_records_count(\u0026self) -\u003e StoreResult\u003cusize\u003e {\n        Ok(*self.records_counter.read().unwrap())\n    }\n\n    pub fn export_records(\u0026self, options: \u0026ExportOptions) -\u003e StoreResult\u003c()\u003e {\n        let ExportOptions {\n            limit,\n            query,\n            output_path,\n            overwrite,\n            parse_timestamp,\n        } = options;\n        debug!(\"Exporting records to {}\", output_path);\n        let query_limit = limit.unwrap_or(-1); // export all the results if no limit is specified\n        let out_file = {\n            if *overwrite {\n                OpenOptions::new()\n                    .write(true)\n                    .truncate(true)\n                    .create(true)\n                    .open(output_path)\n            } else {\n                OpenOptions::new()\n                    .write(true)\n                    .truncate(true)\n                    .create_new(true)\n                    .open(output_path)\n            }\n        }?;\n        let mut writer = LineWriter::new(out_file);\n        let query_result: Vec\u003cParsedKafkaRecord\u003e =\n            self.get_records(query.as_deref(), 0, query_limit, Some(Duration::from_secs(3 * 60)))?;\n        trace!(\"Write records to the out file\");\n        writer.write_all(ParsedKafkaRecord::to_string_header().to_bytes())?;\n        for record in query_result {\n            writer.write_all(b\"\\n\")?;\n            writer.write_all(record.to_csv_line(*parse_timestamp).to_bytes())?;\n        }\n        writer.flush()?;\n        debug!(\"Export completed\");\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use std::env::temp_dir;\n    use std::fs;\n    use std::sync::Arc;\n    use std::time::Duration;\n\n    use mockall::*;\n\n    use super::TopicStore;\n    use crate::lib::record_store::error::StoreResult;\n    use crate::lib::record_store::query::Query;\n    use crate::lib::record_store::record_parser::KafkaRecordParser;\n    use crate::lib::record_store::sqlite_store::RecordStore;\n    use crate::lib::record_store::types::ExportOptions;\n    use crate::lib::types::{ParsedKafkaRecord, RawKafkaRecord};\n    use async_trait::async_trait;\n\n    mock! {\n        Parser {}\n        #[async_trait]\n        impl KafkaRecordParser for Parser {\n            async fn parse_kafka_record(\u0026self, record: \u0026RawKafkaRecord) -\u003e StoreResult\u003cParsedKafkaRecord\u003e;\n        }\n    }\n    mock! {\n        Store {}\n        impl RecordStore for Store {\n            fn query_records(\u0026self, query: \u0026Query, timeout: Option\u003cDuration\u003e) -\u003e StoreResult\u003cVec\u003cParsedKafkaRecord\u003e\u003e;\n            fn create_or_replace_topic_table(\u0026self, cluster_id: \u0026str, topic_name: \u0026str, compacted: bool) -\u003e StoreResult\u003c()\u003e;\n            fn insert_record(\u0026self, cluster_id: \u0026str, topic_name: \u0026str, record: \u0026ParsedKafkaRecord) -\u003e StoreResult\u003c()\u003e;\n            fn destroy(\u0026self, cluster_id: \u0026str, topic_name: \u0026str) -\u003e StoreResult\u003c()\u003e;\n        }\n    }\n\n    #[test]\n    fn test_export_all_records() {\n        // arrange\n        let mut mock_record_store = MockStore::new();\n        let parser_mock = MockParser::new();\n        mock_record_store\n            .expect_create_or_replace_topic_table()\n            .returning(|_, _, _| Ok(()));\n        mock_record_store\n            .expect_query_records()\n            .returning(|_, _| Ok(vec![create_test_record(0), create_test_record(1)]));\n        let sut = TopicStore::from_record_store(\n            Arc::new(mock_record_store),\n            Arc::new(parser_mock),\n            \"cluster_id\",\n            \"topic_name\",\n        );\n\n        let test_file = format!(\"{}/{}\", temp_dir().to_str().unwrap(), rand::random::\u003cusize\u003e());\n        println!(\"{}\", test_file);\n        let select_all_query = \"SELECT partition, offset, timestamp, key, payload FROM {:topic} ORDER BY timestamp desc LIMIT {:limit} OFFSET {:offset}\";\n        // act\n        let options = ExportOptions {\n            query: Some(select_all_query.to_string()),\n            output_path: test_file.clone(),\n            overwrite: true,\n            ..Default::default()\n        };\n        let res = sut.export_records(\u0026options);\n        // assert\n        let exported_data = fs::read_to_string(test_file).unwrap();\n        assert!(res.is_ok());\n        assert_eq!(\n            exported_data,\n            \"timestamp;partition;offset;key;payload\\n123123;0;0;key;payload\\n123123;1;0;key;payload\"\n        );\n    }\n\n    #[test]\n    fn test_export_no_records() {\n        // arrange\n        let mut mock_record_store = MockStore::new();\n        let parser_mock = MockParser::new();\n        mock_record_store.expect_query_records().returning(|_, _| Ok(vec![]));\n        mock_record_store\n            .expect_create_or_replace_topic_table()\n            .returning(|_, _, _| Ok(()));\n        let sut = TopicStore::from_record_store(\n            Arc::new(mock_record_store),\n            Arc::new(parser_mock),\n            \"cluster_id\",\n            \"topic_name\",\n        );\n\n        let test_file = format!(\"{}/{}\", temp_dir().to_str().unwrap(), rand::random::\u003cusize\u003e());\n        let select_all_query = \"SELECT partition, offset, timestamp, key, payload FROM {:topic} ORDER BY timestamp desc LIMIT {:limit} OFFSET {:offset}\";\n        // act\n        let options = ExportOptions {\n            query: Some(select_all_query.to_string()),\n            output_path: test_file.clone(),\n            overwrite: true,\n            ..Default::default()\n        };\n        let res = sut.export_records(\u0026options);\n        // assert\n        let exported_data = fs::read_to_string(test_file).unwrap();\n        assert!(res.is_ok());\n        assert_eq!(exported_data, \"timestamp;partition;offset;key;payload\");\n    }\n\n    #[test]\n    fn test_overwrite_files() {\n        let mut mock_record_store = MockStore::new();\n        let parser_mock = MockParser::new();\n        mock_record_store\n            .expect_create_or_replace_topic_table()\n            .returning(|_, _, _| Ok(()));\n        mock_record_store.expect_query_records().returning(|_, _| Ok(vec![]));\n        let sut = TopicStore::from_record_store(\n            Arc::new(mock_record_store),\n            Arc::new(parser_mock),\n            \"cluster_id\",\n            \"topic_name\",\n        );\n        let select_all_query = \"SELECT partition, offset, timestamp, key, payload FROM {:topic} ORDER BY timestamp desc LIMIT {:limit} OFFSET {:offset}\";\n        let options = ExportOptions {\n            query: Some(select_all_query.to_string()),\n            output_path: format!(\"{}/test{}\", temp_dir().to_str().unwrap(), rand::random::\u003cusize\u003e()),\n            overwrite: true,\n            ..Default::default()\n        };\n        // truncate the file if overwrite true\n        {\n            let mut options = options.clone();\n            options.overwrite = true;\n            assert!(sut.export_records(\u0026options).is_ok());\n            assert!(sut.export_records(\u0026options).is_ok());\n        }\n        // return err if the file already exists and overwrite is false\n        {\n            let mut options = options;\n            options.overwrite = true;\n            assert!(sut.export_records(\u0026options).is_ok());\n            options.overwrite = false;\n            assert!(sut.export_records(\u0026options).is_err());\n        }\n    }\n\n    fn create_test_record(i: i32) -\u003e ParsedKafkaRecord {\n        ParsedKafkaRecord {\n            payload: Some(\"payload\".into()),\n            key: Some(\"key\".into()),\n            topic: \"topic\".into(),\n            timestamp: Some(123123),\n            partition: i,\n            offset: 0,\n        }\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":5},"fn_name":null}],"covered":40,"coverable":59},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","record_store","types.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Default, Debug, Clone)]\npub struct ExportOptions {\n    pub query: Option\u003cString\u003e,\n    #[serde(rename = \"outputPath\")]\n    pub output_path: String,\n    pub limit: Option\u003ci64\u003e,\n    #[serde(rename = \"parseTimestamp\")]\n    pub parse_timestamp: bool,\n    pub overwrite: bool,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","schema_registry","client.rs"],"content":"use log::{debug, trace};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\nuse url::Url;\n\nuse apache_avro::Schema as AvroSchema;\n\nuse super::error::{SchemaRegistryError, SchemaRegistryResult};\nuse super::http_client::{HttpClient, ReqwestClient};\nuse super::types::{BasicAuth, ResolvedAvroSchema, Schema, Subject};\n\n#[derive(Deserialize)]\nstruct GetSchemaByIdResult {\n    pub schema: String,\n}\n\n#[derive(Clone)]\npub struct CachedSchemaRegistry\u003cC: HttpClient = ReqwestClient\u003e {\n    http_client: C,\n    endpoint: String,\n    schema_cache_by_id: Arc\u003cRwLock\u003cHashMap\u003ci32, ResolvedAvroSchema\u003e\u003e\u003e,\n}\n\nimpl CachedSchemaRegistry\u003cReqwestClient\u003e {\n    pub fn new(endpoint: \u0026str, username: Option\u003c\u0026str\u003e, password: Option\u003c\u0026str\u003e) -\u003e Self {\n        assert!(!endpoint.is_empty());\n        let auth = if let Some(username) = username {\n            assert!(!username.is_empty());\n            let auth = BasicAuth {\n                username: username.to_string(),\n                password: password.map(|p| p.to_owned()),\n            };\n            Some(auth)\n        } else {\n            None\n        };\n        let http_client = ReqwestClient::new(auth);\n        CachedSchemaRegistry::new_with_client(endpoint, http_client)\n    }\n}\n\nimpl\u003cC: HttpClient\u003e CachedSchemaRegistry\u003cC\u003e {\n    pub fn new_with_client(endpoint: \u0026str, http_client: C) -\u003e Self {\n        Self {\n            http_client,\n            endpoint: endpoint.into(),\n            schema_cache_by_id: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    pub async fn post_schema(\u0026self, subject_name: \u0026str, schema: \u0026str) -\u003e SchemaRegistryResult\u003c()\u003e {\n        #[derive(Serialize)]\n        struct PostRequest {\n            schema: String,\n        }\n        let url = Url::parse(\u0026self.endpoint)?.join(format!(\"/subjects/{}/versions\", subject_name).as_str())?;\n        let request = PostRequest { schema: schema.into() };\n        match AvroSchema::parse_str(schema) {\n            Ok(_) =\u003e Ok(self.http_client.post(url.as_str(), request).await?),\n            Err(err) =\u003e Err(SchemaRegistryError::SchemaParsing(format!(\"Invalid schema {}\", err))),\n        }\n    }\n\n    pub async fn list_subjects(\u0026self) -\u003e SchemaRegistryResult\u003cVec\u003cString\u003e\u003e {\n        let url = Url::parse(\u0026self.endpoint)?.join(\"subjects\")?;\n        let res = self.http_client.get(url.as_ref()).await?;\n        Ok(res)\n    }\n\n    pub async fn get_subject(\u0026self, subject_name: \u0026str) -\u003e SchemaRegistryResult\u003cSubject\u003e {\n        debug!(\"Get subject {}\", subject_name);\n        Ok(Subject {\n            subject: subject_name.into(),\n            versions: self.get_versions(subject_name).await?,\n            compatibility: self.get_compatibility_level(subject_name).await?,\n        })\n    }\n\n    pub async fn delete_subject(\u0026self, subject_name: \u0026str) -\u003e SchemaRegistryResult\u003c()\u003e {\n        debug!(\"Deleting subject {}\", subject_name);\n        let url = Url::parse(\u0026self.endpoint)?.join(format!(\"/subjects/{}\", subject_name).as_str())?;\n        Ok(self.http_client.delete(url.as_str()).await?)\n    }\n\n    pub async fn delete_version(\u0026self, subject_name: \u0026str, version: i32) -\u003e SchemaRegistryResult\u003c()\u003e {\n        debug!(\"Deleting subject {} version {}\", subject_name, version);\n        let url =\n            Url::parse(\u0026self.endpoint)?.join(format!(\"/subjects/{}/versions/{}\", subject_name, version).as_str())?;\n        Ok(self.http_client.delete(url.as_str()).await?)\n    }\n\n    pub async fn get_schema_by_id(\u0026self, id: i32) -\u003e SchemaRegistryResult\u003cResolvedAvroSchema\u003e {\n        trace!(\"Getting schema {} by id.\", id);\n        {\n            if let Some(cached) = self.schema_cache_by_id.read().await.get(\u0026id) {\n                trace!(\"Schema found in cache\");\n                return Ok(cached.clone());\n            }\n        }\n        {\n            trace!(\"Schema not found in cache, retrieving\");\n            let url = Url::parse(\u0026self.endpoint)?.join(format!(\"/schemas/ids/{}\", id).as_str())?;\n            let schema: GetSchemaByIdResult = self.http_client.get(url.as_str()).await?;\n            let schema = AvroSchema::parse_str(schema.schema.as_str()).map_err(|err| {\n                SchemaRegistryError::SchemaParsing(format!(\"Unable to parse the schema from schema registry\\n{}\", err))\n            })?;\n            let res = ResolvedAvroSchema::from(id, schema);\n            self.schema_cache_by_id.write().await.insert(id, res.clone());\n            Ok(res)\n        }\n    }\n\n    async fn get_compatibility_level(\u0026self, subject_name: \u0026str) -\u003e SchemaRegistryResult\u003cString\u003e {\n        #[derive(Deserialize)]\n        struct CompatibilityResponse {\n            #[serde(alias = \"compatibilityLevel\")]\n            compatibility_level: String,\n        }\n        let url = Url::parse(\u0026self.endpoint)?.join(format!(\"/config/{}?defaultToGlobal=true\", subject_name).as_str())?;\n        let response: CompatibilityResponse = self.http_client.get(url.as_ref()).await?;\n        Ok(response.compatibility_level)\n    }\n\n    async fn get_versions(\u0026self, subject_name: \u0026str) -\u003e SchemaRegistryResult\u003cVec\u003cSchema\u003e\u003e {\n        let url = Url::parse(\u0026self.endpoint)?.join(format!(\"/subjects/{}/versions/\", subject_name).as_str())?;\n        let versions: Vec\u003ci32\u003e = self.http_client.get(url.as_ref()).await?;\n        let mut schemas = Vec::\u003cSchema\u003e::new();\n        for v in versions {\n            let url = url.join(\u0026v.to_string())?;\n            let schema: Schema = self.http_client.get(url.as_ref()).await?;\n            schemas.push(schema);\n        }\n        Ok(schemas)\n    }\n\n    pub async fn get_last_schema(\u0026self, subject_name: \u0026str) -\u003e SchemaRegistryResult\u003cResolvedAvroSchema\u003e {\n        let schemas = self.get_versions(subject_name).await?;\n        let last = schemas.iter().max_by(|x, y| x.version.cmp(\u0026y.version));\n\n        if let Some(last) = last {\n            let schema = AvroSchema::parse_str(last.schema.as_str()).map_err(|err| {\n                SchemaRegistryError::SchemaParsing(format!(\"Unable to parse the schema from schema registry\\n{}\", err))\n            })?;\n            Ok(ResolvedAvroSchema::from(last.id, schema))\n        } else {\n            Err(SchemaRegistryError::SchemaNotFound(format!(\n                \"Schema {} not found\",\n                subject_name\n            )))\n        }\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":74},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","schema_registry","error.rs"],"content":"use super::http_client::HttpClientError;\n\n#[derive(Debug, PartialEq)]\npub enum SchemaRegistryError {\n    SchemaNotFound(String),\n    SchemaParsing(String),\n    HttpClient(String),\n    InvalidUrl(String),\n}\n\npub type SchemaRegistryResult\u003cT\u003e = core::result::Result\u003cT, SchemaRegistryError\u003e;\n\nimpl From\u003curl::ParseError\u003e for SchemaRegistryError {\n    fn from(url: url::ParseError) -\u003e Self {\n        Self::InvalidUrl(url.to_string())\n    }\n}\nimpl From\u003cHttpClientError\u003e for SchemaRegistryError {\n    fn from(err: HttpClientError) -\u003e Self {\n        SchemaRegistryError::HttpClient(format!(\"Http client error {:?}\", err))\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","schema_registry","http_client.rs"],"content":"use async_trait::async_trait;\nuse log::warn;\nuse reqwest::{\n    header::{HeaderMap, CONTENT_TYPE},\n    RequestBuilder,\n};\nuse serde::{de::DeserializeOwned, Serialize};\n\nuse super::BasicAuth;\n\n#[derive(Debug, PartialEq, Eq)]\npub enum HttpClientError {\n    Unknown(String),\n    Decode(String),\n    Code(u16),\n}\n\npub(super) type Result\u003cT\u003e = std::result::Result\u003cT, HttpClientError\u003e;\n\n#[async_trait]\npub trait HttpClient: Sync + Send {\n    async fn get\u003cT: 'static + DeserializeOwned\u003e(\u0026self, url: \u0026str) -\u003e Result\u003cT\u003e;\n    async fn delete(\u0026self, url: \u0026str) -\u003e Result\u003c()\u003e;\n    async fn post\u003cT: Serialize + Send + Sync\u003e(\u0026self, url: \u0026str, data: T) -\u003e Result\u003c()\u003e;\n}\n\npub struct ReqwestClient {\n    client: reqwest::Client,\n    timeout_seconds: u64,\n    auth: Option\u003cBasicAuth\u003e,\n}\n\n#[async_trait]\nimpl HttpClient for ReqwestClient {\n    async fn post\u003cT: Serialize + Send + Sync\u003e(\u0026self, url: \u0026str, data: T) -\u003e Result\u003c()\u003e {\n        let request = self\n            .client\n            .post(url.to_string())\n            .body(serde_json::to_string(\u0026data).unwrap())\n            .headers({\n                let mut h = HeaderMap::new();\n                h.insert(CONTENT_TYPE, \"application/json\".parse().unwrap());\n                h\n            });\n        let response = self.send_request(request).await?;\n        if response.status().is_success() {\n            Ok(())\n        } else {\n            let error_code = response.status().as_u16();\n            let text = response.text().await.unwrap();\n            warn!(\"Unable to create a schema {:?}\", text);\n            Err(HttpClientError::Code(error_code))\n        }\n    }\n    async fn get\u003cT: 'static + DeserializeOwned\u003e(\u0026self, url: \u0026str) -\u003e Result\u003cT\u003e {\n        let request = self.client.get(url.to_string());\n        let response = self.send_request(request).await?;\n        if response.status().is_success() {\n            let res = response.json().await?;\n            Ok(res)\n        } else {\n            Err(HttpClientError::Code(response.status().as_u16()))\n        }\n    }\n\n    async fn delete(\u0026self, url: \u0026str) -\u003e Result\u003c()\u003e {\n        let request = self.client.delete(url.to_string());\n        let response = self.send_request(request).await?;\n        if response.status().is_success() {\n            Ok(())\n        } else {\n            Err(HttpClientError::Code(response.status().as_u16()))\n        }\n    }\n}\n\nimpl ReqwestClient {\n    pub fn new(auth: Option\u003cBasicAuth\u003e) -\u003e Self {\n        Self {\n            client: Default::default(),\n            timeout_seconds: 10,\n            auth,\n        }\n    }\n\n    async fn send_request(\u0026self, mut request: RequestBuilder) -\u003e Result\u003creqwest::Response\u003e {\n        request = request.timeout(core::time::Duration::from_secs(self.timeout_seconds));\n        if let Some(auth) = \u0026self.auth {\n            request = request.basic_auth(auth.username.to_owned(), auth.password.to_owned());\n        }\n        Ok(request.send().await?)\n    }\n}\n\nimpl From\u003creqwest::Error\u003e for HttpClientError {\n    fn from(err: reqwest::Error) -\u003e Self {\n        if let Some(error_code) = err.status() {\n            HttpClientError::Code(error_code.as_u16())\n        } else if err.is_decode() {\n            HttpClientError::Decode(err.to_string())\n        } else {\n            HttpClientError::Unknown(err.to_string())\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use httpmock::{\n        Method::{GET, POST},\n        MockServer,\n    };\n    use serde::Deserialize;\n\n    use crate::lib::schema_registry::http_client::HttpClientError;\n\n    use super::{HttpClient, ReqwestClient};\n\n    #[tokio::test]\n    async fn test_post_request() {\n        let server = MockServer::start();\n        let sut = ReqwestClient::new(None);\n        // return Ok when the request is successful\n        {\n            let server_mock = server.mock(|when, then| {\n                when.method(POST).path(\"/happy_path\");\n                then.status(200);\n            });\n            let res = sut.post(server.url(\"/happy_path\").as_str(), \u0026\"{}\").await;\n            assert!(res.is_ok(), \"Received {:?}\", res);\n            server_mock.assert();\n        }\n        // return the error code if any\n        {\n            let server_mock = server.mock(|when, then| {\n                when.method(POST).path(\"/not_found\");\n                then.status(404);\n            });\n            let res = sut.post(server.url(\"/not_found\").as_str(), \u0026\"{}\").await;\n            assert_eq!(res.err().unwrap(), HttpClientError::Code(404));\n            server_mock.assert();\n        }\n    }\n\n    #[tokio::test]\n    async fn test_get_request() {\n        let server = MockServer::start();\n        let sut = ReqwestClient::new(None);\n        #[derive(Deserialize, Debug)]\n        struct MockResponse {\n            id: String,\n        }\n        // return Ok when the request is successful\n        {\n            let server_mock = server.mock(|when, then| {\n                when.method(GET).path(\"/happy_path\");\n                then.status(200)\n                    .header(\"content-type\", \"text/json\")\n                    .body(\"{\\\"id\\\":\\\"123\\\"}\");\n            });\n            let res = sut.get::\u003cMockResponse\u003e(server.url(\"/happy_path\").as_str()).await;\n            assert!(res.is_ok());\n            assert_eq!(res.unwrap().id, \"123\");\n            server_mock.assert();\n        }\n        // return deserialization error if an unexpected body is received\n        {\n            let server_mock = server.mock(|when, then| {\n                when.method(GET).path(\"/invalid_response\");\n                then.status(200)\n                    .header(\"content-type\", \"text/json\")\n                    .body(\"{\\\"unknown_field\\\":\\\"123\\\"}\");\n            });\n            let res = sut.get::\u003cMockResponse\u003e(server.url(\"/invalid_response\").as_str()).await;\n            assert!(res.is_err());\n            assert!(matches!(res.err().unwrap(), HttpClientError::Decode(..)));\n            server_mock.assert();\n        }\n        // return the error code if any\n        {\n            let server_mock = server.mock(|when, then| {\n                when.method(GET).path(\"/not_found\");\n                then.status(404);\n            });\n            let res = sut.get::\u003cMockResponse\u003e(server.url(\"/not_found\").as_str()).await;\n            assert_eq!(res.err().unwrap(), HttpClientError::Code(404));\n            server_mock.assert();\n        }\n    }\n}\n","traces":[{"line":35,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":32,"coverable":41},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","schema_registry","mod.rs"],"content":"mod client;\nmod error;\nmod http_client;\nmod resolved_avro_schema;\nmod types;\n\npub use client::CachedSchemaRegistry;\npub use error::SchemaRegistryError;\npub use types::{BasicAuth, ResolvedAvroSchema, Schema, Subject};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","schema_registry","resolved_avro_schema.rs"],"content":"use std::collections::HashMap;\n\nuse apache_avro::{schema::Name, Schema};\n\nuse super::types::ResolvedAvroSchema;\n\nimpl ResolvedAvroSchema {\n    pub fn from(schema_id: i32, schema: Schema) -\u003e Self {\n        let refs = extract_all_refs(\u0026schema);\n        Self {\n            schema_id,\n            schema,\n            resolved_schemas: refs,\n        }\n    }\n}\n\nfn extract_all_refs(s: \u0026Schema) -\u003e HashMap\u003cName, Schema\u003e {\n    // set the namespace of the parent if it's not specified\n    fn ns_name(name: \u0026Name, parent_ns: \u0026Option\u003cString\u003e) -\u003e Name {\n        Name {\n            namespace: name.namespace.clone().or_else(|| parent_ns.to_owned()),\n            name: name.name.clone(),\n        }\n    }\n    fn _extract(s: \u0026Schema, parent_ns: \u0026Option\u003cString\u003e, cache: \u0026mut HashMap\u003cName, Schema\u003e) {\n        match s {\n            Schema::Array(s) =\u003e _extract(s, parent_ns, cache),\n            Schema::Map(s) =\u003e _extract(s, parent_ns, cache),\n            Schema::Union(s) =\u003e s.variants().iter().for_each(|s| _extract(s, parent_ns, cache)),\n            Schema::Record { name, fields, .. } =\u003e {\n                let parent = name.namespace.clone().or_else(|| parent_ns.to_owned());\n                fields.iter().for_each(|f| _extract(\u0026f.schema, \u0026parent, cache));\n                cache.insert(ns_name(name, parent_ns), s.clone());\n            }\n            Schema::Enum { name, .. } =\u003e {\n                cache.insert(ns_name(name, parent_ns), s.clone());\n            }\n            Schema::Fixed { name, .. } =\u003e {\n                cache.insert(ns_name(name, parent_ns), s.clone());\n            }\n            _ =\u003e (),\n        }\n    }\n    let mut cache = HashMap::new();\n    _extract(s, \u0026None, \u0026mut cache);\n    cache\n}\n\n#[cfg(test)]\nmod tests {\n    use std::{collections::HashSet, fs};\n\n    use apache_avro::{schema::Name, Schema};\n\n    use super::extract_all_refs;\n\n    #[test]\n    fn test_extract_all_refs_different_ns() {\n        let test_schema = fs::read_to_string(\"src/lib/schema_registry/avro_test_files/ref_to_another_ns.json\").unwrap();\n        let schema = Schema::parse_str(\u0026test_schema).unwrap();\n        let res = extract_all_refs(\u0026schema);\n        // assert\n        let names: HashSet\u003c_\u003e = res.keys().map(|n| n.to_owned()).collect();\n        assert!(names.contains(\u0026name(\"testTarget\", Some(\"nested.ns\"))));\n    }\n\n    #[test]\n    fn test_extract_all_refs() {\n        let test_schema = fs::read_to_string(\"src/lib/schema_registry/avro_test_files/schema.json\").unwrap();\n        let schema = Schema::parse_str(\u0026test_schema).unwrap();\n        let res = extract_all_refs(\u0026schema);\n        // assert\n        let names: HashSet\u003c_\u003e = res.keys().map(|n| n.to_owned()).collect();\n        assert_eq!(\n            names,\n            HashSet::from_iter(vec![\n                name(\"userInfo1\", Some(\"my.example\")),\n                name(\"userInfo2\", Some(\"my.example\")),\n                name(\"userInfo3\", Some(\"my.nested\")),\n                name(\"userInfo4\", Some(\"my.nested\")),\n                name(\"Suit\", Some(\"my.nested\")),\n                name(\"userInfo5\", Some(\"my.example\")),\n                name(\"userInfo6\", Some(\"my.example\")),\n                name(\"Suit\", Some(\"my.example\"))\n            ])\n        );\n    }\n\n    fn name(n: \u0026str, ns: Option\u003c\u0026str\u003e) -\u003e Name {\n        Name {\n            name: n.into(),\n            namespace: ns.map(|s| s.to_string()),\n        }\n    }\n}\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":39},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":39},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":24,"coverable":24},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","schema_registry","types.rs"],"content":"use std::collections::HashMap;\n\nuse apache_avro::schema::{Name, Schema as AvroSchema};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Deserialize, Serialize, Clone)]\npub struct Subject {\n    pub subject: String,\n    pub compatibility: String,\n    pub versions: Vec\u003cSchema\u003e,\n}\n\n#[derive(Debug, Deserialize, Serialize, Clone)]\npub struct Schema {\n    pub id: i32,\n    pub version: i32,\n    pub schema: String,\n}\n\n#[derive(Clone)]\npub struct BasicAuth {\n    pub username: String,\n    pub password: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Clone)]\npub struct ResolvedAvroSchema {\n    pub schema_id: i32,\n    pub schema: AvroSchema,\n    pub resolved_schemas: HashMap\u003cName, AvroSchema\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","lib","types.rs"],"content":"use std::time::{Duration, UNIX_EPOCH};\n\nuse serde::{Deserialize, Serialize};\nuse time::format_description::well_known;\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]\npub struct KafkaRecord\u003cT\u003e {\n    pub payload: Option\u003cT\u003e,\n    pub key: Option\u003cT\u003e,\n    pub topic: String,\n    /**\n    Unix timestamp in ms\n    */\n    pub timestamp: Option\u003cu64\u003e,\n    pub partition: i32,\n    pub offset: i64,\n    //todo: headers\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]\npub enum ParserMode {\n    String,\n    Avro,\n}\n\npub type RawKafkaRecord = KafkaRecord\u003cVec\u003cu8\u003e\u003e;\npub type ParsedKafkaRecord = KafkaRecord\u003cString\u003e;\n\nimpl ParsedKafkaRecord {\n    pub fn to_csv_line(\u0026self, parse_timestamp: bool) -\u003e String {\n        let unix_timestamp = self.timestamp.unwrap_or_default();\n        let timestamp = if parse_timestamp {\n            // Creates a new SystemTime from the specified number of whole seconds\n            let d = UNIX_EPOCH + Duration::from_millis(unix_timestamp);\n            // Create DateTime from SystemTime\n            time::OffsetDateTime::from(d).format(\u0026well_known::Rfc3339).unwrap()\n        } else {\n            unix_timestamp.to_string()\n        };\n        format!(\n            \"{};{};{};{};{}\",\n            timestamp,\n            self.partition,\n            self.offset,\n            self.key.clone().unwrap_or_default(),\n            self.payload.clone().unwrap_or_default()\n        )\n    }\n}\n\nimpl ParsedKafkaRecord {\n    pub(crate) fn to_string_header() -\u003e String {\n        format!(\"{};{};{};{};{}\", \"timestamp\", \"partition\", \"offset\", \"key\", \"payload\")\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":5},"fn_name":null}],"covered":12,"coverable":15},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","main.rs"],"content":"#![cfg_attr(all(not(debug_assertions), target_os = \"windows\"), windows_subsystem = \"windows\")]\nextern crate log;\n\n#[cfg(feature = \"integration_tests\")]\nmod integration_tests;\n\nmod api;\nmod lib;\nmod telemetry;\n\nuse crate::api::{\n    admin::{\n        create_topic, delete_consumer_group, delete_topic, describe_consumer_group, get_consumer_group_state,\n        get_last_offsets, get_topic_info, list_consumer_groups, list_topics, set_consumer_group,\n    },\n    configuration::{get_configuration, write_configuration},\n    consumer::{export_records, get_consumer_state, get_records_page, start_consumer, stop_consumer},\n    producer::produce_record,\n    schema_registry::{delete_subject, delete_subject_version, get_subject, list_subjects, post_schema},\n    utils::{export_datastore, parse_keystore, parse_truststore},\n};\nuse api::AppState;\nuse tauri::Manager;\nuse telemetry::log_active_user;\n\nfn main() {\n    env_logger::init();\n    log_active_user();\n    tauri::Builder::default()\n        .invoke_handler(tauri::generate_handler![\n            // utils\n            export_datastore,\n            parse_keystore,\n            parse_truststore,\n            // producer\n            produce_record,\n            // consumer\n            start_consumer,\n            stop_consumer,\n            get_consumer_state,\n            get_records_page,\n            export_records,\n            // schema\n            list_subjects,\n            get_subject,\n            delete_subject,\n            delete_subject_version,\n            post_schema,\n            // config\n            get_configuration,\n            write_configuration,\n            // admin topics\n            list_topics,\n            get_topic_info,\n            create_topic,\n            delete_topic,\n            get_last_offsets,\n            // admin consumer groups\n            get_consumer_group_state,\n            list_consumer_groups,\n            describe_consumer_group,\n            set_consumer_group,\n            delete_consumer_group,\n        ])\n        .setup(|app| {\n            app.manage(AppState::new(app.app_handle()));\n            Ok(())\n        })\n        .run(tauri::generate_context!())\n        .expect(\"error while running tauri application\");\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":42},{"path":["/","Users","andrewinci","Development","insulator2","backend","src","telemetry.rs"],"content":"use std::time::{SystemTime, UNIX_EPOCH};\n\nuse log::debug;\nuse serde::Serialize;\n#[derive(Serialize, Debug)]\nstruct GraphiteMetric {\n    // Graphite style name (required)\n    name: String,\n    // the resolution of the metric in seconds (required)\n    interval: u32,\n    // float64 value (required)\n    value: i32,\n    // unix timestamp in seconds (required)\n    time: u64,\n    // list of key=value pairs of tags (optional)\n    tags: Vec\u003cString\u003e,\n}\n\npub fn log_active_user() {\n    let url = \"https://graphite-prod-01-eu-west-0.grafana.net/graphite/metrics\";\n    if let Some(token) = std::option_env!(\"GRAPHITE_TOKEN\") {\n        debug!(\"Telemetry log active user\");\n        let metrics = vec![GraphiteMetric {\n            name: \"insulator2.active_user\".into(),\n            interval: 1,\n            value: 1,\n            time: SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs(),\n            tags: vec![get_locale_tag(), get_os_tag()],\n        }];\n        let client = reqwest::blocking::Client::new();\n        let res = client.post(url).bearer_auth(token).json(\u0026metrics).send();\n        debug!(\"Telemetry send result: {:?}\", res);\n    }\n}\n\nfn get_locale_tag() -\u003e String {\n    use sys_locale::get_locale;\n    format!(\"locale={}\", get_locale().unwrap_or_else(|| String::from(\"unknown\")))\n}\n\nfn get_os_tag() -\u003e String {\n    format!(\"os={}\", std::env::consts::OS)\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":17}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, pathToString(file.path)),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>